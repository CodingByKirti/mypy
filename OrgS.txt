Sub DebugConvertTextBoxes()
    Dim pres As Presentation
    Dim sld As Slide
    Dim shp As Shape
    Dim sa As Shape
    Dim layout As SmartArtLayout
    Dim lines() As String
    Dim i As Long
    
    ' Use the active presentation for testing
    Set pres = ActivePresentation
    
    ' Get Organization Chart layout
    Set layout = Application.SmartArtLayouts("Hierarchy1")
    If layout Is Nothing Then
        Debug.Print "SmartArt layout not found!"
        Exit Sub
    End If
    
    ' Loop through slides
    For Each sld In pres.Slides
        Debug.Print "Slide " & sld.SlideIndex & " ----------------"
        
        For i = 1 To sld.Shapes.Count
            Set shp = sld.Shapes(i)
            Debug.Print "  Shape " & i & ": " & shp.Name & " | Type=" & shp.Type
            
            If shp.HasTextFrame Then
                Debug.Print "    HasTextFrame = True"
                If shp.TextFrame.HasText Then
                    Debug.Print "    Text = " & shp.TextFrame.TextRange.Text
                    
                    ' Split text into lines
                    lines = Split(shp.TextFrame.TextRange.Text, vbCrLf)
                    
                    ' Add SmartArt
                    Set sa = sld.Shapes.AddSmartArt(layout, shp.Left, shp.Top, shp.Width, shp.Height)
                    sa.SmartArt.AllNodes(1).TextFrame2.TextRange.Text = lines(0)
                    
                    Debug.Print "    SmartArt created."
                    
                    ' Delete original
                    shp.Delete
                Else
                    Debug.Print "    TextFrame but no text."
                End If
            Else
                Debug.Print "    No TextFrame (probably just a rectangle)."
            End If
        Next i
    Next sld
    
    Debug.Print "Done."
End Sub

.....................

Option Explicit

Sub ConvertIndentedTextToOrgChart_Robust()
    Dim dlg As FileDialog
    Dim pres As Presentation
    Dim sld As Slide
    Dim shp As Shape
    Dim sa As Shape
    Dim layout As SmartArtLayout
    Dim lines() As String
    Dim i As Long
    
    On Error GoTo Fail
    
    ' 1) Pick a file
    Set dlg = Application.FileDialog(msoFileDialogFilePicker)
    With dlg
        .Title = "Select a PowerPoint file"
        .Filters.Clear
        .Filters.Add "PowerPoint Files", "*.pptx;*.pptm"
        If .Show <> -1 Then Exit Sub
    End With
    
    ' 2) Open presentation (no window)
    Set pres = Application.Presentations.Open(dlg.SelectedItems(1), WithWindow:=False)
    
    ' 3) Get Organization Chart layout safely
    Set layout = GetOrgChartLayoutSafe()
    If layout Is Nothing Then
        MsgBox "Organization Chart SmartArt layout not found. Please ensure SmartArt is available.", vbCritical
        GoTo Cleanup
    End If
    
    ' 4) Process slides
    For Each sld In pres.Slides
        ' Iterate shapes in reverse to avoid index issues when deleting
        For i = sld.Shapes.Count To 1 Step -1
            Set shp = sld.Shapes(i)
            
            If HasUsableText(shp) Then
                lines = Split(NormalizeText(shp.TextFrame.TextRange.Text), vbCrLf)
                If UBound(lines) < 0 Then GoTo NextShape
                
                ' Add SmartArt at same position/size
                Set sa = sld.Shapes.AddSmartArt(layout, shp.Left, shp.Top, shp.Width, shp.Height)
                
                ' Build hierarchy from indentation
                BuildOrgChartFromIndentedLines sa, lines
                
                ' Delete original text box (optional)
                shp.Delete
            End If
NextShape:
        Next i
    Next sld
    
    ' 5) Save and close
    pres.Save
    
Cleanup:
    If Not pres Is Nothing Then pres.Close
    Exit Sub
    
Fail:
    MsgBox "Error: " & Err.Description, vbCritical
    Resume Cleanup
End Sub

' ---------- Helpers ----------

Private Function GetOrgChartLayoutSafe() As SmartArtLayout
    ' Try common names first
    On Error Resume Next
    Set GetOrgChartLayoutSafe = Application.SmartArtLayouts("Hierarchy1")
    If Not GetOrgChartLayoutSafe Is Nothing Then Exit Function
    Set GetOrgChartLayoutSafe = Application.SmartArtLayouts("HierarchyOrganizationChart")
    If Not GetOrgChartLayoutSafe Is Nothing Then Exit Function
    On Error GoTo 0
    
    ' Fallback: scan layouts for hierarchy + organization
    Dim sal As SmartArtLayout
    For Each sal In Application.SmartArtLayouts
        If (InStr(1, sal.Name, "Hierarchy", vbTextCompare) > 0 Or _
            InStr(1, sal.Description, "Hierarchy", vbTextCompare) > 0) Then
            If (InStr(1, sal.Name, "Organization", vbTextCompare) > 0 Or _
                InStr(1, sal.Description, "Organization", vbTextCompare) > 0) Then
                Set GetOrgChartLayoutSafe = sal
                Exit Function
            End If
        End If
    Next sal
End Function

Private Function HasUsableText(shp As Shape) As Boolean
    On Error Resume Next
    HasUsableText = (shp.HasTextFrame = msoTrue) And _
                    (shp.TextFrame.HasText = msoTrue) And _
                    (Trim$(shp.TextFrame.TextRange.Text) <> "")
End Function

Private Function NormalizeText(ByVal s As String) As String
    ' Normalize line breaks and trim
    Dim t As String
    t = Replace(s, vbCrLf, vbLf)
    t = Replace(t, vbCr, vbLf)
    t = Replace(t, vbLf, vbCrLf)
    NormalizeText = Trim$(t)
End Function

Private Function GetIndentLevel(ByVal s As String) As Long
    ' Tabs count as 1 level; every 4 spaces = 1 level
    Dim i As Long, tabs As Long, spaces As Long, ch As String
    For i = 1 To Len(s)
        ch = Mid$(s, i, 1)
        If ch = vbTab Then
            tabs = tabs + 1
        ElseIf ch = " " Then
            spaces = spaces + 1
        Else
            Exit For
        End If
    Next i
    GetIndentLevel = tabs + (spaces \ 4)
End Function

Private Sub BuildOrgChartFromIndentedLines(sa As Shape, lines() As String)
    Dim levelParents() As SmartArtNode   ' parent node per level
    Dim lastNodeAtLevel() As SmartArtNode ' last created node per level (for siblings)
    Dim maxLevels As Long: maxLevels = 20 ' adjust if needed
    ReDim levelParents(0 To maxLevels)
    ReDim lastNodeAtLevel(0 To maxLevels)
    
    Dim i As Long, lvl As Long
    Dim textLine As String
    Dim node As SmartArtNode
    Dim parent As SmartArtNode
    
    ' Initialize root
    sa.SmartArt.AllNodes(1).TextFrame2.TextRange.Text = ""
    Set levelParents(0) = sa.SmartArt.AllNodes(1)
    Set lastNodeAtLevel(0) = levelParents(0)
    
    For i = LBound(lines) To UBound(lines)
        textLine = Trim$(lines(i))
        If textLine = "" Then GoTo NextLine
        
        lvl = GetIndentLevel(lines(i))
        If lvl < 0 Then lvl = 0
        If lvl > maxLevels Then lvl = maxLevels
        
        If lvl = 0 And lastNodeAtLevel(0).TextFrame2.TextRange.Text = "" Then
            ' First root line fills the existing root node
            lastNodeAtLevel(0).TextFrame2.TextRange.Text = textLine
        Else
            ' Determine parent for this level
            If lvl = 0 Then
                ' Another root-level item → sibling of root
                Set node = lastNodeAtLevel(0).InsertNode(msoSmartArtNodeAfter)
                node.TextFrame2.TextRange.Text = textLine
                Set lastNodeAtLevel(0) = node
                Set levelParents(0) = node
            Else
                ' Child or deeper
                If levelParents(lvl - 1) Is Nothing Then
                    ' If missing parent, fallback to nearest available above
                    Dim back As Long
                    back = lvl - 1
                    Do While back >= 0 And levelParents(back) Is Nothing
                        back = back - 1
                    Loop
                    If back < 0 Then
                        Set parent = sa.SmartArt.AllNodes(1)
                    Else
                        Set parent = levelParents(back)
                    End If
                Else
                    Set parent = levelParents(lvl - 1)
                End If
                
                ' If we already created a node at this level, add a sibling; else add a child
                If Not lastNodeAtLevel(lvl) Is Nothing Then
                    Set node = lastNodeAtLevel(lvl).InsertNode(msoSmartArtNodeAfter)
                Else
                    Set node = parent.InsertNode(msoSmartArtNodeBelow)
                End If
                
                node.TextFrame2.TextRange.Text = textLine
                Set lastNodeAtLevel(lvl) = node
                Set levelParents(lvl) = node
            End If
        End If
NextLine:
    Next i
End Sub
////////////////////////////////////////////////////////

for _, rr in l6_actuals.iterrows():
    line = "\t\t" + line_for_actual(rr, mgr_id=rr.get("Employee ID"))
    if is_md(rr): md_boxes.append(line)
    elif str(rr.get("GCB","")).strip() == "3": gcb3_boxes.append(line)
    elif str(rr.get("GCB","")).strip() == "4": gcb4_boxes.append(line)
    elif str(rr.get("GCB","")).strip() == "5": gcb5_boxes.append(line)
    elif str(rr.get("GCB","")).strip() == "6": gcb6_boxes.append(line)
    else: gcb6_boxes.append(line)

    # NEW: detect extra GCB3 at L6
    if str(rr.get("GCB","")).strip() == "3" and rr.get("BFG") == selected_bfg:
        if rr.get("Employee ID") not in processed_roots:
            extra_roots.add(rr.get("Employee ID"))

# Generate extra slides for GCB3s found at L6
for extra_id in extra_roots:
    export_indented_text_full(extra_id, df_actual, df_open,
                              direct_counts, open_pos_counts,
                              ppt_app, pres, max_per_slide,
                              show_names, expanded_list)
    processed_roots.add(extra_id)


processed_roots = set()
extra_roots = set()


....
# --- Compression logic ---
count_lines = []
if total_boxes > max_per_slide:
    # Step 1: collapse GCB5+6 into counts
    if gcb_counts["5"] or gcb_counts["6"]:
        count_lines.append(f"Count {gcb_counts['5']} GCB5")
        count_lines.append(f"Count {gcb_counts['6']} GCB6")

    new_total = len(details) + (1 if count_lines else 0) + len(open_boxes)
    if new_total > max_per_slide:
        # Step 2: collapse GCB4 as well
        details = [d for d in details if not d.strip().endswith("GCB4")]
        count_lines = [
            f"Count {gcb_counts['4']} GCB4",
            f"Count {gcb_counts['5']} GCB5",
            f"Count {gcb_counts['6']} GCB6"
        ]

        new_total = len(details) + (1 if count_lines else 0) + len(open_boxes)
        if new_total > max_per_slide:
            # Step 3: final fallback — counts for all GCB levels
            details = []
            count_lines = [
                f"Count {gcb_counts['3']} GCB3",
                f"Count {gcb_counts['4']} GCB4",
                f"Count {gcb_counts['5']} GCB5",
                f"Count {gcb_counts['6']} GCB6"
            ]
            if expanded_list is not None:
                expanded_list.append(root_id)
.................

def export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              show_names=False,
                              max_per_slide=10,
                              expanded_list=None):
    """
    Export indented text for a given root with progressive compression rules.
    - Collapse GCB5+6 if >10 boxes
    - Collapse GCB4+5+6 if still >10
    - Final fallback: counts for all GCB levels + open positions
    """

    lines = []
    # IMPORTANT: children/open_boxes must come from full dataset, not BFG-filtered subset
    children = df_actual.loc[df_actual["Functional Manager Employee ID"] == root_id].to_dict("records")
    open_boxes = df_open.loc[df_open["Functional Manager Employee ID"] == root_id].to_dict("records")

    total_boxes = len(children) + len(open_boxes)

    # Collect counts
    gcb_counts = {"MD": 0, "3": 0, "4": 0, "5": 0, "6": 0}
    details = []
    for child in children:
        gcb = str(child.get("GCB", ""))
        if gcb in ["MD", "3", "4"]:
            details.append("\t" + line_for_actual(child, root_id, level=5, show_names=show_names))
        if gcb in gcb_counts:
            gcb_counts[gcb] += 1

    # --- Compression logic ---
    count_lines = []
    if total_boxes > max_per_slide:
        # Step 1: collapse GCB5+6
        if gcb_counts["5"] or gcb_counts["6"]:
            count_lines.append(f"Count {gcb_counts['5']} GCB5")
            count_lines.append(f"Count {gcb_counts['6']} GCB6")

        new_total = len(details) + (1 if count_lines else 0) + len(open_boxes)
        if new_total > max_per_slide:
            # Step 2: collapse GCB4 as well
            details = [d for d in details if not d.strip().endswith("GCB4")]
            count_lines = [
                f"Count {gcb_counts['4']} GCB4",
                f"Count {gcb_counts['5']} GCB5",
                f"Count {gcb_counts['6']} GCB6"
            ]

            new_total = len(details) + (1 if count_lines else 0) + len(open_boxes)
            if new_total > max_per_slide:
                # Step 3: final fallback
                details = []
                count_lines = [
                    f"Count {gcb_counts['3']} GCB3",
                    f"Count {gcb_counts['4']} GCB4",
                    f"Count {gcb_counts['5']} GCB5",
                    f"Count {gcb_counts['6']} GCB6"
                ]
                if expanded_list is not None:
                    expanded_list.append(root_id)

    # --- Append to lines ---
    for d in details:
        lines.append(d)
    if count_lines:
        indented_block = "\n".join("\t\t" + line for line in count_lines if not line.endswith("0"))
        lines.append(indented_block)
    for op in open_boxes:
        lines.append("\t\t" + line_for_actual(op, root_id, level=5, show_names=show_names))

    return lines



import pandas as pd

def clean(val):
    """
    Normalize values for display in org chart.
    Handles NaN, None, empty strings, whitespace, 'Unspecified', '#N/A', <NA>.
    """
    if val is None:
        return ""
    val = str(val).strip()
    if val in ["", "Unspecified", "#N/A", "<NA>", "nan", "NaN"]:
        return ""
    return val


def line_for_actual(row, mgr_id=None, level=0, show_names=True):
    """
    Build the text line for an employee row.
    Includes name only if show_names=True.
    """
    name = clean(row.get("Employee Name", "")) if show_names else ""
    title = clean(row.get("Position Title", ""))
    gcb   = clean(row.get("GCB", ""))
    country = clean(row.get("Country R3", ""))

    header_parts = [p for p in [name, title] if p]
    header = " | ".join(header_parts)
    footer_parts = [p for p in [gcb, country] if p]
    footer = " | ".join(footer_parts)

    if footer:
        line = f"{header}\n{footer}" if header else footer
    else:
        line = header

    return line


def export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              show_names=False,
                              max_per_slide=10,
                              expanded_list=None,
                              pres=None):
    """
    Export indented text for a given root with progressive compression rules.
    - Collapse GCB5+6 if >10 boxes
    - Collapse GCB4+5+6 if still >10
    - Final fallback: counts for all GCB levels + open positions
    Returns a list of indented text lines.
    """

    lines = []
    children = df_actual.loc[df_actual["Functional Manager Employee ID"] == root_id].to_dict("records")
    open_boxes = df_open.loc[df_open["Functional Manager Employee ID"] == root_id].to_dict("records")

    # Step 1: total boxes
    total_boxes = len(children) + len(open_boxes)

    # Collect counts
    gcb_counts = {"MD": 0, "3": 0, "4": 0, "5": 0, "6": 0}
    details = []
    for child in children:
        gcb = str(child.get("GCB", ""))
        if gcb in ["MD", "3", "4"]:
            details.append("\t" + line_for_actual(child, root_id, level=5, show_names=show_names))
        if gcb in gcb_counts:
            gcb_counts[gcb] += 1

    # --- Compression logic ---
    count_lines = []
    if total_boxes > max_per_slide:
        # Collapse GCB5+6
        if gcb_counts["5"] or gcb_counts["6"]:
            count_lines.append(f"Count {gcb_counts['5']} GCB5")
            count_lines.append(f"Count {gcb_counts['6']} GCB6")

        new_total = len(details) + (1 if count_lines else 0) + len(open_boxes)
        if new_total > max_per_slide:
            # Collapse GCB4 as well
            details = [d for d in details if not d.strip().endswith("GCB4")]
            if gcb_counts["4"] or gcb_counts["5"] or gcb_counts["6"]:
                count_lines = [
                    f"Count {gcb_counts['4']} GCB4",
                    f"Count {gcb_counts['5']} GCB5",
                    f"Count {gcb_counts['6']} GCB6"
                ]

            new_total = len(details) + (1 if count_lines else 0) + len(open_boxes)
            if new_total > max_per_slide:
                # Final fallback: counts for all GCB levels
                count_lines = [
                    f"Count {gcb_counts['3']} GCB3",
                    f"Count {gcb_counts['4']} GCB4",
                    f"Count {gcb_counts['5']} GCB5",
                    f"Count {gcb_counts['6']} GCB6"
                ]
                details = []  # no individuals
                if expanded_list is not None and pres is not None:
                    create_expanded_slide(root_id, children, open_boxes, pres, show_names, expanded_list)

    # --- Append to lines ---
    for d in details:
        lines.append(d)
    if count_lines:
        indented_block = "\n".join("\t\t" + line for line in count_lines if not line.endswith("0"))
        lines.append(indented_block)
    for op in open_boxes:
        lines.append("\t\t" + line_for_actual(op, root_id, level=5, show_names=show_names))

    return lines


def create_expanded_slide(level5_id, children, open_boxes, pres, show_names, expanded_list):
    """
    Create an expanded slide for a Level-5 employee with too many direct reports.
    Shows:
      - GCB3 and GCB4 individually
      - GCB5+6 combined in one box
      - Open positions in one box
    Also stores (employee name, slide number) in expanded_list.
    """

    slide = pres.Slides.Add(pres.Slides.Count+1, 1)
    slide.Shapes.Title.TextFrame.TextRange.Text = f"{level5_id} (Expanded)"

    gcb3s = [c for c in children if str(c.get("GCB")) == "3"]
    gcb4s = [c for c in children if str(c.get("GCB")) == "4"]
    gcb5s = [c for c in children if str(c.get("GCB")) == "5"]
    gcb6s = [c for c in children if str(c.get("GCB")) == "6"]

    left, top, width, height = 50, 100, 300, 50
    spacing = 60

    def add_box(text, l, t):
        box = slide.Shapes.AddTextbox(1, l, t, width, height)
        box.TextFrame.TextRange.Text = text
        box.TextFrame.TextRange.ParagraphFormat.Alignment = 1
        return box

    offset = 0
    for i, emp in enumerate(gcb3s):
        name = clean(emp.get("Employee Name", "")) if show_names else ""
        title = clean(emp.get("Position Title", ""))
        text = " | ".join([p for p in [name, title] if p])
        add_box(f"GCB3: {text}", left, top + offset + i*spacing)
    offset += len(gcb3s)*spacing

    for i, emp in enumerate(gcb4s):
        name = clean(emp.get("Employee Name", "")) if show_names else ""
        title = clean(emp.get("Position Title", ""))
        text = " | ".join([p for p in [name, title] if p])
        add_box(f"GCB4: {text}", left, top + offset + i*spacing)
    offset += len(gcb4s)*spacing

    gcb5_count = len(gcb5s)
    gcb6_count = len(gcb6s)
    if gcb5_count or gcb6_count:
        add_box(f"Count {gcb5_count} GCB5\nCount {gcb6_count} GCB6", left, top + offset)
        offset += spacing

    if open_boxes:
        op_texts = []
        for op in open_boxes:
            title = clean(op.get("Position Title", ""))
            op_texts.append(f"Open: {title}")
        add_box("\n".join(op_texts), left, top + offset)

    expanded_list.append((level5_id, slide.SlideIndex))
    return slide.SlideIndex


def add_summary_slide(pres, expanded_list):
    """
    Add a final slide listing all Level-5 employees with expanded slides.
    """
    if not expanded_list:
        return

    slide = pres.Slides.Add(pres.Slides.Count+1, 1)
    slide.Shapes.Title.TextFrame.TextRange.Text = "Expanded Level-5 Employees"

    summary_text = [f"{emp} → Slide {idx}" for emp, idx in expanded_list]
    textbox = slide.Shapes.AddTextbox(1, 50, 100, 400, 400)
    textbox.TextFrame.TextRange.Text = "\n".join(summary_text)
    textbox.TextFrame.ParagraphFormat.Alignment = 1


def generate_orgchart_ppt(df_actual, df_open, selected_bfg, pres,
                          show_names=True, max_per_slide=10,
                          excel_path="OrgChart_Validation.xlsx"):
    """
    Generate a PPT with indented org charts for all MD and GCB3 under selected BFG.
    Adds:
      - Extra slide listing employees with too many direct reports
      - Validation summary (actual vs considered counts)
      - Writes validation summary into Excel
    """

    expanded_list = []
    validation_rows = []

    # Filter for selected BFG
    df_actual_bfg = df_actual[df_actual["BFG"] == selected_bfg]
    df_open_bfg   = df_open[df_open["BFG"] == selected_bfg]

    # Get all MD and GCB3 roots (including standalone GCB3s)
    roots = df_actual_bfg[df_actual_bfg["GCB"].isin(["MD", "3"])]["Employee ID"].unique()

    for root_id in roots:
        # Export indented text lines with compression rules
        lines = export_indented_text_full(
            root_id,
            df_actual_bfg,
            df_open_bfg,
            direct_counts=None,
            open_pos_counts=None,
            show_names=show_names,
            max_per_slide=max_per_slide,
            expanded_list=expanded_list,
            pres=pres
        )

        # Create a slide for this root
        slide = pres.Slides.Add(pres.Slides.Count+1, 1)
        root_name = df_actual_bfg.loc[df_actual_bfg["Employee ID"] == root_id, "Employee Name"].values[0]
        slide.Shapes.Title.TextFrame.TextRange.Text = f"{root_name} ({selected_bfg})"

        left, top, width, height = 50, 100, 400, 50
        spacing = 60
        for i, line in enumerate(lines):
            box = slide.Shapes.AddTextbox(1, left, top + i*spacing, width, height)
            box.TextFrame.TextRange.Text = line
            box.TextFrame.TextRange.ParagraphFormat.Alignment = 1

        # --- Validation summary ---
        actual_count = len(df_actual_bfg[df_actual_bfg["Functional Manager Employee ID"] == root_id])
        open_count   = len(df_open_bfg[df_open_bfg["Functional Manager Employee ID"] == root_id])
        considered_count = sum(1 for l in lines if l.strip())  # number of boxes actually shown

        validation_rows.append({
            "Root Employee": root_name,
            "Employee ID": root_id,
            "Actual Direct Reports": actual_count,
            "Open Positions": open_count,
            "Considered in Org Chart": considered_count
        })

    # --- Extra slide for expanded employees ---
    add_summary_slide(pres, expanded_list)

    # --- Write validation summary to Excel ---
    df_validation = pd.DataFrame(validation_rows)
    df_validation.to_excel(excel_path, index=False)

    return pres, df_validation

# Create a new PPT
pres = ppt_app.Presentations.Add()

# Generate org chart PPT + validation summary
pres, df_validation = generate_orgchart_ppt(
    df_actual=df_final,
    df_open=df_open_bfg,
    selected_bfg="Finance",
    pres=pres,
    show_names=True,
    max_per_slide=10,
    excel_path="OrgChart_Validation.xlsx"
)

print(df_validation)
..........................................
def collect_covered_ids(df, root_id):
    """
    Recursively collect all employee IDs under a given root.
    Includes the root itself and all descendants.
    """
    covered = set()
    stack = [root_id]

    while stack:
        current = stack.pop()
        if pd.isna(current):
            continue
        if current in covered:
            continue
        covered.add(current)

        # Find direct reports of current
        children = df.loc[df["Functional Manager Employee ID"] == current, "Employee ID"].dropna().tolist()
        stack.extend(children)

    return covered


if __name__ == "__main__":
    import os
    import win32com.client

    output_dir = os.path.join(os.getcwd(), "OrgCharts")
    os.makedirs(output_dir, exist_ok=True)

    # Identify MDs
    mds = df_final[df_final["GCB"] == "MD"]["Employee ID"].dropna().unique().tolist()

    # Identify all GCB3s (note: adjust if your data stores numeric '3' instead of string 'GCB3')
    gcb3s = df_final[df_final["GCB"].isin(["3", "GCB3"])]["Employee ID"].dropna().unique().tolist()

    # Collect coverage under MDs
    covered_ids = set()
    for md_id in mds:
        covered_ids |= collect_covered_ids(df_final, md_id)

    # Uncovered GCB3s = all GCB3s minus those covered under any MD
    uncovered_gcb3s = [g for g in gcb3s if g not in covered_ids]

    # Roots = MDs + uncovered GCB3s
    roots = mds + uncovered_gcb3s

    if not roots:
        print("No MDs or uncovered GCB3s found in df_final. Nothing to generate.")
    else:
        # Create one shared PPT per BFG
        ppt_app = win32com.client.Dispatch("PowerPoint.Application")
        ppt_app.Visible = True
        pres = ppt_app.Presentations.Add()

        covered_ids = set()

        # Filter open positions once for this BFG
        df_open_bfg = df_open_enriched[
            df_open_enriched["Functional Manager Employee ID"].isin(df_final["Employee ID"])
        ]

        for root_id in roots:
            role_vals = df_final.loc[df_final["Employee ID"] == root_id, "GCB"].values
            role = role_vals[0] if len(role_vals) else "Unknown"
            print(f"Generating for {role} {root_id}...")

            # Optional: graphical org chart per root
            draw_orgchart(root_id, df_final, df_open_bfg,
                          direct_counts_actual, open_pos_counts, ppt_app)

            # Generate indented hierarchy slides (Excel saving disabled)
            export_indented_text_full(
                root_id, df_final, df_open_bfg,
                direct_counts_actual, open_pos_counts,
                excel_path=None,          # disabled Excel saving
                ppt_path=None,            # skip per-root PPT saving
                ppt_app=ppt_app,
                pres=pres,                # shared presentation
                max_per_slide=7
            )

            # Track coverage
            covered_ids |= collect_covered_ids(df_final, root_id)

        # Save once for the whole BFG
        bfg_name = "MyBFG"  # replace with actual BFG identifier if available
        pres.SaveAs(os.path.join(output_dir, f"Indented_BFG_{bfg_name}.pptx"))
        pres.Close()

        print(f"Workflow complete. Files saved under: {output_dir}")
        check_coverage(df_final, covered_ids)




// correct
def export_indented_text_full(level_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              excel_path=None,
                              ppt_path=None,
                              ppt_app=None,
                              pres=None,
                              max_per_slide=7):
    """
    Export indented hierarchy lines with batching:
      - Max 7 children per slide
      - Handles MD roots (GCB == 'MD') and uncovered GCB3 roots (GCB == '3')
      - At last level: if >7 reportees, show details only for MD/GCB3/GCB4,
        collapse GCB5/GCB6 into counts, and ALWAYS keep open positions as boxes.
    """

    import os
    import pandas as pd
    import win32com.client
    from openpyxl import Workbook

    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() == "unspecified" else s

    def line_for_actual(row, mgr_id=None, level=0):
        name = clean(row.get("Employee Name", ""))
        title = clean(row.get("Position Title", ""))
        gcb   = clean(row.get("GCB", ""))
        country = clean(row.get("Country R3", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = " | ".join([p for p in [gcb, country] if p])
        line = f"{header}\n{footer}" if footer else header

        has_mgr = (mgr_id is not None) and (not pd.isna(mgr_id))
        if level >= 5 and has_mgr:
            if open_pos_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Open Positions: {open_pos_counts[mgr_id]}"
            if direct_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Direct Reports: {direct_counts[mgr_id]}"
        return line

    def line_for_open(op_row, level=0):
        title = clean(op_row.get("Position Title", ""))
        if not title: return None
        pid = op_row.get("PID")
        gcb, country = "", ""
        match = df_actual[df_actual["PID"] == pid]
        if not match.empty:
            gcb = clean(match.iloc[0].get("GCB", ""))
            country = clean(match.iloc[0].get("Country R3", ""))
        header = f"<Open Position> | {title}"
        footer = " | ".join([p for p in [gcb, country] if p])
        line = f"{header}\n{footer}" if footer else header
        return ("\t"*level) + line

    def gcb_rank(val):
        val = str(val).strip()
        if val == "MD": return 1
        if val == "3": return 2
        if val == "4": return 3
        if val == "5": return 4
        if val == "6": return 5
        return 99

    # Default paths
    excel_path = excel_path or os.path.join(os.getcwd(), f"Indented_{level_id}.xlsx")
    ppt_path   = ppt_path   or os.path.join(os.getcwd(), f"Indented_{level_id}.pptx")

    # Root row
    root_df = df_actual[df_actual["Employee ID"] == level_id]
    if root_df.empty:
        raise ValueError(f"Employee ID {level_id} not found in df_actual.")
    root_row = root_df.iloc[0]
    root_gcb = str(root_row.get("GCB", "")).strip()

    if root_gcb == "MD":
        root_line = line_for_actual(root_row, level_id, level=4)
    elif root_gcb == "3":
        root_line = line_for_actual(root_row, level_id, level=3)
    else:
        root_line = line_for_actual(root_row, level_id, level=4)

    child_actuals = df_actual[df_actual["Functional Manager Employee ID"] == level_id]
    child_opens   = df_open[df_open["Functional Manager Employee ID"] == level_id]
    child_items = [("actual", r) for _, r in child_actuals.iterrows()]
    child_items += [("open", r) for _, r in child_opens.iterrows()]

    # Excel workbook
    wb = Workbook()
    ws = wb.active
    ws.title = "Slide_1"
    slide_idx = 1

    # PowerPoint
    if pres is None:
        ppt = ppt_app or win32com.client.Dispatch("PowerPoint.Application")
        ppt.Visible = True
        pres_local = ppt.Presentations.Add()
    else:
        pres_local = pres

    def write_slide(lines):
        nonlocal slide_idx
        if slide_idx == 1 and wb.active.title == "Slide_1" and wb.active.max_row == 1:
            ws = wb.active
            ws.delete_rows(1, ws.max_row)
        else:
            ws = wb.create_sheet(title=f"Slide_{slide_idx}")
        ws.append(["Hierarchy"])
        for ln in lines:
            ws.append([ln])
        slide = pres_local.Slides.Add(pres_local.Slides.Count+1, 12)
        tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
        tr.Font.Size = 9
        tr.Text = "\r".join(lines)
        slide_idx += 1

    # --- Batch children ---
    for i in range(0, len(child_items), max_per_slide):
        batch = child_items[i:i+max_per_slide]
        lines = [root_line]

        for kind, child in batch:
            if kind == "actual":
                cid = child.get("Employee ID")
                cid = None if pd.isna(cid) else cid
                child_line = "\t" + line_for_actual(child, cid, level=5)
                lines.append(child_line)

                # Collect grandchildren (L6 under this L5)
                gc_actuals = df_actual[df_actual["Functional Manager Employee ID"] == cid]
                gc_opens   = df_open[df_open["Functional Manager Employee ID"] == cid]
                gc_items = [("actual", rr) for _, rr in gc_actuals.iterrows()]
                gc_items += [("open", rr) for _, rr in gc_opens.iterrows()]

                # Sort grandchildren: MD > 3 > 4 > 5 > 6 (open positions later kept explicitly)
                gc_items.sort(key=lambda tup: gcb_rank(tup[1].get("GCB", "")))

                if len(gc_items) <= max_per_slide:
                    # Normal display
                    for kind2, gc in gc_items:
                        if kind2 == "actual":
                            gid = gc.get("Employee ID")
                            gid = None if pd.isna(gid) else gid
                            lines.append("\t\t" + line_for_actual(gc, gid, level=6))
                        else:
                            op_line = line_for_open(gc, level=2)
                            if op_line: lines.append(op_line)
                else:
                    # Overflow: details for MD/3/4 + ALWAYS open positions; counts for 5/6
                    details = []
                    open_boxes = []
                    gcb5_count = 0
                    gcb6_count = 0

                    for kind2, gc in gc_items:
                        gcb_val = str(gc.get("GCB", "")).strip()
                        if kind2 == "open":
                            op_line = line_for_open(gc, level=2)
                            if op_line: open_boxes.append(op_line)
                        else:
                            if gcb_val in ["MD", "3", "4"]:
                                gid = gc.get("Employee ID")
                                gid = None if pd.isna(gid) else gid
                                details.append("\t\t" + line_for_actual(gc, gid, level=6))
                            elif gcb_val == "5":
                                gcb5_count += 1
                            elif gcb_val == "6":
                                gcb6_count += 1
                            else:
                                # Unknown/blank GCB: treat as lower priority count
                                gcb6_count += 1

                    # Add details (MD/3/4), then open positions, then counts
                    for d in details:
                        lines.append(d)
                    for op in open_boxes:
                        lines.append(op)
                    if gcb5_count > 0:
                        lines.append(f"\t\tGCB5 Count: {gcb5_count}")
                    if gcb6_count > 0:
                        lines.append(f"\t\tGCB6 Count: {gcb6_count}")
            else:
                # Child is an open position under the root (L5 level open)
                op_line = line_for_open(child, level=1)
                if op_line: lines.append(op_line)

        write_slide(lines)

    # Save Excel always
    wb.save(excel_path)

    # Save PPT only if local pres was created
    if pres is None and ppt_path:
        pres_local.SaveAs(ppt_path)
        pres_local.Close()

    print(f"Excel saved: {excel_path}")
    if pres is None and ppt_path:
        print(f"PPT saved: {ppt_path}")------------------------------




if __name__ == "__main__":
    import os
    import win32com.client

    output_dir = os.path.join(os.getcwd(), "OrgCharts")
    os.makedirs(output_dir, exist_ok=True)

    # Identify MDs
    mds = df_final[df_final["GCB"] == "MD"]["Employee ID"].dropna().unique().tolist()

    # Identify GCB3s
    gcb3s = df_final[df_final["GCB"] == "GCB3"]["Employee ID"].dropna().unique().tolist()

    # Find standalone GCB3s (not reporting to any MD)
    md_ids_set = set(mds)
    standalone_gcb3s = []
    for gcb3_id in gcb3s:
        mgr_vals = df_final.loc[df_final["Employee ID"] == gcb3_id, "Functional Manager Employee ID"].values
        mgr_id = mgr_vals[0] if len(mgr_vals) else None
        if mgr_id is None or mgr_id not in md_ids_set:
            standalone_gcb3s.append(gcb3_id)

    # Combine MDs + standalone GCB3s as roots
    roots = mds + standalone_gcb3s

    if not roots:
        print("No MDs or standalone GCB3s found in df_final. Nothing to generate.")
    else:
        # Create one shared PPT per BFG
        ppt_app = win32com.client.Dispatch("PowerPoint.Application")
        ppt_app.Visible = True
        pres = ppt_app.Presentations.Add()

        covered_ids = set()

        # Filter open positions once for this BFG
        df_open_bfg = df_open_enriched[
            df_open_enriched["Functional Manager Employee ID"].isin(df_final["Employee ID"])
        ]

        for root_id in roots:
            role_vals = df_final.loc[df_final["Employee ID"] == root_id, "GCB"].values
            role = role_vals[0] if len(role_vals) else "Unknown"
            print(f"Generating for {role} {root_id}...")

            # Optional: graphical org chart per root
            draw_orgchart(root_id, df_final, df_open_bfg,
                          direct_counts_actual, open_pos_counts, ppt_app)

            # Generate indented Excel (per root) + add slides to shared PPT
            export_indented_text_full(
                root_id, df_final, df_open_bfg,
                direct_counts_actual, open_pos_counts,
                excel_path=os.path.join(output_dir, f"Indented_{role}_{root_id}.xlsx"),
                ppt_path=None,              # skip per-root PPT saving
                ppt_app=ppt_app,
                pres=pres,                  # shared presentation
                max_per_slide=7
            )

            # Track coverage
            covered_ids |= collect_covered_ids(df_final, root_id)

        # Save once for the whole BFG
        bfg_name = "MyBFG"  # replace with actual BFG identifier if available
        pres.SaveAs(os.path.join(output_dir, f"Indented_BFG_{bfg_name}.pptx"))
        pres.Close()

        print(f"Workflow complete. Files saved under: {output_dir}")
        check_coverage(df_final, covered_ids)
........

def export_indented_text_full(level_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              excel_path=None,
                              ppt_path=None,
                              ppt_app=None,
                              pres=None,
                              max_per_slide=7):
    """
    Export indented hierarchy lines with batching:
      - Max 7 children per slide
      - Handles MD roots (L4) and standalone GCB3 roots
    Each slide is written to Excel (sheet) and PPT (slide).
    """

    import os
    import pandas as pd
    import win32com.client
    from openpyxl import Workbook

    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() == "unspecified" else s

    def line_for_actual(row, mgr_id=None, level=0):
        name = clean(row.get("Employee Name", ""))
        title = clean(row.get("Position Title", ""))
        gcb   = clean(row.get("GCB", ""))
        country = clean(row.get("Country R3", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = " | ".join([p for p in [gcb, country] if p])
        line = f"{header}\n{footer}" if footer else header
        if level >= 5 and mgr_id:
            if open_pos_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Open Positions: {open_pos_counts[mgr_id]}"
            if direct_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Direct Reports: {direct_counts[mgr_id]}"
        return line

    def line_for_open(op_row, level=0):
        title = clean(op_row.get("Position Title", ""))
        if not title: return None
        pid = op_row.get("PID")
        gcb, country = "", ""
        match = df_actual[df_actual["PID"] == pid]
        if not match.empty:
            gcb = clean(match.iloc[0].get("GCB", ""))
            country = clean(match.iloc[0].get("Country R3", ""))
        header = f"<Open Position> | {title}"
        footer = " | ".join([p for p in [gcb, country] if p])
        line = f"{header}\n{footer}" if footer else header
        return ("\t"*level) + line

    # Default paths
    excel_path = excel_path or os.path.join(os.getcwd(), f"Indented_{level_id}.xlsx")
    ppt_path   = ppt_path   or os.path.join(os.getcwd(), f"Indented_{level_id}.pptx")

    # Root row
    root_df = df_actual[df_actual["Employee ID"] == level_id]
    if root_df.empty:
        raise ValueError(f"Employee ID {level_id} not found in df_actual.")
    root_row = root_df.iloc[0]
    root_gcb = root_row.get("GCB", "")
    root_line = line_for_actual(root_row, level_id,
                                level=3 if root_gcb == "GCB3" else 4)

    # Collect children under root
    child_actuals = df_actual[df_actual["Functional Manager Employee ID"] == level_id]
    child_opens   = df_open[df_open["Functional Manager Employee ID"] == level_id]
    child_items = [("actual", r) for _, r in child_actuals.iterrows()]
    child_items += [("open", r) for _, r in child_opens.iterrows()]

    # Excel workbook
    wb = Workbook()
    ws = wb.active
    ws.title = "Slide_1"
    slide_idx = 1

    # PowerPoint
    if pres is None:
        ppt = ppt_app or win32com.client.Dispatch("PowerPoint.Application")
        ppt.Visible = True
        pres_local = ppt.Presentations.Add()
    else:
        pres_local = pres

    def write_slide(lines):
        nonlocal slide_idx
        # Excel
        if slide_idx == 1 and wb.active.title == "Slide_1" and wb.active.max_row == 1:
            ws = wb.active
            ws.delete_rows(1, ws.max_row)
        else:
            ws = wb.create_sheet(title=f"Slide_{slide_idx}")
        ws.append(["Hierarchy"])
        for ln in lines:
            ws.append([ln])
        # PPT
        slide = pres_local.Slides.Add(pres_local.Slides.Count+1, 12)
        tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
        tr.Font.Size = 9
        tr.Text = "\r".join(lines)
        slide_idx += 1

    # --- Batch children ---
    for i in range(0, len(child_items), max_per_slide):
        batch = child_items[i:i+max_per_slide]
        lines = [root_line]
        overflow_map = {}

        for kind, child in batch:
            if kind == "actual":
                cid = child["Employee ID"]
                child_line = "\t" + line_for_actual(child, cid, level=5)
                lines.append(child_line)

                # Collect grandchildren
                gc_actuals = df_actual[df_actual["Functional Manager Employee ID"] == cid]
                gc_opens   = df_open[df_open["Functional Manager Employee ID"] == cid]
                gc_items = [("actual", rr) for _, rr in gc_actuals.iterrows()]
                gc_items += [("open", rr) for _, rr in gc_opens.iterrows()]

                for kind2, gc in gc_items[:max_per_slide]:
                    if kind2 == "actual":
                        lines.append("\t\t" + line_for_actual(gc, gc["Employee ID"], level=6))
                    else:
                        op_line = line_for_open(gc, level=2)
                        if op_line: lines.append(op_line)

                if len(gc_items) > max_per_slide:
                    overflow_map[child_line] = gc_items[max_per_slide:]
            else:
                op_line = line_for_open(child, level=1)
                if op_line: lines.append(op_line)

        write_slide(lines)

        # Overflow slides
        if overflow_map:
            max_overflow_len = max(len(v) for v in overflow_map.values())
            for j in range(0, max_overflow_len, max_per_slide):
                lines2 = [root_line]
                for kind, child in batch:
                    if kind == "actual":
                        cid2 = child["Employee ID"]
                        child_line2 = "\t" + line_for_actual(child, cid2, level=5)
                        lines2.append(child_line2)
                        if child_line2 in overflow_map:
                            chunk = overflow_map[child_line2][j:j+max_per_slide]
                            for kind2, gc in chunk:
                                if kind2 == "actual":
                                    lines2.append("\t\t" + line_for_actual(gc, gc["Employee ID"], level=6))
                                else:
                                    op_line = line_for_open(gc, level=2)
                                    if op_line: lines2.append(op_line)
                    else:
                        op_line = line_for_open(child, level=1)
                        if op_line: lines2.append(op_line)
                write_slide(lines2)

    # Save Excel always
    wb.save(excel_path)

    # Save PPT only if local pres was created
    if pres is None and ppt_path:
        pres_local.SaveAs(ppt_path)
        pres_local.Close()

    print(f"Excel saved: {excel_path}")
    if pres is None and ppt_path:
        print(f"PPT saved: {ppt_path}")
..................
def initialize_counts(df_final, bfg_filter=None):
    """
    Capture initial counts of GCB3, GCB4, GCB5 employees
    when user selects a BFG level (or overall if no filter).

    Parameters
    ----------
    df_final : pandas.DataFrame
        Employee dataset with columns including:
        - Employee ID
        - GCB
        - BFG (optional, if filtering by business function group)
    bfg_filter : str or None
        If provided, restrict counts to employees under this BFG level.
        If None, counts are taken across the entire dataset.

    Returns
    -------
    dict
        Dictionary with baseline counts:
        {
            "GCB3": <count>,
            "GCB4": <count>,
            "GCB5": <count>
        }
    """
    df_target = df_final.copy()

    # Apply BFG filter if given
    if bfg_filter is not None and "BFG" in df_target.columns:
        df_target = df_target[df_target["BFG"] == bfg_filter]

    counts = {
        "GCB3": len(df_target[df_target["GCB"] == "GCB3"]),
        "GCB4": len(df_target[df_target["GCB"] == "GCB4"]),
        "GCB5": len(df_target[df_target["GCB"] == "GCB5"]),
    }

    return counts



Sub CreateSmartArtFromSlideText()
    Dim pres As Presentation
    Dim sld As Slide
    Dim shp As Shape
    Dim txt As String
    Dim lines() As String
    Dim sa As Shape
    Dim node As SmartArtNode
    
    Set pres = Application.ActivePresentation
    
    For Each sld In pres.Slides
        txt = ""
        ' Collect text from all textboxes
        For Each shp In sld.Shapes
            If shp.HasTextFrame Then
                If shp.TextFrame.HasText Then
                    txt = txt & shp.TextFrame.TextRange.Text & vbCrLf
                End If
            End If
        Next shp
        
        If Len(txt) > 0 Then
            ' Split text into lines
            lines = Split(txt, vbCrLf)
            
            ' Add SmartArt (Vertical Bullet List is safe)
            Set sa = sld.Shapes.AddSmartArt(Application.SmartArtLayouts(2), 50, 50, 600, 400)
            
            ' Clear default nodes
            Do While sa.SmartArt.AllNodes.Count > 0
                sa.SmartArt.AllNodes(1).Delete
            Loop
            
            ' Add each line as a node
            For i = LBound(lines) To UBound(lines)
                Set node = sa.SmartArt.AllNodes.Add
                node.TextFrame2.TextRange.Text = lines(i)
            Next i
        End If
    Next sld
    
    MsgBox "SmartArt created for all slides."
End Sub



....
Sub ConvertSlidesToSmartArt()
    Dim pres As Presentation
    Dim sld As Slide
    Dim shp As Shape
    Dim txt As String
    Dim newSmartArt As Shape
    Dim layout As SmartArtLayout
    
    ' Choose SmartArt layout (Hierarchy is good for org charts)
    Set layout = Application.SmartArtLayouts("BasicHierarchy")
    
    ' Work on the active presentation
    Set pres = Application.ActivePresentation
    
    For Each sld In pres.Slides
        txt = ""
        ' Collect text from all textboxes on the slide
        For Each shp In sld.Shapes
            If shp.HasTextFrame Then
                If shp.TextFrame.HasText Then
                    txt = txt & shp.TextFrame.TextRange.Text & vbCrLf
                End If
            End If
        Next shp
        
        If Len(txt) > 0 Then
            ' Add SmartArt and put text in
            Set newSmartArt = sld.Shapes.AddSmartArt(layout, 50, 50, 600, 400)
            newSmartArt.TextFrame2.TextRange.Text = txt
        End If
    Next sld
    
    MsgBox "Conversion complete."
End Sub




)
    If fDialog.Show <> -1 Then Exit Sub
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set folder = fso.GetFolder(fDialog.SelectedItems(1))
    
    ' Choose SmartArt layout (e.g. BasicHierarchy)
    Set layout = Application.SmartArtLayouts("BasicHierarchy")
    
    ' Loop through all PPTX files in folder
    For Each file In folder.Files
        If LCase(fso.GetExtensionName(file.Name)) = "pptx" Then
            Set pptApp = Application
            Set pres = pptApp.Presentations.Open(file.Path, WithWindow:=msoFalse)
            
            ' Loop through slides
            For Each sld In pres.Slides
                For Each shp In sld.Shapes
                    If shp.HasTextFrame Then
                        If shp.TextFrame.HasText Then
                            ' Add SmartArt shape
                            Set newSmartArt = sld.Shapes.AddSmartArt(layout, shp.Left, shp.Top, shp.Width, shp.Height)
                            ' Copy text into SmartArt
                            newSmartArt.TextFrame2.TextRange.Text = shp.TextFrame.TextRange.Text
                            ' Optionally delete original textbox
                            shp.Delete
                        End If
                    End If
                Next shp
            Next sld
            
            pres.Save
            pres.Close
        End If
    Next file
    
    MsgBox "SmartArt created for all PPTX files in folder."
End Sub

,........


Sub BatchConvertSlidesToSmartArt()
    Dim fDialog As FileDialog
    Dim pres As Presentation
    Dim sld As Slide
    Dim shp As Shape
    Dim pptApp As PowerPoint.Application
    Dim fso As Object, folder As Object, file As Object
    
    ' Ask user to select folder
    Set fDialog = Application.FileDialog(msoFileDialogFolderPicker)
    If fDialog.Show <> -1 Then Exit Sub
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set folder = fso.GetFolder(fDialog.SelectedItems(1))
    
    ' Loop through all PPTX files in folder
    For Each file In folder.Files
        If LCase(fso.GetExtensionName(file.Name)) = "pptx" Then
            Set pptApp = Application
            Set pres = pptApp.Presentations.Open(file.Path, WithWindow:=msoFalse)
            
            ' Loop through slides
            For Each sld In pres.Slides
                ' Loop through shapes
                For Each shp In sld.Shapes
                    If shp.HasTextFrame Then
                        If shp.TextFrame.HasText Then
                            ' Convert to SmartArt (basic vertical list layout)
                            shp.ConvertToSmartArt (pptApp.SmartArtLayouts("BasicProcess"))
                        End If
                    End If
                Next shp
            Next sld
            
            ' Save and close
            pres.Save
            pres.Close
        End If
    Next file
    
    MsgBox "Conversion complete for all PPTX files in folder."
End Sub






if __name__ == "__main__":
    # Identify MDs
    mds = df_final[df_final["GCB"] == "MD"]["Employee ID"].dropna().unique().tolist()

    # Identify GCB3s
    gcb3s = df_final[df_final["GCB"] == "GCB3"]["Employee ID"].dropna().unique().tolist()

    # Find standalone GCB3s (not reporting to any MD)
    md_ids_set = set(mds)
    standalone_gcb3s = []
    for gcb3_id in gcb3s:
        mgr_id = df_final.loc[df_final["Employee ID"] == gcb3_id, "Functional Manager Employee ID"].values
        if len(mgr_id) == 0 or mgr_id[0] not in md_ids_set:
            standalone_gcb3s.append(gcb3_id)

    # Combine MDs + standalone GCB3s as roots
    roots = mds + standalone_gcb3s

    if not roots:
        print("No MDs or standalone GCB3s found in df_final. Nothing to generate.")
    else:
        ppt_app = win32com.client.Dispatch("PowerPoint.Application")
        ppt_app.Visible = True

        covered_ids = set()
        for root_id in roots:
            role = df_final.loc[df_final["Employee ID"] == root_id, "GCB"].values[0]
            print(f"Generating for {role} {root_id}...")

            df_open_bfg = df_open_enriched[
                df_open_enriched["Functional Manager Employee ID"].isin(df_final["Employee ID"])
            ]

            # Generate PPT chart
            draw_orgchart(root_id, df_final, df_open_bfg,
                          direct_counts_actual, open_pos_counts, ppt_app)

            # Generate indented Excel + PPT
            export_indented_text_full(
                root_id, df_final, df_open_bfg,
                direct_counts_actual, open_pos_counts,
                excel_path=os.path.join(output_dir, f"Indented_{role}_{root_id}.xlsx"),
                ppt_path=os.path.join(output_dir, f"Indented_{role}_{root_id}.pptx"),
                ppt_app=ppt_app
            )

            covered_ids.add(root_id)
            covered_ids.update(
                df_final[df_final["Functional Manager Employee ID"] == root_id]["Employee ID"].dropna().tolist()
            )

        print(f"Workflow complete. Files saved under: {output_dir}")
        check_coverage(df_final, covered_ids)-----

def export_indented_text_full(level4_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              excel_path=None,
                              ppt_path=None,
                              ppt_app=None,
                              max_per_slide=7):
    """
    Export indented hierarchy lines with batching:
      - Max 7 L5 per slide under L4
      - Max 7 L6 per slide under each L5
    Each slide is written to Excel (sheet) and PPT (slide).
    Overflow L6s for multiple L5s in the same batch are combined.
    """

    import os
    import pandas as pd
    import win32com.client
    from openpyxl import Workbook

    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() == "unspecified" else s

    def line_for_actual(row, mgr_id=None, level=0):
        name = clean(row.get("Employee Name", ""))
        title = clean(row.get("Position Title", ""))
        gcb   = clean(row.get("GCB", ""))
        country = clean(row.get("Country R3", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = " | ".join([p for p in [gcb, country] if p])
        line = f"{header}\n{footer}" if footer else header
        if level == 6 and mgr_id:
            if open_pos_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Open Positions: {open_pos_counts[mgr_id]}"
            if direct_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Direct Reports: {direct_counts[mgr_id]}"
        return line

    def line_for_open(op_row, level=0):
        title = clean(op_row.get("Position Title", ""))
        if not title: return None
        pid = op_row.get("PID")
        gcb, country = "", ""
        match = df_actual[df_actual["PID"] == pid]
        if not match.empty:
            gcb = clean(match.iloc[0].get("GCB", ""))
            country = clean(match.iloc[0].get("Country R3", ""))
        header = f"<Open Position> | {title}"
        footer = " | ".join([p for p in [gcb, country] if p])
        line = f"{header}\n{footer}" if footer else header
        return ("\t"*level) + line

    # Paths
    excel_path = excel_path or os.path.join(os.getcwd(), f"Indented_MD_{level4_id}.xlsx")
    ppt_path   = ppt_path   or os.path.join(os.getcwd(), f"Indented_MD_{level4_id}.pptx")

    # L4
    l4_df = df_actual[df_actual["Employee ID"] == level4_id]
    if l4_df.empty:
        raise ValueError(f"L4 Employee ID {level4_id} not found in df_actual.")
    mgr_row = l4_df.iloc[0]
    l4_line = line_for_actual(mgr_row, level4_id, level=4)

    # Collect L5s
    l5_actuals = df_actual[df_actual["Functional Manager Employee ID"] == level4_id]
    l5_opens   = df_open[df_open["Functional Manager Employee ID"] == level4_id]
    l5_items = []
    for _, r in l5_actuals.iterrows():
        if pd.notna(r.get("Employee ID")):
            l5_items.append(("actual", r))
    for _, r in l5_opens.iterrows():
        l5_items.append(("open", r))

    # Excel workbook
    wb = Workbook()
    ws = wb.active
    ws.title = "Slide_1"
    slide_idx = 1

    # PowerPoint
    ppt = ppt_app or win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()

    def write_slide(lines):
        nonlocal slide_idx
        # Excel
        if slide_idx == 1 and wb.active.title == "Slide_1" and wb.active.max_row == 1:
            ws = wb.active
            ws.delete_rows(1, ws.max_row)
        else:
            ws = wb.create_sheet(title=f"Slide_{slide_idx}")
        ws.append(["Hierarchy"])
        for ln in lines:
            ws.append([ln])
        # PPT
        slide = pres.Slides.Add(pres.Slides.Count+1, 12)
        tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
        tr.Font.Size = 9
        tr.Text = "\r".join(lines)
        slide_idx += 1

    # --- Batch L5s ---
    for i in range(0, len(l5_items), max_per_slide):
        l5_batch = l5_items[i:i+max_per_slide]

        # 1. Build main hierarchy slide
        lines = [l4_line]
        overflow_map = {}  # {l5_line: [overflow L6s]}

        for kind, l5 in l5_batch:
            if kind == "actual":
                l5_id = l5["Employee ID"]
                l5_line = "\t" + line_for_actual(l5, l5_id, level=5)
                lines.append(l5_line)

                # Collect L6s
                l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
                l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]
                l6_items = []
                for _, rr in l6_actuals.iterrows():
                    if pd.notna(rr.get("Employee ID")):
                        l6_items.append(("actual", rr))
                for _, rr in l6_opens.iterrows():
                    l6_items.append(("open", rr))

                # First 7 L6 inline
                for kind2, l6 in l6_items[:max_per_slide]:
                    if kind2 == "actual":
                        lines.append("\t\t" + line_for_actual(l6, l6["Employee ID"], level=6))
                    else:
                        op_line = line_for_open(l6, level=2)
                        if op_line:
                            lines.append(op_line)

                # Save overflow for later
                if len(l6_items) > max_per_slide:
                    overflow_map[l5_line] = l6_items[max_per_slide:]
            else:
                op_line = line_for_open(l5, level=1)
                if op_line:
                    lines.append(op_line)

        # Write the main hierarchy slide
        write_slide(lines)

        # 2. Write combined overflow slides for this batch
        if overflow_map:
            max_overflow_len = max(len(v) for v in overflow_map.values())
            for j in range(0, max_overflow_len, max_per_slide):
                lines2 = [l4_line]
                for kind, l5 in l5_batch:
                    if kind == "actual":
                        l5_id2 = l5["Employee ID"]
                        l5_line2 = "\t" + line_for_actual(l5, l5_id2, level=5)
                        lines2.append(l5_line2)
                        if l5_line2 in overflow_map:
                            chunk = overflow_map[l5_line2][j:j+max_per_slide]
                            for kind2, l6 in chunk:
                                if kind2 == "actual":
                                    lines2.append("\t\t" + line_for_actual(l6, l6["Employee ID"], level=6))
                                else:
                                    op_line = line_for_open(l6, level=2)
                                    if op_line:
                                        lines2.append(op_line)
                    else:
                        op_line = line_for_open(l5, level=1)
                        if op_line:
                            lines2.append(op_line)
                write_slide(lines2)

    # Save Excel and PPT
    wb.save(excel_path)
    pres.SaveAs(ppt_path)
    pres.Close()

    print(f"Excel saved: {excel_path}")
    print(f"PPT saved: {ppt_path}")

......................

MAX_PER_SLIDE = 7  # threshold for readability

def draw_l6_layer(l5_box, l5_id, df_actual, df_open, pres, l4_id=None, l5_left=None):
    """
    Draw L6 actuals + open positions under a single L5 manager,
    batching into slides of MAX_PER_SLIDE per L5.
    """
    l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
    l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]

    l6_items = []
    for _, row in l6_actuals.iterrows():
        if pd.notna(row["Employee ID"]):
            l6_items.append(("actual", row))
    for _, row in l6_opens.iterrows():
        l6_items.append(("open", row))

    for batch_start in range(0, len(l6_items), MAX_PER_SLIDE):
        batch = l6_items[batch_start:batch_start+MAX_PER_SLIDE]

        # If not first batch, create new slide and redraw parent boxes
        if batch_start > 0:
            slide = pres.Slides.Add(pres.Slides.Count+1, 12)
            if l4_id:
                l4_left = (pres.PageSetup.SlideWidth - L4_W) / 2
                l4_box = add_box(slide, l4_left, TOP_MARGIN, L4_W, L4_H,
                                 box_text_actual(l4_id, level=4))
            # redraw only this L5
            l5_box = add_box(slide, l5_left, L5_TOP, L5_W, L5_H,
                             box_text_actual(l5_id, level=5))
            if l4_id:
                connect(slide, l4_box, l5_box)
        else:
            slide = l5_box.Parent

        # Place batch items under this L5
        l6_positions = place_row(pres.PageSetup.SlideWidth, len(batch), L6_W)
        for j, (kind, row) in enumerate(batch):
            l6_left = l6_positions[j]
            l6_top  = L6_TOP_BASE
            if kind == "actual":
                l6_id = row["Employee ID"]
                l6_box = add_box(slide, l6_left, l6_top, L6_W, L6_H,
                                 box_text_actual(l6_id, level=6))
                connect(slide, l5_box, l6_box)  # connect only this L5 to its L6
            else:
                op_text = box_text_open(row)
                if op_text:
                    l6_box = add_box(slide, l6_left, l6_top, L6_W, L6_H, op_text)
                    connect(slide, l5_box, l6_box)  # connect only this L5 to its open position


def add_l4_slide(l4_id, l5_rows):
    """
    Draw L4 manager and their L5 reports,
    batching into slides of MAX_PER_SLIDE per L4.
    """
    sw = pres.PageSetup.SlideWidth

    for batch_start in range(0, len(l5_rows), MAX_PER_SLIDE):
        batch = l5_rows[batch_start:batch_start+MAX_PER_SLIDE]

        # New slide for each batch
        slide = pres.Slides.Add(pres.Slides.Count + 1, 12)

        # L4 box
        l4_left = (sw - L4_W) / 2
        l4_box = add_box(slide, l4_left, TOP_MARGIN, L4_W, L4_H,
                         box_text_actual(l4_id, level=4))

        # Place L5 boxes for this batch
        l5_positions = place_row(sw, len(batch), L5_W)
        for i, l5_row in enumerate(batch):
            l5_id = l5_row["Employee ID"]
            if pd.isna(l5_id):
                continue
            left = l5_positions[i]
            l5_box = add_box(slide, left, L5_TOP, L5_W, L5_H,
                             box_text_actual(l5_id, level=5))
            connect(slide, l4_box, l5_box)  # connect only this L5 to its L4

            # Draw L6 subtree with batching
            draw_l6_layer(l5_box, l5_id, df_actual, df_open, pres,
                          l4_id=l4_id, l5_left=left)...........................................

import pandas as pd
import os

def validate_orgchart(df_final, selected_bfg, output_path=os.path.join(output_dir,"BFG_Validation.xlsx")):
    # Filter slice
    df_bfg = df_final[df_final["Business Framework Group"] == selected_bfg].copy()
    df_bfg["GCB"] = df_bfg["GCB"].astype(str).str.strip().replace("nan","")

    # Determine starting nodes
    if "MD" in df_bfg["GCB"].unique():
        start_nodes = df_bfg[df_bfg["GCB"]=="MD"]["Employee ID"].dropna().tolist()
    else:
        start_nodes = df_bfg[df_bfg["GCB"]=="3"]["Employee ID"].dropna().tolist()

    covered_ids = set()

    # Recursive traversal
    def traverse(manager_id):
        covered_ids.add(manager_id)
        direct_reports = df_bfg[df_bfg["Functional Manager Employee ID"] == manager_id]["Employee ID"].dropna().tolist()
        covered_ids.update(direct_reports)  # mark them covered
        for dr in direct_reports:
            traverse(dr)

    for node in start_nodes:
        traverse(node)

    # Compare coverage
    all_ids = set(df_bfg[df_bfg["GCB"].isin(["MD","3","4","5"])]["Employee ID"].dropna())
    uncovered_ids = all_ids - covered_ids

    # Build summary tables
    df_raw = df_bfg[["Employee ID","Employee Name","GCB","Functional Manager Employee ID","Functional Manager Employee Name"]]
    df_covered = df_raw[df_raw["Employee ID"].isin(covered_ids)]
    df_uncovered = df_raw[df_raw["Employee ID"].isin(uncovered_ids)]

    counts = []
    for role in ["MD","3","4","5"]:
        total = len(df_raw[df_raw["GCB"]==role])
        covered = len(df_covered[df_covered["GCB"]==role])
        uncovered = len(df_uncovered[df_uncovered["GCB"]==role])
        counts.append({"Role":role,"Total":total,"Covered":covered,"Uncovered":uncovered})
    df_counts = pd.DataFrame(counts)

    # Write to one Excel file with multiple tabs
    with pd.ExcelWriter(output_path, engine="openpyxl") as writer:
        df_raw.to_excel(writer, sheet_name="Org_Data_Raw", index=False)
        df_covered.to_excel(writer, sheet_name="OrgChart_Covered", index=False)
        df_uncovered.to_excel(writer, sheet_name="Uncovered", index=False)
        df_counts.to_excel(writer, sheet_name="Counts", index=False)

    print(f"Validation report written to {output_path}")
    return df_counts, df_uncovered



==================================

def export_indented_text_full(level4_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              excel_path=None,
                              ppt_path=None,
                              ppt_app=None):
    """
    Export indented hierarchy lines with employees + open positions.
    Also produces role summary and uncovered employee list.
    """

    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() == "unspecified" else s

    def line_for_actual(row, mgr_id=None, level=0):
        name = clean(row.get("Employee Name", ""))
        title = clean(row.get("Position Title", ""))
        gcb   = clean(row.get("GCB", ""))
        country = clean(row.get("Country R3", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = " | ".join([p for p in [gcb, country] if p])
        line = f"{header}\n{footer}" if footer else header

        # At L6, append counts instead of expanding further
        if level == 6 and mgr_id:
            if open_pos_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Open Positions: {open_pos_counts[mgr_id]}"
            if direct_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Direct Reports: {direct_counts[mgr_id]}"
        return line

    def line_for_open(op_row):
        title = clean(op_row.get("Position Title", ""))
        if not title: return None
        pid = op_row.get("PID")
        gcb, country = "", ""
        match = df_actual[df_actual["PID"] == pid]
        if not match.empty:
            gcb = clean(match.iloc[0].get("GCB", ""))
            country = clean(match.iloc[0].get("Country R3", ""))
        header = f"<Open Position> | {title}"
        footer = " | ".join([p for p in [gcb, country] if p])
        return f"{header}\n{footer}" if footer else header

    lines = []
    covered_ids = set()

    # --- L4 manager ---
    mgr_row = df_actual[df_actual["Employee ID"] == level4_id].iloc[0]
    lines.append(line_for_actual(mgr_row, level4_id, level=4))
    covered_ids.add(level4_id)

    # --- L5 reports ---
    l5_actuals = df_actual[df_actual["Functional Manager Employee ID"] == level4_id]
    l5_opens   = df_open[df_open["Functional Manager Employee ID"] == level4_id]

    for _, l5 in l5_actuals.iterrows():
        l5_id = l5.get("Employee ID")
        if pd.isna(l5_id): continue
        lines.append(f"\t{line_for_actual(l5, l5_id, level=5)}")
        covered_ids.add(l5_id)

        # --- L6 reports ---
        l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
        l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]

        for _, l6 in l6_actuals.iterrows():
            l6_id = l6.get("Employee ID")
            if pd.isna(l6_id): continue
            lines.append(f"\t\t{line_for_actual(l6, l6_id, level=6)}")
            covered_ids.add(l6_id)

            # Add all direct reports of this L6 (covered via counts)
            dr_ids = df_actual[df_actual["Functional Manager Employee ID"] == l6_id]["Employee ID"].dropna().tolist()
            covered_ids.update(dr_ids)

        for _, op in l6_opens.iterrows():
            op_line = line_for_open(op)
            if op_line:
                lines.append(f"\t\t{op_line}")
                # Mark open position PID as covered
                if pd.notna(op.get("PID")):
                    covered_ids.add(op["PID"])

    # --- Open positions directly under L4 ---
    for _, op in l5_opens.iterrows():
        op_line = line_for_open(op)
        if op_line:
            lines.append(f"\t{op_line}")
            if pd.notna(op.get("PID")):
                covered_ids.add(op["PID"])

    # --- Export hierarchy ---
    excel_path = excel_path or os.path.join(output_dir, f"Indented_MD_{level4_id}.xlsx")
    ppt_path   = ppt_path   or os.path.join(output_dir, f"Indented_MD_{level4_id}.pptx")

    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to Excel: {excel_path}")

    ppt = ppt_app or win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()
    slide = pres.Slides.Add(1, 12)
    textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
    tr = textbox.TextFrame.TextRange
    tr.Text = "\r".join(lines)
    tr.Font.Size = 8
    pres.SaveAs(ppt_path)
    pres.Close()
    print(f"Indented hierarchy exported to PPT: {ppt_path}")

    # --- Coverage summary ---
    all_ids = set(df_actual["Employee ID"].dropna().unique())
    uncovered_ids = all_ids - covered_ids

    role_summary = []
    for role in ["MD","GCB3","GCB4","GCB5"]:
        total = len(df_actual[df_actual["GCB"]==role])
        uncovered = len(df_actual[(df_actual["GCB"]==role) & (df_actual["Employee ID"].isin(uncovered_ids))])
        role_summary.append({"Role":role,"Total":total,"Uncovered":uncovered})

    df_summary = pd.DataFrame(role_summary)
    summary_path = os.path.join(output_dir, f"Role_Summary_MD_{level4_id}.xlsx")
    df_summary.to_excel(summary_path,index=False)
    print(f"Role summary exported to {summary_path}")

    if uncovered_ids:
        df_uncovered = df_actual[df_actual["Employee ID"].isin(uncovered_ids)]
        uncovered_path = os.path.join(output_dir, f"Uncovered_Employees_MD_{level4_id}.xlsx")
        df_uncovered.to_excel(uncovered_path,index=False)
        print(f"Uncovered employees exported to {uncovered_path}")
    else:
        print("All employees covered for this MD.")

    return lines, df_summary, uncovered_ids


..................

# loop for bfg level code:
import os
import pandas as pd
import win32com.client
import tkinter as tk  # only used if you later re-add dialogs

# -----------------------------
# Output folder (absolute path under current dir)
# -----------------------------
output_dir = os.path.join(os.getcwd(), "Output")
os.makedirs(output_dir, exist_ok=True)

# -----------------------------
# Helpers
# -----------------------------
def safe_str(x):
    return "" if pd.isna(x) else str(x).strip()

def is_missing(val):
    if pd.isna(val):
        return True
    s = str(val).strip()
    return s == "" or s.lower() == "unspecified"

def clean_text(series):
    return series.astype(str).str.strip().replace("Unspecified", "")

# -----------------------------
# Step 1: Use preloaded org_data copy (df1)
# -----------------------------
df = df1.copy()

# Clean text
for col in ["Employee Name", "Functional Manager Employee Name", "Country R3", "GCB", "Business Framework Group", "Position Title"]:
    if col in df.columns:
        df[col] = clean_text(df[col])

# Coerce IDs
df["Employee ID"] = pd.to_numeric(df["Employee ID"], errors="coerce").astype("Int64")
df["Functional Manager Employee ID"] = pd.to_numeric(df["Functional Manager Employee ID"], errors="coerce").astype("Int64")
if "PID" in df.columns:
    df["PID"] = pd.to_numeric(df["PID"], errors="coerce").astype("Int64")
else:
    df["PID"] = pd.NA

# -----------------------------
# Step 2: Merge Position Title from gha (lookup1)
# -----------------------------
lookup = lookup1.copy()
lookup["Employee ID"] = pd.to_numeric(lookup["Employee ID"], errors="coerce").astype("Int64")
lookup["Position Title"] = clean_text(lookup["Position Title"])

# Rename to avoid clash
lookup = lookup.rename(columns={"Position Title": "Position_Title_gha"})

# Merge
df = df.merge(lookup, on="Employee ID", how="left")
df["Position Title"] = df["Position Title"].fillna("").astype(str).str.strip()
df["Position Title"] = df["Position Title"].where(df["Position Title"] != "", df["Position_Title_gha"])
df.drop(columns=["Position_Title_gha"], inplace=True)

# -----------------------------
# Step 3: Append open positions
# -----------------------------
def step3_append_open_positions(df, df_base, open_pos_df):
    """
    Fetches open positions, applies org_data constraints, coalesces manager info,
    and updates df_final in place. Returns df_final and df_open_enriched.

    df_base: base org_data-like DF with PID, Stack, FTE, and manager columns
    open_pos_df: open positions DF (may have different manager column names)
    """

    # Clean and coerce base
    if "PID" not in df_base.columns:
        raise ValueError("df_base must contain PID column for open position matching.")

    df_base = df_base.copy()
    df_base["PID"] = pd.to_numeric(df_base["PID"], errors="coerce").astype("Int64")
    if "FTE" in df_base.columns:
        df_base["FTE"] = pd.to_numeric(df_base["FTE"], errors="coerce")
    else:
        df_base["FTE"] = 1.0  # fallback so filter works

    df_base["Stack"] = df_base["Stack"].astype(str).str.strip() if "Stack" in df_base.columns else "PLAN"

    # Candidate filter: not ACTUALS, FTE > 0, PID present
    mask_candidates = (
        (df_base["Stack"] != "ACTUALS") &
        (df_base["FTE"] > 0) &
        (df_base["PID"].notna())
    )
    df_open_candidates = (
        df_base.loc[mask_candidates, ["PID", "Functional Manager Employee ID", "Functional Manager Employee Name"]]
        .drop_duplicates(subset=["PID"])
        .copy()
    )
    # Ensure expected manager columns exist for candidates
    if "Functional Manager Employee ID" not in df_open_candidates.columns:
        df_open_candidates["Functional Manager Employee ID"] = pd.NA
    if "Functional Manager Employee Name" not in df_open_candidates.columns:
        df_open_candidates["Functional Manager Employee Name"] = ""

    # --- Normalize open positions columns (handle naming differences) ---
    op = open_pos_df.copy()

    # Standardize key columns
    # PID in open positions is commonly "Position Number"
    if "Position Number" in op.columns:
        op["Position Number"] = pd.to_numeric(op["Position Number"], errors="coerce").astype("Int64")
    elif "PID" in op.columns:
        op["Position Number"] = pd.to_numeric(op["PID"], errors="coerce").astype("Int64")
    else:
        raise ValueError("open_pos_df requires 'Position Number' or 'PID' to match against org PID.")

    # Position Title column
    title_col = "Position Title" if "Position Title" in op.columns else None
    if title_col is None:
        # fallback to any column that looks like title
        maybe_title = [c for c in op.columns if "title" in c.lower()]
        if not maybe_title:
            raise ValueError("open_pos_df must have a position title column.")
        title_col = maybe_title[0]
    op[title_col] = clean_text(op[title_col])

    # Manager ID and Manager Name columns in open positions may differ
    # Try common variants in order:
    manager_id_cols = [
        "Functional Manager Position Level Employee ID",
        "Manager Employee ID",
        "Functional Manager Employee ID",
        "Manager_ID",
    ]
    manager_name_cols = [
        "Functional Manager Position Level Employee Name",
        "Manager Employee Name",
        "Functional Manager Employee Name",
        "Manager_Name",
    ]

    mgr_id_col = next((c for c in manager_id_cols if c in op.columns), None)
    mgr_name_col = next((c for c in manager_name_cols if c in op.columns), None)

    # Coerce manager ID if present
    if mgr_id_col:
        op[mgr_id_col] = pd.to_numeric(op[mgr_id_col], errors="coerce").astype("Int64")
    else:
        op["__mgr_id_missing__"] = pd.NA
        mgr_id_col = "__mgr_id_missing__"

    # Clean manager name if present
    if mgr_name_col:
        op[mgr_name_col] = clean_text(op[mgr_name_col])
    else:
        op["__mgr_name_missing__"] = ""
        mgr_name_col = "__mgr_name_missing__"

    # --- Merge candidates with open positions ---
    df_open_enriched = df_open_candidates.merge(
        op,
        left_on="PID",
        right_on="Position Number",
        how="inner",
        suffixes=("_org", "_open")
    )

    # --- Coalesce manager fields ---
    # Prefer open positions manager fields if available; fall back to org candidates
    df_open_enriched["Manager_ID_Final"] = df_open_enriched[mgr_id_col].fillna(
        df_open_enriched["Functional Manager Employee ID"]
    )
    df_open_enriched["Manager_Name_Final"] = df_open_enriched[mgr_name_col].replace("", pd.NA).fillna(
        df_open_enriched["Functional Manager Employee Name"]
    )

    # --- Prepare placeholder rows ---
    df_open_enriched["Employee ID"] = pd.NA
    df_open_enriched["Employee Name"] = ""
    df_open_enriched["Position Title"] = df_open_enriched[title_col].fillna("")

    # --- Final schema for open positions ---
    df_open_enriched = df_open_enriched[[
        "Employee ID", "Employee Name", "PID", "Position Title",
        "Manager_ID_Final", "Manager_Name_Final"
    ]].rename(columns={
        "Manager_ID_Final": "Functional Manager Employee ID",
        "Manager_Name_Final": "Functional Manager Employee Name"
    })

    # --- Update df_final in place (manager fields from open positions) ---
    df["PID"] = pd.to_numeric(df["PID"], errors="coerce").astype("Int64")
    updated = 0
    for _, row in df_open_enriched.iterrows():
        mask = df["PID"].eq(row["PID"])
        if mask.any():
            df.loc[mask, ["Functional Manager Employee ID", "Functional Manager Employee Name"]] = [
                row["Functional Manager Employee ID"],
                row["Functional Manager Employee Name"]
            ]
            updated += int(mask.sum())

    print(f"Open positions merged: {len(df_open_enriched)}")
    print(f"Rows updated in df_final: {updated}")

    return df.copy(), df_open_enriched

df_final, df_open_enriched = step3_append_open_positions(df, df_base1.copy(), open_pos1.copy())

# -----------------------------
# Step 4: Precompute Counts
# -----------------------------
direct_counts_actual = (
    df_final[df_final["Employee ID"].notna()]
    .groupby("Functional Manager Employee ID")["Employee ID"]
    .nunique()
    .to_dict()
)

open_pos_counts = (
    df_open_enriched.groupby("Functional Manager Employee ID")["PID"]
    .size()
    .to_dict()
)

direct_counts_total = {
    mgr: direct_counts_actual.get(mgr, 0) + open_pos_counts.get(mgr, 0)
    for mgr in set(direct_counts_actual) | set(open_pos_counts)
}

print("Open pos:", open_pos_counts)
print("Direct counts:", direct_counts_actual)

# -----------------------------
# Step 6A: PowerPoint generation (actuals + open positions, counts at L6)
# -----------------------------
def draw_orgchart(level4_id, df_actual, df_open, direct_counts, open_pos_counts,
                  ppt_app=None):
    ppt = ppt_app or win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()

    # Box sizes and layout
    L4_W, L4_H = 100, 50
    L5_W, L5_H = 100, 50
    L6_W, L6_H = 100, 50
    TOP_MARGIN = 15
    L5_TOP = 100
    L6_TOP_BASE = 160
    COL_GAP = 20
    ROW_GAP = 15

    # --- Helpers ---
    def add_box(slide, left, top, w, h, text):
        shape = slide.Shapes.AddShape(1, left, top, w, h)
        tr = shape.TextFrame.TextRange
        tr.Text = text
        tr.ParagraphFormat.Alignment = 1
        tr.Font.Size = 8
        shape.TextFrame.AutoSize = 0
        return shape

    def connect(slide, parent, child):
        conn = slide.Shapes.AddConnector(1, 0, 0, 0, 0)
        conn.ConnectorFormat.BeginConnect(parent, 3)
        conn.ConnectorFormat.EndConnect(child, 1)

    def place_row(sw, n, box_w):
        total_w = n * box_w + (n - 1) * COL_GAP
        start_left = max(20, (sw - total_w) / 2)
        return [start_left + i * (box_w + COL_GAP) for i in range(n)]

    def clean(x):
        if pd.isna(x):
            return ""
        s = str(x).strip()
        return "" if s.lower() == "unspecified" else s

    def box_text_actual(emp_id, level=None):
        row = df_actual[df_actual["Employee ID"] == emp_id].iloc[0]
        name = clean(row["Employee Name"])
        title = clean(row["Position Title"])
        gcb = clean(row["GCB"])
        country = clean(row["Country R3"])
        header = "\n".join([p for p in [name, title] if p])
        footer = " | ".join([p for p in [gcb, country] if p])
        text = f"{header}\n{footer}" if footer else header
        # At L6, append counts
        if level == 6:
            if open_pos_counts.get(emp_id, 0) > 0:
                text += f"\n→ Open Positions: {open_pos_counts[emp_id]}"
            if direct_counts.get(emp_id, 0) > 0:
                text += f"\n→ Direct Reports: {direct_counts[emp_id]}"
        return text

    def box_text_open(op_row):
        title = clean(op_row.get("Position Title", ""))
        if not title:
            return None
        pid = op_row.get("PID")
        gcb, country = "", ""
        match = df_actual[df_actual["PID"] == pid]
        if not match.empty:
            gcb = clean(match.iloc[0].get("GCB", ""))
            country = clean(match.iloc[0].get("Country R3", ""))
        header = f"<Open Position>\n{title}"
        footer = " | ".join([p for p in [gcb, country] if p])
        return f"{header}\n{footer}" if footer else header

    def get_direct_reports(manager_id):
        actuals = df_actual[df_actual["Functional Manager Employee ID"] == manager_id]
        opens = df_open[df_open["Functional Manager Employee ID"] == manager_id]
        return actuals, opens

    def add_l4_slide(l4_id, l5_rows):
        slide = pres.Slides.Add(pres.Slides.Count + 1, 12)
        sw = pres.PageSetup.SlideWidth

        # L4 box
        l4_left = (sw - L4_W) / 2
        l4_box = add_box(slide, l4_left, TOP_MARGIN, L4_W, L4_H, box_text_actual(l4_id, level=4))

        # Place L5 boxes
        l5_positions = place_row(sw, len(l5_rows), L5_W)
        for i, l5_row in enumerate(l5_rows):
            l5_id = l5_row["Employee ID"]
            if pd.isna(l5_id):
                continue
            left = l5_positions[i]
            l5_box = add_box(slide, left, L5_TOP, L5_W, L5_H, box_text_actual(l5_id, level=5))
            connect(slide, l4_box, l5_box)

            # Get L6 direct reports (actual + open)
            actuals, opens = get_direct_reports(l5_id)
            l6_rows = [row for _, row in actuals.iterrows() if pd.notna(row["Employee ID"])]
            open_rows = [row for _, row in opens.iterrows()]

            # Draw actual L6 employees (with counts inside their box, no expansion)
            for j, l6_row in enumerate(l6_rows):
                l6_id = l6_row["Employee ID"]
                l6_left = left + (L5_W - L6_W) / 2
                l6_top = L6_TOP_BASE + j * (L6_H + ROW_GAP)
                l6_box = add_box(slide, l6_left, l6_top, L6_W, L6_H, box_text_actual(l6_id, level=6))
                connect(slide, l5_box, l6_box)

            # Draw open positions under L5
            for k, op_row in enumerate(open_rows):
                op_text = box_text_open(op_row)
                if not op_text:
                    continue
                l6_left = left + (L5_W - L6_W) / 2
                l6_top = L6_TOP_BASE + (len(l6_rows) + k) * (L6_H + ROW_GAP)
                l6_box = add_box(slide, l6_left, l6_top, L6_W, L6_H, op_text)
                connect(slide, l5_box, l6_box)

    # --- Build chart starting from L4 ---
    l5_reports, _ = get_direct_reports(level4_id)
    l5_rows = [row for _, row in l5_reports.iterrows() if pd.notna(row["Employee ID"])]
    add_l4_slide(level4_id, l5_rows)

    pres.SaveAs(os.path.join(output_dir, f"OrgChart_MD_{level4_id}.pptx"))
    pres.Close()
    print(f"Org chart saved to {os.path.join(output_dir, f'OrgChart_MD_{level4_id}.pptx')}")

# -----------------------------
# Step 6B: Export indented hierarchy to Excel and PPT
# -----------------------------
def export_indented_text_full(level4_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              excel_path=None,
                              ppt_path=None,
                              ppt_app=None):
    """
    Export indented hierarchy lines with employees + open positions.
    - L4/L5: list all direct reports explicitly.
    - L6: show counts only (Direct Reports, Open Positions).
    - Skip open positions if Position Title missing/blank/Unspecified.
    """

    def clean(x):
        if pd.isna(x):
            return ""
        s = str(x).strip()
        return "" if s.lower() == "unspecified" else s

    def line_for_actual(row, mgr_id=None, level=0):
        name = clean(row.get("Employee Name", ""))
        title = clean(row.get("Position Title", ""))
        gcb = clean(row.get("GCB", ""))
        country = clean(row.get("Country R3", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = " | ".join([p for p in [gcb, country] if p])
        line = f"{header}\n{footer}" if footer else header

        # At L6, append counts instead of expanding further
        if level == 6 and mgr_id:
            if open_pos_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Open Positions: {open_pos_counts[mgr_id]}"
            if direct_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Direct Reports: {direct_counts[mgr_id]}"
        return line

    def line_for_open(op_row):
        title = clean(op_row.get("Position Title", ""))
        if not title:
            return None
        pid = op_row.get("PID")
        gcb, country = "", ""
        match = df_actual[df_actual["PID"] == pid]
        if not match.empty:
            gcb = clean(match.iloc[0].get("GCB", ""))
            country = clean(match.iloc[0].get("Country R3", ""))
        header = f"<Open Position> | {title}"
        footer = " | ".join([p for p in [gcb, country] if p])
        return f"{header}\n{footer}" if footer else header

    lines = []

    # L4 manager
    mgr_row = df_actual[df_actual["Employee ID"] == level4_id].iloc[0]
    lines.append(line_for_actual(mgr_row, level4_id, level=4))

    # L5 reports
    l5_actuals = df_actual[df_actual["Functional Manager Employee ID"] == level4_id]
    l5_opens = df_open[df_open["Functional Manager Employee ID"] == level4_id]

    for _, l5 in l5_actuals.iterrows():
        l5_id = l5.get("Employee ID")
        if pd.isna(l5_id):
            continue
        lines.append(f"\t{line_for_actual(l5, l5_id, level=5)}")

        # L6 reports
        l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
        l6_opens = df_open[df_open["Functional Manager Employee ID"] == l5_id]

        for _, l6 in l6_actuals.iterrows():
            l6_id = l6.get("Employee ID")
            if pd.isna(l6_id):
                continue
            lines.append(f"\t\t{line_for_actual(l6, l6_id, level=6)}")

        for _, op in l6_opens.iterrows():
            op_line = line_for_open(op)
            if op_line:
                lines.append(f"\t\t{op_line}")

    # Open positions directly under L4
    for _, op in l5_opens.iterrows():
        op_line = line_for_open(op)
        if op_line:
            lines.append(f"\t{op_line}")

    # Paths
    excel_path = excel_path or os.path.join(output_dir, f"Indented_MD_{level4_id}.xlsx")
    ppt_path = ppt_path or os.path.join(output_dir, f"Indented_MD_{level4_id}.pptx")

    # Export to Excel
    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to Excel: {excel_path}")

    # Export to PPT
    ppt = ppt_app or win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()
    slide = pres.Slides.Add(1, 12)
    textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
    tr = textbox.TextFrame.TextRange
    tr.Text = "\r".join(lines)
    tr.Font.Size = 8
    pres.SaveAs(ppt_path)
    pres.Close()
    print(f"Indented hierarchy exported to PPT: {ppt_path}")

    return lines

# -----------------------------
# Main (no dropdown; uses already filtered df1/open_pos1/etc.)
# -----------------------------
if __name__ == "__main__":
    # You already filtered by BFG and built df1/df_base1/open_pos1/lookup1 upstream.
    # Here we just iterate over MDs present in df_final and generate outputs.

    # Identify MDs
    mds = df_final[df_final["GCB"] == "MD"]["Employee ID"].dropna().unique().tolist()
    if not mds:
        print("No MDs found in df_final. Nothing to generate.")
    else:
        ppt_app = win32com.client.Dispatch("PowerPoint.Application")
        ppt_app.Visible = True
        
        covered_ids = set()

        for md_id in mds:
            print(f"Generating for MD {md_id}...")
            # Limit open positions to those whose manager is within current df_final slice
            df_open_bfg = df_open_enriched[df_open_enriched["Functional Manager Employee ID"].isin(df_final["Employee ID"])]

            # Generate PPT chart
            draw_orgchart(md_id, df_final, df_open_bfg, direct_counts_actual, open_pos_counts, ppt_app)

            # Generate indented Excel + PPT
            export_indented_text_full(md_id, df_final, df_open_bfg,
                                      direct_counts_actual, open_pos_counts,
                                      excel_path=os.path.join(output_dir, f"Indented_MD_{md_id}.xlsx"),
                                      ppt_path=os.path.join(output_dir, f"Indented_MD_{md_id}.pptx"),
                                      ppt_app=ppt_app)
            covered_ids.add(md_id)
            covered_ids.update(df_final[df_final["Functional Manager Employee ID"] == md_id]["Employee ID"].dropna().tolist())

        print(f"Workflow complete. Files saved under: {output_dir}")
        check_coverage(df_final, covered_ids)
        
def check_coverage(df_final, covered_ids, summary_excel_path=os.path.join(output_dir, "OrgChart_Summary.xlsx")):
    # All employees in the current BFG slice
    all_ids = set(df_final["Employee ID"].dropna().unique())

    # Who is not covered
    uncovered = all_ids - covered_ids

    print(f"Coverage summary: {len(covered_ids)} employees covered, {len(uncovered)} uncovered.")

    if uncovered:
        print("Uncovered Employee IDs:", uncovered)
        df_uncovered = df_final[df_final["Employee ID"].isin(uncovered)]
        df_uncovered.to_excel(summary_excel_path, index=False)
        print(f"Uncovered employees exported to {summary_excel_path}")
    else:
        print("All employees covered.")
        
        
