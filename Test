import xlwings as xw

def fix_product_control_xlwings(file_path, sheet_name, header_row):
    app = xw.App(visible=False)
    wb = app.books.open(file_path)
    ws = wb.sheets[sheet_name]

    headers = ws.range((header_row, 1)).expand('right').value

    try:
        bf_col_idx = headers.index("Business Framework") + 1
        bfg_col_idx = headers.index("Business Framework Group") + 1
    except ValueError:
        app.quit()
        raise Exception("One or both columns not found!")

    last_row = ws.cells.last_cell.row

    changed_count = 0

    for row in range(header_row + 1, last_row + 1):
        bf_val = ws.range((row, bf_col_idx)).value
        bfg_val = ws.range((row, bfg_col_idx)).value

        if isinstance(bf_val, str) and bf_val.strip().upper() == "PRODUCT CONTROL":
            if isinstance(bfg_val, str) and bfg_val.strip() != "L3 - Financial Control & Tax":
                ws.range((row, bfg_col_idx)).value = "L3 - Financial Control & Tax"
                changed_count += 1

    print(f"✅ Updated {changed_count} rows for PRODUCT CONTROL.")

    fixed_file = file_path.replace(".xlsx", "_product_control_fixed.xlsx")
    wb.save(fixed_file)
    wb.close()
    app.quit()

    print(f"✅ File saved: {fixed_file}")
    return fixed_file

# Example usage:
fix_product_control_xlwings(
    file_path="your_file.xlsx",
    sheet_name="Data",
    header_row=2  # Adjust if your header is on row 2
)


import xlwings as xw

def delete_prev_year_rows_xlwings_safe(file_path, sheet_name, header_row, target_year):
    app = xw.App(visible=False)
    wb = app.books.open(file_path)
    ws = wb.sheets[sheet_name]

    headers = ws.range((header_row, 1)).expand('right').value

    try:
        period_col_idx = headers.index("Period Month") + 1
    except ValueError:
        app.quit()
        raise Exception("'Period Month' column not found!")

    prev_yy = str(int(target_year[-2:]) - 1).zfill(2)
    print(f"Deleting rows ending with {prev_yy}")

    # Clear filter if any
    ws.api.AutoFilterMode = False

    # Apply AutoFilter
    ws.range((header_row, 1)).api.AutoFilter(
        Field=period_col_idx,
        Criteria1=f"*{prev_yy}"
    )

    xlCellTypeVisible = 12

    # Data starts from header_row + 1
    first_data_row = header_row + 1
    last_row = ws.cells.last_cell.row
    used_range = ws.range((first_data_row, 1), (last_row, ws.cells.last_cell.column))

    try:
        # Only visible rows in the data range
        visible_cells = used_range.api.SpecialCells(xlCellTypeVisible)
        visible_cells.EntireRow.Delete()
        print("✅ Matching data rows deleted.")
    except Exception:
        print("No matching rows found — nothing deleted.")

    ws.api.AutoFilterMode = False

    cleaned_file = file_path.replace(".xlsx", f"_cleaned_{target_year}.xlsx")
    wb.save(cleaned_file)
    wb.close()
    app.quit()

    print(f"✅ Cleaned file saved: {cleaned_file}")

# Example usage
delete_prev_year_rows_xlwings_safe(
    file_path="your_file.xlsx",
    sheet_name="Data",
    header_row=2,
    target_year="2025"
)



from openpyxl import load_workbook

def clean_workbook(file_path, sheet_name, start_row, target_year):
    wb = load_workbook(file_path)
    ws = wb[sheet_name]

    # Get header row
    header_row = [cell.value for cell in ws[start_row]]
    try:
        period_col_idx = header_row.index("Period Month") + 1
    except ValueError:
        raise Exception("❌ 'Period Month' column not found")

    # Loop bottom-up: safely remove rows matching last 2 digits of previous year
    yy = target_year[-2:]
    prev_yy = str(int(yy) - 1).zfill(2)
    max_row = ws.max_row

    for row in range(max_row, start_row, -1):
        val = ws.cell(row=row, column=period_col_idx).value
        if val and isinstance(val, str) and val.strip()[-2:] == prev_yy:
            ws.delete_rows(row)

    # Fix PRODUCT CONTROL tagging
    try:
        bf_idx = header_row.index("Business Framework") + 1
        bfg_idx = header_row.index("Business Framework Group") + 1
    except ValueError:
        raise Exception("❌ Required columns not found")

    for row in range(start_row + 1, ws.max_row + 1):
        if str(ws.cell(row=row, column=bf_idx).value).strip() == "PRODUCT CONTROL":
            if str(ws.cell(row=row, column=bfg_idx).value).strip() != "L3 - Financial Control & Tax":
                ws.cell(row=row, column=bfg_idx).value = "L3 - Financial Control & Tax"

    cleaned_file = file_path.replace(".xlsx", "_cleaned.xlsx")
    wb.save(cleaned_file)
    print(f"✅ Cleaned file saved: {cleaned_file}")
    return cleaned_file




>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>






from openpyxl import load_workbook
import os

# --- User Inputs ---
file_path = input("Enter the full path to the Excel file: ").strip()
sheet_name = "Data"  # Assuming your sheet is named 'Data'

# --- Load Workbook ---
wb = load_workbook(file_path)
if sheet_name not in wb.sheetnames:
    raise ValueError(f"Sheet '{sheet_name}' not found in workbook.")

ws = wb[sheet_name]

# --- Find columns ---
header_row_number = 2  # Your headers are in row 2
header_row = [cell.value for cell in ws[header_row_number]]

# Get column indexes
try:
    framework_col_index = header_row.index("Business Framework")
    group_col_index = header_row.index("Business Framework Group")
except ValueError as e:
    raise ValueError("Required columns not found in header row.") from e

# --- Process rows ---
for row in ws.iter_rows(min_row=header_row_number + 1):
    framework_cell = row[framework_col_index]
    group_cell = row[group_col_index]

    if framework_cell.value and framework_cell.value.strip() == "PRODUCT CONTROL":
        if group_cell.value.strip() != "L3 - Financial Control & Tax":
            print(
                f"Fixing row {framework_cell.row}: "
                f"was '{group_cell.value}', setting to 'L3 - Financial Control & Tax'"
            )
            group_cell.value = "L3 - Financial Control & Tax"

# --- Save updated workbook ---
new_file_path = os.path.splitext(file_path)[0] + "_framework_fixed.xlsx"
wb.save(new_file_path)

print(f"✅ File saved with corrected tags: {new_file_path}")

.................................................
import xlwings as xw

# --- Inputs ---
file_path = input("Enter full path to Excel file: ").strip()
sheet_name = "Data"
target_year = input("Enter the target year (e.g., 2025): ").strip()

yy = target_year[-2:]
prev_yy = str(int(yy) - 1).zfill(2)

# Open workbook with Excel app
app = xw.App(visible=False)
wb = app.books.open(file_path)
ws = wb.sheets[sheet_name]

# Find header row (row 2) and the Period Month column
header_row_number = 2
headers = ws.range((header_row_number, 1)).expand('right').value

try:
    period_col_index = headers.index("Period Month") + 1  # 1-based index
except ValueError:
    raise ValueError("'Period Month' column not found.")

# Clear existing filter
ws.api.AutoFilterMode = False

# ✅ Correct syntax for calling AutoFilter in Python:
ws.range((header_row_number, 1)).api.AutoFilter(
    Field=period_col_index,
    Criteria1="*" + prev_yy
)

# Find used range
used_range = ws.used_range
last_row = used_range.last_cell.row

# Delete visible rows (bottom up) except header row
for row in range(last_row, header_row_number, -1):
    if not ws.range((row, 1)).api.EntireRow.Hidden:
        ws.range((row, 1)).api.EntireRow.Delete()

# Remove filter
ws.api.AutoFilterMode = False

# Save new file
new_file_path = file_path.replace(".xlsx", f"_filtered_{yy}.xlsx")
wb.save(new_file_path)
wb.close()
app.quit()

print(f"✅ Filtered rows deleted and saved to: {new_file_path}")


/................................
from openpyxl import load_workbook
import os

# --- User Inputs ---
file_path = input("Enter the full path to the Excel file: ").strip()
sheet_name = input("Enter the sheet name: ").strip()
target_year = input("Enter the target year (e.g., 2025): ").strip()

# Derive last 2 digits of current and previous year
yy = target_year[-2:]
prev_yy = str(int(yy) - 1).zfill(2)

# --- Load Workbook and Sheet ---
wb = load_workbook(file_path)
if sheet_name not in wb.sheetnames:
    raise ValueError(f"Sheet '{sheet_name}' not found in workbook.")

ws = wb[sheet_name]

# --- Identify the "Period Month" column ---
header_row_number = 2  # Your headers are in row 2
header_row = [cell.value for cell in ws[header_row_number]]
period_col_index = None

for idx, col_name in enumerate(header_row):
    if col_name and col_name.strip() == "Period Month":
        period_col_index = idx
        break

if period_col_index is None:
    raise ValueError("'Period Month' column not found in the sheet.")

# --- Filter Rows ---
rows_to_keep = []
rows_to_keep.append(header_row)  # Keep header

for row in ws.iter_rows(min_row=header_row_number + 1, values_only=True):
    period_value = row[period_col_index]
    if not period_value or not isinstance(period_value, str):
        continue
    if period_value.strip()[-2:] == yy and period_value.strip()[-2:] != prev_yy:
        rows_to_keep.append(list(row))

# --- Clear old data (keep header) and write filtered rows ---
ws.delete_rows(header_row_number + 1, ws.max_row)  # Delete rows below header

for i, row_data in enumerate(rows_to_keep[1:], start=header_row_number + 1):
    for j, value in enumerate(row_data, start=1):
        ws.cell(row=i, column=j, value=value)

# --- Save updated workbook ---
new_file_path = os.path.splitext(file_path)[0] + f"_filtered_{yy}.xlsx"
wb.save(new_file_path)

print(f"✅ Filtered data saved to: {new_file_path}")
.......................................

import pandas as pd

def enrich_billing_entity_info(main_df: pd.DataFrame, last_month_df: pd.DataFrame, ospd_df: pd.DataFrame) -> pd.DataFrame:
    # Normalize BPCC and LE_Description
    def normalize_bpcc(series):
        return series.astype(str).str.strip().str.lstrip('0').str.upper()

    main_df['__BPCC_tmp'] = normalize_bpcc(main_df['Business Partner Cost Center'])
    last_month_df['__BPCC_tmp'] = normalize_bpcc(last_month_df['Business Partner Cost Center'])
    ospd_df['__BPCC_tmp'] = normalize_bpcc(ospd_df['CC_ID'])

    # Normalize LE_Description
    ospd_df['__LE_tmp'] = ospd_df['LE_Description'].astype(str).str.strip().str.upper()

    # Initialize columns
    if 'Comment' not in main_df.columns:
        main_df['Comment'] = ""
    main_df['Billing Entity name as per OSPD'] = ""

    # Set for faster lookup
    bpcc_last_month_set = set(last_month_df['__BPCC_tmp'])
    bpcc_ospd_set = set(ospd_df['__BPCC_tmp'])

    for idx, row in main_df.iterrows():
        bpcc = row['__BPCC_tmp']
        billing_entity = str(row['Billing Entity']).replace("_", " ").strip().upper()

        # Case 1: BPCC not found in OSPD
        if bpcc not in bpcc_ospd_set:
            main_df.at[idx, 'Comment'] = "No BPCC found in OSPD."
            continue

        # Case 2: New BPCC (not in last month file)
        if bpcc not in bpcc_last_month_set:
            matching_ospd_entries = ospd_df[ospd_df['__BPCC_tmp'] == bpcc]['__LE_tmp'].unique()

            # Join all expected LE_Descriptions from OSPD
            combined_le = " | ".join(sorted(set(matching_ospd_entries)))
            main_df.at[idx, 'Billing Entity name as per OSPD'] = combined_le

            # Compare with cleaned Billing Entity from main_df
            if billing_entity not in matching_ospd_entries:
                comment = f"New BPCC found. Billing Entity mismatch. Expected from OSPD: {combined_le}"
                main_df.at[idx, 'Comment'] = comment

    # Cleanup temporary columns
    main_df.drop(columns=['__BPCC_tmp'], inplace=True)
    return main_df
