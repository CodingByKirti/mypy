import pandas as pd
from pptx import Presentation
from pptx.util import Inches

# Step 1: Read Excel
df = pd.read_excel("org_data.xlsx")
import pandas as pd

# Read Excel
df = pd.read_excel("org_data.xlsx")

# Strip spaces from names (optional but recommended)
df["Employee Name"] = df["Employee Name"].str.strip()
df["Functional Manager Employee Name"] = df["Functional Manager Employee Name"].str.strip()

# Convert IDs to integers (handle NaN safely)
df["Employee ID"] = pd.to_numeric(df["Employee ID"], errors="coerce").astype("Int64")
df["Functional Manager Employee ID"] = pd.to_numeric(df["Functional Manager Employee ID"], errors="coerce").astype("Int64")

# Now both columns are Int64 dtype (nullable integer)
print(df.dtypes)

# Step 2: Recursive function to build hierarchy
def build_hierarchy(manager_id, level, max_level=6):
    if level > max_level:
        return None
    
    reports = df[df["Functional Manager Employee ID"] == manager_id]
    hierarchy = {}
    
    for _, row in reports.iterrows():
        emp_id = row["Employee ID"]
        emp_name = row["Employee Name"]
        
        if level == max_level:
            # Count direct reports instead of expanding
            count = df[df["Functional Manager Employee ID"] == emp_id].shape[0]
            hierarchy[emp_name] = {"count": count}
        else:
            hierarchy[emp_name] = build_hierarchy(emp_id, level+1, max_level)
    
    return hierarchy

# Step 3: Build starting hierarchy
root_hierarchy = {
    "GE": {
        "PK": {
            "Abhishek Jain": {
                "Vikram Sarma": build_hierarchy(
                    manager_id=df.loc[df["Employee Name"]=="Vikram Sarma","Employee ID"].iloc[0],
                    level=5
                )
            }
        }
    }
}

output_rows = []

def traverse(manager_id, manager_name, level):
    reports = df[df["Functional Manager Employee ID"] == manager_id]
    for _, row in reports.iterrows():
        emp_id = row["Employee ID"]
        emp_name = row["Employee Name"]

        if level == 6:
            count = df[df["Functional Manager Employee ID"] == emp_id].shape[0]
            output_rows.append([manager_name, row["Functional Manager Employee Name"], emp_name, count])
        else:
            traverse(emp_id, emp_name, level+1)

# Example: start from Vikram Sarma (Level 4)
vikram_id = df.loc[df["Employee Name"]=="Vikram Sarma","Employee ID"].iloc[0]
traverse(vikram_id, "Vikram Sarma", 5)

# Convert to DataFrame for Excel
out_df = pd.DataFrame(output_rows, columns=["Level 4 Manager","Level 5 Employee","Level 6 Employee","Count of Direct Reports"])
out_df.to_excel("OrgChart_Flat.xlsx", index=False)
# Step 4: Create PPT
prs = Presentation()
slide = prs.slides.add_slide(prs.slide_layouts[5])
txBox = slide.shapes.add_textbox(Inches(1), Inches(1), Inches(8), Inches(5))
tf = txBox.text_frame
tf.text = str(root_hierarchy)  # For POC, just dump hierarchy text
prs.save("OrgChart_POC.pptx")


import ctypes
import time

def prevent_sleep():
    # Prevent sleep and keep display on
    ES_CONTINUOUS = 0x80000000
    ES_SYSTEM_REQUIRED = 0x00000001
    ES_DISPLAY_REQUIRED = 0x00000002
    ctypes.windll.kernel32.SetThreadExecutionState(
        ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED)

while True:
    prevent_sleep()
    time.sleep(60)  # Refresh every minute

def calculate_workstyle_compliance(flattened_df, weeks_lookup, month_list, expected_prefix="Expected Workstyle Days", actual_prefix="Days at Any Office"):
    """
    Adds 'Workstyle Met? (Mm-YY)' columns to flattened_df for each month in month_list.
    Uses updated logic:
    - Met: 85% to 100%
    - Partially Met: <85% but >0
    - Exceeding: >100%
    - Defaulted: 0
    """
    weeks_dict = dict(zip(weeks_lookup["Month"], weeks_lookup["Weeks_in_Month"]))

    for month in month_list:
        expected_col = f"{expected_prefix} {month}"
        actual_col = f"{actual_prefix} {month}"
        status_col = f"Workstyle Met? {month}"

        if expected_col not in flattened_df.columns or actual_col not in flattened_df.columns:
            continue

        expected_total = flattened_df[expected_col] * weeks_dict.get(month, 0)
        actual_total = flattened_df[actual_col]

        def get_status(expected, actual):
            if expected == 0:
                return "No Expectation"
            if actual == 0:
                return "Defaulted"
            ratio = actual / expected
            if 0.85 <= ratio <= 1.00:
                return "Met"
            elif ratio < 0.85:
                return "Partially Met"
            elif ratio > 1.00:
                return "Exceeding"
            else:
                return "Unknown"

        flattened_df[status_col] = [
            get_status(e, a) for e, a in zip(expected_total, actual_total)
        ]

    return flattened_df

# after flattening monthly data


# Step 1: Get list of months from weeks_lookup
month_list = weeks_lookup["Month"].tolist()

# Step 2: Call the compliance function
flattened_df = calculate_workstyle_compliance(
    flattened_df,
    weeks_lookup,
    month_list,
    expected_prefix="Expected Workstyle Days",
    actual_prefix="Days at Any Office"
)





def calculate_workstyle_compliance(flattened_df, weeks_lookup, month_list, expected_prefix="Expected Workstyle Days", actual_prefix="Days at Any Office"):
    """
    Adds 'Workstyle Met? (Mm-YY)' columns to flattened_df for each month in month_list.
    
    Parameters:
    - flattened_df (pd.DataFrame): Pivoted monthly data with expected and actual office days
    - weeks_lookup (pd.DataFrame): DataFrame with columns ['Month', 'Weeks_in_Month']
    - month_list (list): List of month strings like ['Apr-25', 'May-25']
    - expected_prefix (str): Prefix for expected workstyle column names
    - actual_prefix (str): Prefix for actual office days column names
    
    Returns:
    - pd.DataFrame: Updated flattened_df with compliance columns added
    """
    # Create a lookup dictionary for weeks per month
    weeks_dict = dict(zip(weeks_lookup["Month"], weeks_lookup["Weeks_in_Month"]))

    for month in month_list:
        expected_col = f"{expected_prefix} {month}"
        actual_col = f"{actual_prefix} {month}"
        status_col = f"Workstyle Met? {month}"

        if expected_col not in flattened_df.columns or actual_col not in flattened_df.columns:
            continue  # Skip if required columns are missing

        # Calculate thresholds
        expected_total = flattened_df[expected_col] * weeks_dict.get(month, 0)
        actual_total = flattened_df[actual_col]

        def get_status(expected, actual):
            if expected == 0:
                return "No Expectation"
            ratio = actual / expected if expected else 0
            if actual == 0:
                return "Defaulted"
            elif 0.85 <= ratio <= 1.08:
                return "Met"
            elif ratio < 0.85:
                return "Partially Met"
            elif ratio > 1.08:
                return "Exceeding"
            else:
                return "Unknown"

        flattened_df[status_col] = [
            get_status(e, a) for e, a in zip(expected_total, actual_total)
        ]

    return flattened_df


#after flatenning
month_list = weeks_lookup["Month"].tolist()
flattened_df = calculate_workstyle_compliance(flattened_df, weeks_lookup, month_list)





def extract_weeks_lookup_table(df, month_col="Month", weeks_col="Weeks_in_Month"):
    """
    Extracts a unique Month ‚Üí Weeks_in_Month mapping from the monthly DataFrame.

    Parameters:
    - df (pd.DataFrame): Monthly-level DataFrame with 'Month' and 'Weeks_in_Month'
    - month_col (str): Name of the month column (e.g., 'Apr-25')
    - weeks_col (str): Name of the weeks count column

    Returns:
    - weeks_lookup_df (pd.DataFrame): Unique Month ‚Üí Weeks_in_Month mapping
    """
    return df[[month_col, weeks_col]].drop_duplicates().reset_index(drop=True)


weeks_lookup = extract_weeks_lookup_table(monthly)
monthly = monthly.drop(columns=["Weeks_in_Month"])





def extract_weeks_per_month(df, month_col="Month", weeks_col="Weeks_in_Month"):
    """
    Extracts a unique mapping of Month ‚Üí Weeks_in_Month from the input DataFrame.
    Removes the weeks column from the main DataFrame to avoid duplication during flattening.

    Parameters:
    - df (pd.DataFrame): Monthly-level DataFrame with 'Month' and 'Weeks_in_Month'
    - month_col (str): Name of the month column (e.g., 'Apr-25')
    - weeks_col (str): Name of the weeks count column

    Returns:
    - tuple: (cleaned_df, weeks_lookup_df)
        - cleaned_df: original df without the weeks column
        - weeks_lookup_df: unique Month ‚Üí Weeks_in_Month mapping
    """
    # Extract unique month-week mapping
    weeks_lookup = df[[month_col, weeks_col]].drop_duplicates().reset_index(drop=True)

    # Drop weeks column from main df
    df_cleaned = df.drop(columns=[weeks_col])

    return df_cleaned, weeks_lookup


monthly, weeks_lookup = extract_weeks_per_month(monthly)











orphans = []
for _, row in enriched.iterrows():
    emp_id = row[EMP_ID_COL]
    # skip MDs
    if row[GCB_COL] == "MD":
        continue
    if emp_id not in hierarchy_df[EMP_ID_COL].values and emp_id not in exceptions_df[EMP_ID_COL].values:
        row_dict = row.to_dict()
        row_dict["Issue"] = "Not connected to any MD, no missing manager found"
        orphans.append(row_dict)

orphans_df = pd.DataFrame(orphans)






for suffix in sheet_suffix_order:
    for sheet in wb.Sheets:
        if sheet.Name.endswith(suffix):
            key = sheet.Name.split("_")[0]
            pivot_table_sheet_name = f"{key}"

            if key in pivot_sheets:
                pivot_ws = pivot_sheets[key]
            else:
                pivot_ws = wb.Worksheets.Add()
                pivot_ws.Name = pivot_table_sheet_name
                pivot_sheets[key] = pivot_ws

            last_row = pivot_ws.Cells(pivot_ws.Rows.Count, 1).End(-4162).Row
            start_cell = pivot_ws.Cells(last_row + 7, 1)
            pivot_ws.Cells(last_row + 3, 1).Value = str(sheet.Name.split("_")[1])
            pivot_ws.Cells(last_row + 3, 1).Interior.ColorIndex = 6

            pt_cache = wb.PivotCaches().Create(1, sheet.UsedRange)
            pivot_table = pivot_ws.PivotTables().Add(pt_cache, start_cell)

            # Configure pivot table fields
            pivot_table.PivotFields("14").Orientation = 1
            pivot_table.PivotFields("Account_Mapping").Orientation = 1
            pivot_table.PivotFields("13").Orientation = 3
            pivot_table.PivotFields("Category").Orientation = 3
            pivot_table.PivotFields("Entity").Orientation = 2
            pivot_table.PivotFields("Year").Orientation = 2
            pivot_table.PivotFields("Month").Orientation = 2
            pivot_table.PivotFields("Amount USD").Orientation = 4

            pivot_table.ColumnGrand = True
            pivot_table.RowGrand = False
            pivot_table.SubtotalLocation(2)  # bottom
            pivot_table.RowAxisLayout(1)  # Tabular
            pivot_table.TableStyle2 = "PivotStyleMedium9"




import tkinter as tk
from tkinter import filedialog, messagebox
import sys

def browse_file():
    """Open file dialog and update label with file path"""
    file_path = filedialog.askopenfilename(
        parent=root,   # tie dialog to main window
        title="Select GIRS Excel File",
        filetypes=[("Excel Files", "*.xlsx *.xls")]
    )
    if file_path:
        selected_file.set(file_path)

def on_ok():
    """Check if file is selected and proceed"""
    file_path = selected_file.get()
    if not file_path or file_path == "No file selected":
        messagebox.showwarning("Warning", "You must select a file.\nIf you want to quit, click Cancel.")
    else:
        print(f"File selected: {file_path}")
        root.quit()   # stop mainloop safely

def on_cancel():
    """Exit program"""
    print("Program exited. No file selected.")
    root.quit()
    sys.exit(0)

# Main window
root = tk.Tk()
root.title("GIRS File Selector")

# === Row 0: Big Title ===
title_label = tk.Label(root, text="GIRS File Selector", font=("Arial", 16, "bold"))
title_label.grid(row=0, column=0, columnspan=3, padx=10, pady=15)

# === Row 1: Instruction + File path + Browse button ===
instr_label = tk.Label(root, text="Select GIRS File:")
instr_label.grid(row=1, column=0, padx=10, pady=10, sticky="w")

selected_file = tk.StringVar(value="No file selected")
file_display = tk.Label(root, textvariable=selected_file, width=50, anchor="w", relief="sunken", bg="white")
file_display.grid(row=1, column=1, padx=10, pady=10, sticky="we")

browse_btn = tk.Button(root, text="Browse", command=browse_file)
browse_btn.grid(row=1, column=2, padx=10, pady=10)

# === Row 2: OK and Cancel buttons ===
ok_btn = tk.Button(root, text="OK", width=12, command=on_ok)
ok_btn.grid(row=2, column=1, sticky="e", pady=15, padx=5)

cancel_btn = tk.Button(root, text="Cancel", width=12, command=on_cancel)
cancel_btn.grid(row=2, column=2, sticky="w", pady=15, padx=5)

# Adjust column weights so label expands nicely
root.grid_columnconfigure(1, weight=1)

# Run app
root.mainloop()

# After window closes, check final result
file_path = selected_file.get()
if file_path and file_path != "No file selected":
    print("Final file path:", file_path)
else:
    print("No file chosen.")



...............
import tkinter as tk
from tkinter import filedialog, messagebox
import sys

def browse_file():
    """Open file dialog and update label with file path"""
    file_path = filedialog.askopenfilename(
        parent=root,   # tie dialog to main window
        title="Select GIRS Excel File",
        filetypes=[("Excel Files", "*.xlsx *.xls")]
    )
    if file_path:
        selected_file.set(file_path)

def on_ok():
    """Check if file is selected and proceed"""
    file_path = selected_file.get()
    if not file_path or file_path == "No file selected":
        messagebox.showwarning("Warning", "You must select a file.\nIf you want to quit, click Cancel.")
    else:
        print(f"File selected: {file_path}")
        root.quit()   # stop mainloop safely

def on_cancel():
    """Exit program"""
    print("Program exited. No file selected.")
    root.quit()
    sys.exit(0)

# Main window
root = tk.Tk()
root.title("GIRS File Selector")

# === Row 0: Big Title ===
title_label = tk.Label(root, text="GIRS File Selector", font=("Arial", 16, "bold"))
title_label.grid(row=0, column=0, columnspan=3, padx=10, pady=15)

# === Row 1: Instruction + File path + Browse button ===
instr_label = tk.Label(root, text="Select GIRS File:")
instr_label.grid(row=1, column=0, padx=10, pady=10, sticky="w")

selected_file = tk.StringVar(value="No file selected")
file_display = tk.Label(root, textvariable=selected_file, width=50, anchor="w", relief="sunken", bg="white")
file_display.grid(row=1, column=1, padx=10, pady=10, sticky="we")

browse_btn = tk.Button(root, text="Browse", command=browse_file)
browse_btn.grid(row=1, column=2, padx=10, pady=10)

# === Row 2: OK and Cancel buttons ===
ok_btn = tk.Button(root, text="OK", width=12, command=on_ok)
ok_btn.grid(row=2, column=1, sticky="e", pady=15, padx=5)

cancel_btn = tk.Button(root, text="Cancel", width=12, command=on_cancel)
cancel_btn.grid(row=2, column=2, sticky="w", pady=15, padx=5)

# Adjust column weights so label expands nicely
root.grid_columnconfigure(1, weight=1)

# Run app
root.mainloop()

# After window closes, check final result
file_path = selected_file.get()
if file_path and file_path != "No file selected":
    print("Final file path:", file_path)
else:
    print("No file chosen.")
====================
import os
import time
import gc

def cleanup_files(files, retries=5, delay=1):
    """
    Safely delete a list of files after making sure they are closed.

    Args:
        files (list): list of file paths
        retries (int): how many times to retry if locked
        delay (int/float): seconds to wait between retries
    """
    # cleanup any references still held in memory
    gc.collect()

    for f in files:
        deleted = False
        for attempt in range(retries):
            try:
                if os.path.exists(f):
                    os.remove(f)
                    print(f"‚úÖ Deleted: {f}")
                deleted = True
                break
            except PermissionError:
                print(f"‚ö† {f} in use, retrying {attempt+1}/{retries}...")
                time.sleep(delay)
        if not deleted:
            print(f"‚ùå Could not delete {f}, still in use.")


files_to_delete = [
    "temp1.xlsx",
    "temp2.csv",
    r"C:\Users\...\AppData\Local\Temp\somefile.tmp"
]

cleanup_files(files_to_delete)


=IF(AND([@[BF Level 1]]="FS",OR([@[Employee Type]]="Salaried",[@[Employee Type]]="Contractor")),[@[Position ID]],"")


import os
import calendar

# Take user input for year
year = input("Enter the current year (e.g., 2025): ").strip()

# Create year folder if not exists
if not os.path.exists(year):
    os.mkdir(year)
    print(f"Created folder: {year}")
else:
    print(f"Folder '{year}' already exists.")

# Create 12 month folders inside the year folder
for month in range(1, 13):
    month_name = calendar.month_abbr[month]  # Jan, Feb, Mar, etc.
    folder_name = f"{month_name} {year}"
    folder_path = os.path.join(year, folder_name)

    if not os.path.exists(folder_path):
        os.mkdir(folder_path)
        print(f"  Created subfolder: {folder_name}")
    else:
        print(f"  Subfolder '{folder_name}' already exists.")

print("\n‚úÖ Folder structure setup complete!")


(
  Sum({
    < Date = {'$(=vActual)'}, 
      [Actual /Forecast] = {'Actuals'} 
  >} [FTE])
)
+
(
  Sum({
    < Date = {">=$(=Date#('$(vActual)','M/D/YYYY'))<=$(=Date#('1/31/2026','M/D/YYYY'))"},
      [Actual /Forecast] = {'Forecast'},
      Type -= {'One-offs'}
  >} [FTE])
)



# --- Conditions for billed employees (do not filter out 0 or 1 yet) ---
cond_billed = d1['Category for Static'].eq('Billed')
cond_empclass = d1['Employee Class'].eq('Employee')

df_billed = d1[cond_billed & cond_empclass]

# --- Case a: Exact match of FTEs ---
match_fte = df_billed['Employee FTE'] == df_billed['No. of FTE']
d1.loc[df_billed[match_fte].index, 'Observation'] = 'Ok'

# --- Case b1: No. of FTE = 1 but mismatch with Employee FTE ---
cond_b1 = (df_billed['No. of FTE'] == 1) & (df_billed['Employee FTE'] != 1)
d1.loc[df_billed[cond_b1].index, 'Observation'] = 'Update FTE to 1'

# --- Case b2: Sum(No. of FTE) per PSID = 1 but Employee FTE sum != 1 ---
fte_group = df_billed.groupby('PSID').agg({
    'No. of FTE': 'sum',
    'Employee FTE': 'sum'
}).reset_index()

problem_psids = fte_group[
    (fte_group['No. of FTE'] == 1) & (fte_group['Employee FTE'] != 1)
]['PSID']

cond_b2 = df_billed['PSID'].isin(problem_psids)
d1.loc[df_billed[cond_b2].index, 'Observation'] = 'Update FTE to 1'








ActiveSheet.ChartObjects
Sub FixLabelPosition()
    Dim s As Series
    For Each s In ActiveSheet.ChartObjects("Chart 1").Chart.SeriesCollection
        s.ApplyDataLabels
        s.DataLabels.Position = xlLabelPositionInsideBase
    Next s
End Sub



import pandas as pd
import numpy as np
import numpy as np

# 1. Filter for Billed & FTE not in [0,1]
cond_billed = d1['Category for Static'] == 'Billed'
cond_fte_not_01 = ~d1['Employee FTE'].isin([0, 1])
df_billed = d1[cond_billed & cond_fte_not_01].copy()

# 2. Coerce FTE values to float
df_billed['Employee FTE'] = pd.to_numeric(df_billed['Employee FTE'], errors='coerce')
df_billed['No. of FTE'] = pd.to_numeric(df_billed['No. of FTE'], errors='coerce')

# 3. Use np.isclose for float-safe match
df_billed['match'] = np.isclose(df_billed['Employee FTE'], df_billed['No. of FTE'], atol=0.01)

# 4. Debug info
print("Total rows:", len(df_billed))
print("Matched:", df_billed['match'].sum())
print("Unmatched:", (~df_billed['match']).sum())

# 5. Write to main dataframe using df_billed index
d1.loc[df_billed[df_billed['match']].index, 'Observation'] = 'Ok'
d1.loc[df_billed[~df_billed['match']].index, 'Observation'] = 'Update FTE value to 1'
..............................
invalid_vals = ['', 'n/a', 'na', 'nan', 'nan nan']

def is_invalid(val):
    return pd.isna(val) or str(val).strip().lower() in invalid_vals

def compare_con_cols(row):
    con = row['Con']
    con_hr = row['Con_HR']
    if is_invalid(con) or is_invalid(con_hr):
        return 'N/A'
    else:
        return con == con_hr

# Apply to dataframe
d1['Check'] = d1.apply(compare_con_cols, axis=1)

# Load your data
# d1 = pd.read_excel("your_file.xlsx")

# Clean column names to remove extra spaces
d1.columns = d1.columns.str.strip()

# Standardize necessary columns for consistent comparisons
d1['Category for Static'] = d1['Category for Static'].str.strip()
d1['Employee Class'] = d1['Employee Class'].str.strip()
d1['Global Career Band'] = d1['Global Career Band'].astype(str).str.strip()
d1['Check'] = d1['Check'].astype(str).str.lower()
d1['Lookup for Billed CC'] = d1['Lookup for Billed CC'].astype(str).str.strip()

# Initialize Observation column
d1['Observation'] = ""

### 1. For 'Category for Static' == 'Billed'
cond_billed = d1['Category for Static'] == 'Billed'
cond_fte_not_01 = ~d1['Employee FTE'].isin([0, 1])
df_billed = d1[cond_billed & cond_fte_not_01]

# a. If Employee FTE == No. of FTE ‚Üí Ok
match_fte = df_billed['Employee FTE'] == df_billed['No. of FTE']
d1.loc[df_billed[match_fte].index, 'Observation'] = 'Ok'

# b. Else ‚Üí Update FTE value to 1
d1.loc[df_billed[~match_fte].index, 'Observation'] = 'Update FTE value to 1'

### 2. For 'Category for Static' == 'Not Billed'
cond_not_billed = d1['Category for Static'] == 'Not Billed'

# a. If 'Lookup for Billed CC' is not blank or N/A ‚Üí Exclude
not_na_lkp = d1['Lookup for Billed CC'].str.upper().ne('N/A') & d1['Lookup for Billed CC'].ne("")
d1.loc[cond_not_billed & not_na_lkp, 'Observation'] = 'Exclude'

# b. If 'Lookup for Billed CC' is blank or N/A and Check = true ‚Üí Ok
is_na_lkp = d1['Lookup for Billed CC'].str.upper().eq('N/A') | d1['Lookup for Billed CC'].eq("")
check_true = d1['Check'].str.lower() == 'true'
d1.loc[cond_not_billed & is_na_lkp & check_true, 'Observation'] = 'Ok'

### 3. For 'Category for Static' == 'Others'
cond_others = d1['Category for Static'] == 'Others'
emp_class = d1['Employee Class'].str.lower()
gcb = d1['Global Career Band'].str.upper()

# a. External + Check true + GCB = Not Applicable ‚Üí Ok
d1.loc[cond_others & (emp_class == 'external') & (d1['Check'] == 'true') & (gcb == 'NOT APPLICABLE'), 'Observation'] = 'Ok'

# b. External + Check true + GCB ‚â† Not Applicable + Lookup not blank ‚Üí Exclude
not_blank_lkp = d1['Lookup for Billed CC'].ne("") & d1['Lookup for Billed CC'].str.upper().ne("N/A")
d1.loc[cond_others & (emp_class == 'external') & (d1['Check'] == 'true') & (gcb != 'NOT APPLICABLE') & not_blank_lkp, 'Observation'] = 'Exclude'

# c. Intern + Lookup not blank + GCB ‚â† Not Applicable ‚Üí Exclude
d1.loc[cond_others & (emp_class == 'intern') & not_blank_lkp & (gcb != 'NOT APPLICABLE'), 'Observation'] = 'Exclude'

# d. Intern + Lookup blank or N/A ‚Üí Ok
d1.loc[cond_others & (emp_class == 'intern') & ~not_blank_lkp, 'Observation'] = 'Ok'

# e. Intern + GCB = Not Applicable ‚Üí Ok
d1.loc[cond_others & (emp_class == 'intern') & (gcb == 'NOT APPLICABLE'), 'Observation'] = 'Ok'

# f. Employee + GCB = 3 or MD ‚Üí Ok
d1.loc[cond_others & (emp_class == 'employee') & (gcb.isin(['3', 'MD'])), 'Observation'] = 'Ok'

# Save if needed
# d1.to_excel("observation_updated.xlsx", index=False)




import pandas as pd

# Sample structure to mimic the actual data
columns_needed = [
    "Employee ID", "Employee Name", "Employee Business Email Address", 
    "Global Career Band", "Entity Manager Employee ID"
]

# For example, this would be your source data:
# df = pd.read_excel("source.xlsx", sheet_name="Data", usecols=columns_needed)
df = df.drop_duplicates(subset=["Employee ID"])  # ensure unique IDs

# Create lookup for Employee ID ‚Üí employee info
employee_lookup = df.set_index("Employee ID").to_dict("index")

# Helper to fetch employee info if exists
def get_info(emp_id):
    emp = employee_lookup.get(emp_id)
    if emp:
        return (
            emp_id,
            emp["Employee Name"],
            emp["Employee Business Email Address"],
            emp["Global Career Band"]
        )
    return (None, None, None, None)

# Add new columns
df["MD_ID"] = None
df["MD_Name"] = None
df["MD_Email"] = None

df["GCB3_ID"] = None
df["GCB3_Name"] = None
df["GCB3_Email"] = None

df["ReportingMgr_ID"] = None
df["ReportingMgr_Name"] = None
df["ReportingMgr_Email"] = None
df["ReportingMgr_GCB"] = None

for idx, row in df.iterrows():
    emp_id = row["Employee ID"]
    mgr_id = row["Entity Manager Employee ID"]

    # Trace upwards
    current_id = emp_id
    gcb_path = []

    while mgr_id:
        mgr_info = employee_lookup.get(mgr_id)
        if not mgr_info:
            break

        gcb = str(mgr_info["Global Career Band"]).strip()
        gcb_path.append((mgr_id, mgr_info))

        # Recurse upward
        mgr_id = mgr_info["Entity Manager Employee ID"]

    # Assign based on GCB level
    for mid, minfo in gcb_path:
        gcb = str(minfo["Global Career Band"]).strip()
        if gcb.upper() == "MD" and df.at[idx, "MD_ID"] is None:
            df.at[idx, "MD_ID"], df.at[idx, "MD_Name"], df.at[idx, "MD_Email"], _ = get_info(mid)
        elif gcb == "3" and df.at[idx, "GCB3_ID"] is None:
            df.at[idx, "GCB3_ID"], df.at[idx, "GCB3_Name"], df.at[idx, "GCB3_Email"], _ = get_info(mid)
        elif gcb in {"3", "4"} and df.at[idx, "ReportingMgr_ID"] is None:
            df.at[idx, "ReportingMgr_ID"], df.at[idx, "ReportingMgr_Name"], df.at[idx, "ReportingMgr_Email"], df.at[idx, "ReportingMgr_GCB"] = get_info(mid)

# Optional: reorder or save to Excel
final_cols = [
    "Employee ID", "Employee Name", "Employee Business Email Address", "Global Career Band",
    "MD_ID", "MD_Name", "MD_Email",
    "GCB3_ID", "GCB3_Name", "GCB3_Email",
    "ReportingMgr_ID", "ReportingMgr_Name", "ReportingMgr_Email", "ReportingMgr_GCB"
]

final_df = df[final_cols]

# Save result
# final_df.to_excel("final_hierarchy_output.xlsx", index=False)


---------------
import tkinter as tk
from tkinter import ttk, messagebox

def ask_month_year():
    result = {}

    def submit():
        # Validate year input
        if not year_var.get().isdigit() or len(year_var.get()) != 4:
            messagebox.showerror("Invalid Year", "Please enter a valid 4-digit year.")
            return
        result['month'] = month_var.get()
        result['year'] = year_var.get()
        root.quit()

    # Create window
    root = tk.Tk()
    root.title("Cost Templates Builder")
    root.geometry("350x200")
    root.resizable(False, False)

    # Project Name (centered)
    project_label = tk.Label(root, text="Cost Templates Builder", font=("Segoe UI", 14, "bold"))
    project_label.pack(pady=10)

    # Month Dropdown
    tk.Label(root, text="Select Current Month (MM):").pack(pady=5)
    month_var = tk.StringVar()
    months = [f"{i:02}" for i in range(1, 13)]
    month_dropdown = ttk.Combobox(root, textvariable=month_var, values=months, state="readonly", width=10)
    month_dropdown.current(0)
    month_dropdown.pack()

    # Year Entry
    tk.Label(root, text="Enter Base Year (YYYY):").pack(pady=5)
    year_var = tk.StringVar()
    year_entry = tk.Entry(root, textvariable=year_var, width=12, justify="center")
    year_entry.pack()

    # Submit Button
    tk.Button(root, text="Submit", command=submit).pack(pady=15)

    root.mainloop()
    root.destroy()

    return result['month'], result['year']


# Example usage
if __name__ == "__main__":
    month, year = ask_month_year()
    print(f"Selected Month: {month}, Base Year: {year}")

# === Example Usage ===
if __name__ == "__main__":
    project, from_month, to_month, year = ask_project_months_year()
    print(f"Project: {project}, From Month: {from_month}, To Month: {to_month}, Year: {year}")
--------

import tkinter as tk
from tkinter import ttk

def ask_month_year():
    result = {}

    def submit():
        result['month'] = month_var.get()
        result['year'] = year_var.get()
        root.quit()

    # Tkinter window
    root = tk.Tk()
    root.title("Select Month & Enter Year")
    root.geometry("300x150")
    root.resizable(False, False)

    # Month Dropdown
    tk.Label(root, text="Select Month (MM):").pack(pady=5)
    month_var = tk.StringVar()
    months = [f"{i:02}" for i in range(1, 13)]  # 01 - 12
    month_dropdown = ttk.Combobox(root, textvariable=month_var, values=months, state="readonly", width=10)
    month_dropdown.current(0)
    month_dropdown.pack()

    # Year Entry
    tk.Label(root, text="Enter Year (YYYY):").pack(pady=5)
    year_var = tk.StringVar()
    year_entry = tk.Entry(root, textvariable=year_var, width=12)
    year_entry.pack()
    year_entry.focus()

    # Submit Button
    tk.Button(root, text="OK", command=submit).pack(pady=10)

    root.mainloop()
    root.destroy()

    return result['month'], result['year']


# === Example Usage ===
if __name__ == "__main__":
    month, year = ask_month_year()
    print(f"Selected Month: {month}, Year: {year}")


import xlwings as xw
import os
import shutil

# === CONFIG ===
master_file = "Base_Dashboard.xlsx"
report_names = [
    "Investor Relations",
    "Stress Testing",
    "APEX (FC)",
    "Finance COO",
    "Financial Support"
]

sheets_and_cells = [
    ("Index", "D3"),
    ("Summary", "D3"),
    ("P&L Item View", "B3"),
    ("DC by Country", "B3"),
    ("Headcount by Country", "B3"),
    ("Driller", "B3")
]

# === OUTPUT FOLDER ===
output_folder = "Cost_Templates"

def create_copies():
    """Phase 1: Create all copies first using shutil (fast)."""
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    for i, report_name in enumerate(report_names, 1):
        output_path = os.path.join(output_folder, f"Dashboard_{report_name}.xlsx")
        shutil.copyfile(master_file, output_path)
        print(f"üìÇ [{i}/{len(report_names)}] Created copy for: {report_name}")

    print(f"\n‚úÖ Created {len(report_names)} copies in '{output_folder}'.")

def update_files():
    """Phase 2: Open each file, update cells, and save."""
    files = [f for f in os.listdir(output_folder) if f.endswith(".xlsx")]

    with xw.App(visible=False) as app:
        for idx, filename in enumerate(files, 1):
            file_path = os.path.join(output_folder, filename)
            print(f"‚úèÔ∏è [{idx}/{len(files)}] Updating file: {filename}")

            wb = app.books.open(file_path)

            # Extract report name from file name
            report_name = filename.replace("Dashboard_", "").replace(".xlsx", "")

            # Read month details from Dates sheet
            month_text = wb.sheets['Dates'].range('C4').value  # e.g. 'May-25'
            month_part, yy_part = month_text.split('-')
            year_full = "20" + yy_part
            month_year = f"{month_part} {year_full}"

            # Find Reporting sheet
            reporting_sheet = next((sh for sh in wb.sheets if "Reporting" in sh.name), None)
            if reporting_sheet:
                reporting_sheet.name = f"{month_year} Reporting"
                reporting_sheet.range("C20").value = report_name
                reporting_sheet.range("B25").value = f"{month_year} Results"

            # Update other sheets
            for sheet_name, cell in sheets_and_cells:
                ws = wb.sheets[sheet_name]
                ws.range(cell).value = report_name

            wb.save()
            wb.close()

    print(f"\n‚úÖ Updated {len(files)} files with required values.")

if __name__ == "__main__":
    create_copies()
    update_files()
===============================
import numpy as np
import pandas as pd

def convert_mixed_columns(df, columns):
    """
    Converts specified columns:
    - If value is alphanumeric (contains letters), keep as string.
    - If value is numeric only, convert to integer.

    Args:
        df (pd.DataFrame): Input DataFrame
        columns (list): List of column names to process

    Returns:
        pd.DataFrame: Modified DataFrame
    """
    df = df.copy()  # avoid modifying original

    for col in columns:
        col_str = df[col].astype(str).str.strip()
        is_alpha = col_str.str.contains('[A-Za-z]', regex=True)

        df[col] = np.where(
            is_alpha,
            col_str,  # keep as string
            pd.to_numeric(col_str, errors='coerce').fillna(0).astype(int)  # convert to int
        )

    return df


def clean_column_headers(df: pd.DataFrame) -> pd.DataFrame:
    def clean_name(col):
        col = str(col).strip()
        col = ' '.join(col.split())  # remove extra spaces in between
        if col.strip().upper() == 'YTD12':
            return 'YTD12'
        return col.title()  # convert to Title Case

    df.columns = [clean_name(col) for col in df.columns]
    return df



import pandas as pd

def apply_observations(d1: pd.DataFrame) -> pd.DataFrame:
    # Ensure relevant columns are strings where needed
    d1['Category for Static'] = d1['Category for Static'].astype(str).str.strip()
    d1['Lookup for Billed CC'] = d1['Lookup for Billed CC'].astype(str).str.strip().str.lower().replace('nan', '')
    d1['Check'] = d1['Check'].astype(str).str.strip().str.lower()
    
    # Make sure Observation & Comment exist
    if 'Observation' not in d1.columns:
        d1['Observation'] = ''
    if 'Comment' not in d1.columns:
        d1['Comment'] = ''

    # --------------------
    # üìå Billed
    mask_billed = d1['Category for Static'].str.lower() == 'billed'

    # 1) FTE mismatch
    mask_fte_mismatch = mask_billed & (d1['Employee FTE'] != d1['No. of FTE'])
    d1.loc[mask_fte_mismatch, 'Comment'] = 'values are not same'

    # 2) Employee FTE not 0/1 & No. of FTE = 1
    mask_fte_neither_0_1 = mask_billed & (~d1['Employee FTE'].isin([0,1])) & (d1['No. of FTE'] == 1)
    d1.loc[mask_fte_neither_0_1, 'Observation'] = 'Update FTE value to 1'

    # 3) Employee FTE == 0 & Class == Employee
    mask_fte_zero_employee = mask_billed & (d1['Employee FTE'] == 0) & (d1['Employee Class'].str.lower() == 'employee')
    d1.loc[mask_fte_zero_employee, 'Observation'] = 'Update FTE value to 1'

    # --------------------
    # üìå Not Billed
    mask_not_billed = d1['Category for Static'].str.lower() == 'not billed'

    # 1) Lookup for Billed CC not blank/n/a
    mask_lookup_not_blank = mask_not_billed & (d1['Lookup for Billed CC'] != '') & (d1['Lookup for Billed CC'] != 'n/a')
    d1.loc[mask_lookup_not_blank, 'Observation'] = 'Exclude'

    # 2) Lookup blank/n/a & Check True
    mask_lookup_blank_check_true = mask_not_billed & (d1['Lookup for Billed CC'].isin(['', 'n/a'])) & (d1['Check'] == 'true')
    d1.loc[mask_lookup_blank_check_true, 'Observation'] = 'Ok'

    # --------------------
    # üìå Others
    mask_others = d1['Category for Static'].str.lower() == 'others'

    # 1) External + Check True + GCB == Not Applicable
    mask1 = (
        mask_others &
        (d1['Employee Class'].str.lower() == 'external') &
        (d1['Check'] == 'true') &
        (d1['Global Career Band'].str.strip().str.lower() == 'not applicable')
    )
    d1.loc[mask1, 'Observation'] = 'Ok'

    # 2) External + Check True + GCB != Not Applicable + Lookup not blank/n/a
    mask2 = (
        mask_others &
        (d1['Employee Class'].str.lower() == 'external') &
        (d1['Check'] == 'true') &
        (d1['Global Career Band'].str.strip().str.lower() != 'not applicable') &
        (d1['Lookup for Billed CC'] != '') & (d1['Lookup for Billed CC'] != 'n/a')
    )
    d1.loc[mask2, 'Observation'] = 'Exclude'

    # 3) Intern + Lookup not blank/n/a + GCB != Not Applicable
    mask3 = (
        mask_others &
        (d1['Employee Class'].str.lower() == 'intern') &
        (d1['Lookup for Billed CC'] != '') & (d1['Lookup for Billed CC'] != 'n/a') &
        (d1['Global Career Band'].str.strip().str.lower() != 'not applicable')
    )
    d1.loc[mask3, 'Observation'] = 'Exclude'

    # 4) Intern + GCB == Not Applicable
    mask4 = (
        mask_others &
        (d1['Employee Class'].str.lower() == 'intern') &
        (d1['Global Career Band'].str.strip().str.lower() == 'not applicable')
    )
    d1.loc[mask4, 'Observation'] = 'Ok'

    # 5) Employee + GCB in [3, MD]
    mask5 = (
        mask_others &
        (d1['Employee Class'].str.lower() == 'employee') &
        (d1['Global Career Band'].astype(str).str.strip().isin(['3', 'MD']))
    )
    d1.loc[mask5, 'Observation'] = 'Ok'

    return d1
----------------------------------
import tkinter as tk
from tkinter import filedialog

def ask_user_to_select_folder():
    root = tk.Tk()
    root.withdraw()  # Hide the main window
    folder_path = filedialog.askdirectory(title="Select a Folder")
    return folder_path

# Example usage
selected_folder = ask_user_to_select_folder()
print("Selected folder:", selected_folder)

..


def safe_float(val):
    try:
        # Convert to string and strip commas and spaces
        val_str = str(val).replace(',', '').strip()
        # Skip typical error strings
        if val_str.upper() in ['#VALUE!', '#DIV/0!', 'RECALC_ERROR', 'N/A', 'NA', '', '‚Äì']:
            return 0.0
        return float(val_str)
    except:
        return 0.0



ytd_value = sum(
    float(row[f'M{month:02d} {curr_year}']) 
    for month in range(1, curr_month + 1)
    if f'M{month:02d} {curr_year}' in sheet.columns 
    and pd.notna(row[f'M{month:02d} {curr_year}'])
)

or

ytd_value = sum(
    float(row[f'M{month:02d} {curr_year}']) 
    for month in range(1, curr_month + 1)
    if f'M{month:02d} {curr_year}' in sheet.columns 
    and pd.notna(row[f'M{month:02d} {curr_year}'])
)

or

ytd_value = sum(
    float(row[f'M{month:02d} {curr_year}']) 
    for month in range(1, curr_month + 1)
    if f'M{month:02d} {curr_year}' in sheet.columns 
    and isinstance(row[f'M{month:02d} {curr_year}'], (int, float))
)



also
Period_value = f"{month_number_to_name(curr_month)} ‚Äì{str(curr_year)[-2:0]}"
should be

Period_value = f"{month_number_to_name(curr_month)} ‚Äì{str(curr_year)[-2:]}"



import xlwings as xw

from openpyxl import load_workbook

def fix_product_control_openpyxl(file_path, sheet_name="Data", header_row_number=2):
    """
    Uses openpyxl to loop over rows in the sheet,
    fix PRODUCT CONTROL's Business Framework Group in-place,
    then save the file.
    """

    wb = load_workbook(file_path)
    ws = wb[sheet_name]

    # --- Get headers ---
    header_row = [cell.value.strip() if cell.value else None for cell in ws[header_row_number]]

    try:
        bf_col_index = header_row.index("Business Framework")
        bfg_col_index = header_row.index("Business Framework Group")
    except ValueError:
        raise ValueError("'Business Framework' or 'Business Framework Group' column not found!")

    # --- Loop rows ---
    fix_count = 0

    for row in ws.iter_rows(min_row=header_row_number + 1):
        bf_cell = row[bf_col_index]
        bfg_cell = row[bfg_col_index]

        bf_value = str(bf_cell.value).strip().upper() if bf_cell.value else ""
        bfg_value = str(bfg_cell.value).strip() if bfg_cell.value else ""

        if bf_value == "PRODUCT CONTROL" and bfg_value != "L3 - Financial Control & Tax":
            bfg_cell.value = "L3 - Financial Control & Tax"
            fix_count += 1

    wb.save(file_path)
    wb.close()

    print(f"‚úÖ Fixed {fix_count} PRODUCT CONTROL rows and saved: {file_path}")

;;;;;;;;;
import xlwings as xw

def fix_product_control_xlwings(file_path, header_row, rows_to_fix):
    app = xw.App(visible=False)
    wb = app.books.open(file_path)
    ws = wb.sheets["Data"]

    headers = ws.range((header_row, 1)).expand('right').value

    bf_col_idx = headers.index("Business Framework") + 1
    bfg_col_idx = headers.index("Business Framework Group") + 1

    for idx in rows_to_fix:
        excel_row = header_row + 1 + idx  # pandas index to Excel row
        ws.range((excel_row, bfg_col_idx)).value = "L3 - Financial Control & Tax"

    wb.save()
    wb.close()
    app.quit()

# Example usage
rows_to_fix = to_fix.index.tolist()
fix_product_control_xlwings("your_file.xlsx", header_row=2, rows_to_fix=rows_to_fix)
-----------------------------------------
import xlwings as xw

def fix_product_control_xlwings(file_path, sheet_name, header_row):
    app = xw.App(visible=False)
    wb = app.books.open(file_path)
    ws = wb.sheets[sheet_name]

    headers = ws.range((header_row, 1)).expand('right').value

    try:
        bf_col_idx = headers.index("Business Framework") + 1
        bfg_col_idx = headers.index("Business Framework Group") + 1
    except ValueError:
        app.quit()
        raise Exception("One or both columns not found!")

    last_row = ws.cells.last_cell.row

    changed_count = 0

    for row in range(header_row + 1, last_row + 1):
        bf_val = ws.range((row, bf_col_idx)).value
        bfg_val = ws.range((row, bfg_col_idx)).value

        if isinstance(bf_val, str) and bf_val.strip().upper() == "PRODUCT CONTROL":
            if isinstance(bfg_val, str) and bfg_val.strip() != "L3 - Financial Control & Tax":
                ws.range((row, bfg_col_idx)).value = "L3 - Financial Control & Tax"
                changed_count += 1

    print(f"‚úÖ Updated {changed_count} rows for PRODUCT CONTROL.")

    fixed_file = file_path.replace(".xlsx", "_product_control_fixed.xlsx")
    wb.save(fixed_file)
    wb.close()
    app.quit()

    print(f"‚úÖ File saved: {fixed_file}")
    return fixed_file

# Example usage:
fix_product_control_xlwings(
    file_path="your_file.xlsx",
    sheet_name="Data",
    header_row=2  # Adjust if your header is on row 2
)

.......................................

import pandas as pd

def enrich_billing_entity_info(main_df: pd.DataFrame, last_month_df: pd.DataFrame, ospd_df: pd.DataFrame) -> pd.DataFrame:
    # Normalize BPCC and LE_Description
    def normalize_bpcc(series):
        return series.astype(str).str.strip().str.lstrip('0').str.upper()

    main_df['__BPCC_tmp'] = normalize_bpcc(main_df['Business Partner Cost Center'])
    last_month_df['__BPCC_tmp'] = normalize_bpcc(last_month_df['Business Partner Cost Center'])
    ospd_df['__BPCC_tmp'] = normalize_bpcc(ospd_df['CC_ID'])

    # Normalize LE_Description
    ospd_df['__LE_tmp'] = ospd_df['LE_Description'].astype(str).str.strip().str.upper()

    # Initialize columns
    if 'Comment' not in main_df.columns:
        main_df['Comment'] = ""
    main_df['Billing Entity name as per OSPD'] = ""

    # Set for faster lookup
    bpcc_last_month_set = set(last_month_df['__BPCC_tmp'])
    bpcc_ospd_set = set(ospd_df['__BPCC_tmp'])

    for idx, row in main_df.iterrows():
        bpcc = row['__BPCC_tmp']
        billing_entity = str(row['Billing Entity']).replace("_", " ").strip().upper()

        # Case 1: BPCC not found in OSPD
        if bpcc not in bpcc_ospd_set:
            main_df.at[idx, 'Comment'] = "No BPCC found in OSPD."
            continue

        # Case 2: New BPCC (not in last month file)
        if bpcc not in bpcc_last_month_set:
            matching_ospd_entries = ospd_df[ospd_df['__BPCC_tmp'] == bpcc]['__LE_tmp'].unique()

            # Join all expected LE_Descriptions from OSPD
            combined_le = " | ".join(sorted(set(matching_ospd_entries)))
            main_df.at[idx, 'Billing Entity name as per OSPD'] = combined_le

            # Compare with cleaned Billing Entity from main_df
            if billing_entity not in matching_ospd_entries:
                comment = f"New BPCC found. Billing Entity mismatch. Expected from OSPD: {combined_le}"
                main_df.at[idx, 'Comment'] = comment

    # Cleanup temporary columns
    main_df.drop(columns=['__BPCC_tmp'], inplace=True)
    return main_df
