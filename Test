import pandas as pd
import numpy as np

invalid_vals = ['', 'n/a', 'na', 'nan', 'nan nan']

def is_invalid(val):
    return pd.isna(val) or str(val).strip().lower() in invalid_vals

def compare_con_cols(row):
    con = row['Con']
    con_hr = row['Con_HR']
    if is_invalid(con) or is_invalid(con_hr):
        return 'N/A'
    else:
        return con == con_hr

# Apply to dataframe
d1['Check'] = d1.apply(compare_con_cols, axis=1)

# Load your data
# d1 = pd.read_excel("your_file.xlsx")

# Clean column names to remove extra spaces
d1.columns = d1.columns.str.strip()

# Standardize necessary columns for consistent comparisons
d1['Category for Static'] = d1['Category for Static'].str.strip()
d1['Employee Class'] = d1['Employee Class'].str.strip()
d1['Global Career Band'] = d1['Global Career Band'].astype(str).str.strip()
d1['Check'] = d1['Check'].astype(str).str.lower()
d1['Lookup for Billed CC'] = d1['Lookup for Billed CC'].astype(str).str.strip()

# Initialize Observation column
d1['Observation'] = ""

### 1. For 'Category for Static' == 'Billed'
cond_billed = d1['Category for Static'] == 'Billed'
cond_fte_not_01 = ~d1['Employee FTE'].isin([0, 1])
df_billed = d1[cond_billed & cond_fte_not_01]

# a. If Employee FTE == No. of FTE → Ok
match_fte = df_billed['Employee FTE'] == df_billed['No. of FTE']
d1.loc[df_billed[match_fte].index, 'Observation'] = 'Ok'

# b. Else → Update FTE value to 1
d1.loc[df_billed[~match_fte].index, 'Observation'] = 'Update FTE value to 1'

### 2. For 'Category for Static' == 'Not Billed'
cond_not_billed = d1['Category for Static'] == 'Not Billed'

# a. If 'Lookup for Billed CC' is not blank or N/A → Exclude
not_na_lkp = d1['Lookup for Billed CC'].str.upper().ne('N/A') & d1['Lookup for Billed CC'].ne("")
d1.loc[cond_not_billed & not_na_lkp, 'Observation'] = 'Exclude'

# b. If 'Lookup for Billed CC' is blank or N/A and Check = true → Ok
is_na_lkp = d1['Lookup for Billed CC'].str.upper().eq('N/A') | d1['Lookup for Billed CC'].eq("")
check_true = d1['Check'].str.lower() == 'true'
d1.loc[cond_not_billed & is_na_lkp & check_true, 'Observation'] = 'Ok'

### 3. For 'Category for Static' == 'Others'
cond_others = d1['Category for Static'] == 'Others'
emp_class = d1['Employee Class'].str.lower()
gcb = d1['Global Career Band'].str.upper()

# a. External + Check true + GCB = Not Applicable → Ok
d1.loc[cond_others & (emp_class == 'external') & (d1['Check'] == 'true') & (gcb == 'NOT APPLICABLE'), 'Observation'] = 'Ok'

# b. External + Check true + GCB ≠ Not Applicable + Lookup not blank → Exclude
not_blank_lkp = d1['Lookup for Billed CC'].ne("") & d1['Lookup for Billed CC'].str.upper().ne("N/A")
d1.loc[cond_others & (emp_class == 'external') & (d1['Check'] == 'true') & (gcb != 'NOT APPLICABLE') & not_blank_lkp, 'Observation'] = 'Exclude'

# c. Intern + Lookup not blank + GCB ≠ Not Applicable → Exclude
d1.loc[cond_others & (emp_class == 'intern') & not_blank_lkp & (gcb != 'NOT APPLICABLE'), 'Observation'] = 'Exclude'

# d. Intern + Lookup blank or N/A → Ok
d1.loc[cond_others & (emp_class == 'intern') & ~not_blank_lkp, 'Observation'] = 'Ok'

# e. Intern + GCB = Not Applicable → Ok
d1.loc[cond_others & (emp_class == 'intern') & (gcb == 'NOT APPLICABLE'), 'Observation'] = 'Ok'

# f. Employee + GCB = 3 or MD → Ok
d1.loc[cond_others & (emp_class == 'employee') & (gcb.isin(['3', 'MD'])), 'Observation'] = 'Ok'

# Save if needed
# d1.to_excel("observation_updated.xlsx", index=False)




import pandas as pd

# Sample structure to mimic the actual data
columns_needed = [
    "Employee ID", "Employee Name", "Employee Business Email Address", 
    "Global Career Band", "Entity Manager Employee ID"
]

# For example, this would be your source data:
# df = pd.read_excel("source.xlsx", sheet_name="Data", usecols=columns_needed)
df = df.drop_duplicates(subset=["Employee ID"])  # ensure unique IDs

# Create lookup for Employee ID → employee info
employee_lookup = df.set_index("Employee ID").to_dict("index")

# Helper to fetch employee info if exists
def get_info(emp_id):
    emp = employee_lookup.get(emp_id)
    if emp:
        return (
            emp_id,
            emp["Employee Name"],
            emp["Employee Business Email Address"],
            emp["Global Career Band"]
        )
    return (None, None, None, None)

# Add new columns
df["MD_ID"] = None
df["MD_Name"] = None
df["MD_Email"] = None

df["GCB3_ID"] = None
df["GCB3_Name"] = None
df["GCB3_Email"] = None

df["ReportingMgr_ID"] = None
df["ReportingMgr_Name"] = None
df["ReportingMgr_Email"] = None
df["ReportingMgr_GCB"] = None

for idx, row in df.iterrows():
    emp_id = row["Employee ID"]
    mgr_id = row["Entity Manager Employee ID"]

    # Trace upwards
    current_id = emp_id
    gcb_path = []

    while mgr_id:
        mgr_info = employee_lookup.get(mgr_id)
        if not mgr_info:
            break

        gcb = str(mgr_info["Global Career Band"]).strip()
        gcb_path.append((mgr_id, mgr_info))

        # Recurse upward
        mgr_id = mgr_info["Entity Manager Employee ID"]

    # Assign based on GCB level
    for mid, minfo in gcb_path:
        gcb = str(minfo["Global Career Band"]).strip()
        if gcb.upper() == "MD" and df.at[idx, "MD_ID"] is None:
            df.at[idx, "MD_ID"], df.at[idx, "MD_Name"], df.at[idx, "MD_Email"], _ = get_info(mid)
        elif gcb == "3" and df.at[idx, "GCB3_ID"] is None:
            df.at[idx, "GCB3_ID"], df.at[idx, "GCB3_Name"], df.at[idx, "GCB3_Email"], _ = get_info(mid)
        elif gcb in {"3", "4"} and df.at[idx, "ReportingMgr_ID"] is None:
            df.at[idx, "ReportingMgr_ID"], df.at[idx, "ReportingMgr_Name"], df.at[idx, "ReportingMgr_Email"], df.at[idx, "ReportingMgr_GCB"] = get_info(mid)

# Optional: reorder or save to Excel
final_cols = [
    "Employee ID", "Employee Name", "Employee Business Email Address", "Global Career Band",
    "MD_ID", "MD_Name", "MD_Email",
    "GCB3_ID", "GCB3_Name", "GCB3_Email",
    "ReportingMgr_ID", "ReportingMgr_Name", "ReportingMgr_Email", "ReportingMgr_GCB"
]

final_df = df[final_cols]

# Save result
# final_df.to_excel("final_hierarchy_output.xlsx", index=False)


---------------
import tkinter as tk
from tkinter import ttk, messagebox

def ask_month_year():
    result = {}

    def submit():
        # Validate year input
        if not year_var.get().isdigit() or len(year_var.get()) != 4:
            messagebox.showerror("Invalid Year", "Please enter a valid 4-digit year.")
            return
        result['month'] = month_var.get()
        result['year'] = year_var.get()
        root.quit()

    # Create window
    root = tk.Tk()
    root.title("Cost Templates Builder")
    root.geometry("350x200")
    root.resizable(False, False)

    # Project Name (centered)
    project_label = tk.Label(root, text="Cost Templates Builder", font=("Segoe UI", 14, "bold"))
    project_label.pack(pady=10)

    # Month Dropdown
    tk.Label(root, text="Select Current Month (MM):").pack(pady=5)
    month_var = tk.StringVar()
    months = [f"{i:02}" for i in range(1, 13)]
    month_dropdown = ttk.Combobox(root, textvariable=month_var, values=months, state="readonly", width=10)
    month_dropdown.current(0)
    month_dropdown.pack()

    # Year Entry
    tk.Label(root, text="Enter Base Year (YYYY):").pack(pady=5)
    year_var = tk.StringVar()
    year_entry = tk.Entry(root, textvariable=year_var, width=12, justify="center")
    year_entry.pack()

    # Submit Button
    tk.Button(root, text="Submit", command=submit).pack(pady=15)

    root.mainloop()
    root.destroy()

    return result['month'], result['year']


# Example usage
if __name__ == "__main__":
    month, year = ask_month_year()
    print(f"Selected Month: {month}, Base Year: {year}")

# === Example Usage ===
if __name__ == "__main__":
    project, from_month, to_month, year = ask_project_months_year()
    print(f"Project: {project}, From Month: {from_month}, To Month: {to_month}, Year: {year}")
--------

import tkinter as tk
from tkinter import ttk

def ask_month_year():
    result = {}

    def submit():
        result['month'] = month_var.get()
        result['year'] = year_var.get()
        root.quit()

    # Tkinter window
    root = tk.Tk()
    root.title("Select Month & Enter Year")
    root.geometry("300x150")
    root.resizable(False, False)

    # Month Dropdown
    tk.Label(root, text="Select Month (MM):").pack(pady=5)
    month_var = tk.StringVar()
    months = [f"{i:02}" for i in range(1, 13)]  # 01 - 12
    month_dropdown = ttk.Combobox(root, textvariable=month_var, values=months, state="readonly", width=10)
    month_dropdown.current(0)
    month_dropdown.pack()

    # Year Entry
    tk.Label(root, text="Enter Year (YYYY):").pack(pady=5)
    year_var = tk.StringVar()
    year_entry = tk.Entry(root, textvariable=year_var, width=12)
    year_entry.pack()
    year_entry.focus()

    # Submit Button
    tk.Button(root, text="OK", command=submit).pack(pady=10)

    root.mainloop()
    root.destroy()

    return result['month'], result['year']


# === Example Usage ===
if __name__ == "__main__":
    month, year = ask_month_year()
    print(f"Selected Month: {month}, Year: {year}")


import xlwings as xw
import os
import shutil

# === CONFIG ===
master_file = "Base_Dashboard.xlsx"
report_names = [
    "Investor Relations",
    "Stress Testing",
    "APEX (FC)",
    "Finance COO",
    "Financial Support"
]

sheets_and_cells = [
    ("Index", "D3"),
    ("Summary", "D3"),
    ("P&L Item View", "B3"),
    ("DC by Country", "B3"),
    ("Headcount by Country", "B3"),
    ("Driller", "B3")
]

# === OUTPUT FOLDER ===
output_folder = "Cost_Templates"

def create_copies():
    """Phase 1: Create all copies first using shutil (fast)."""
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    for i, report_name in enumerate(report_names, 1):
        output_path = os.path.join(output_folder, f"Dashboard_{report_name}.xlsx")
        shutil.copyfile(master_file, output_path)
        print(f"📂 [{i}/{len(report_names)}] Created copy for: {report_name}")

    print(f"\n✅ Created {len(report_names)} copies in '{output_folder}'.")

def update_files():
    """Phase 2: Open each file, update cells, and save."""
    files = [f for f in os.listdir(output_folder) if f.endswith(".xlsx")]

    with xw.App(visible=False) as app:
        for idx, filename in enumerate(files, 1):
            file_path = os.path.join(output_folder, filename)
            print(f"✏️ [{idx}/{len(files)}] Updating file: {filename}")

            wb = app.books.open(file_path)

            # Extract report name from file name
            report_name = filename.replace("Dashboard_", "").replace(".xlsx", "")

            # Read month details from Dates sheet
            month_text = wb.sheets['Dates'].range('C4').value  # e.g. 'May-25'
            month_part, yy_part = month_text.split('-')
            year_full = "20" + yy_part
            month_year = f"{month_part} {year_full}"

            # Find Reporting sheet
            reporting_sheet = next((sh for sh in wb.sheets if "Reporting" in sh.name), None)
            if reporting_sheet:
                reporting_sheet.name = f"{month_year} Reporting"
                reporting_sheet.range("C20").value = report_name
                reporting_sheet.range("B25").value = f"{month_year} Results"

            # Update other sheets
            for sheet_name, cell in sheets_and_cells:
                ws = wb.sheets[sheet_name]
                ws.range(cell).value = report_name

            wb.save()
            wb.close()

    print(f"\n✅ Updated {len(files)} files with required values.")

if __name__ == "__main__":
    create_copies()
    update_files()
===============================
import numpy as np
import pandas as pd

def convert_mixed_columns(df, columns):
    """
    Converts specified columns:
    - If value is alphanumeric (contains letters), keep as string.
    - If value is numeric only, convert to integer.

    Args:
        df (pd.DataFrame): Input DataFrame
        columns (list): List of column names to process

    Returns:
        pd.DataFrame: Modified DataFrame
    """
    df = df.copy()  # avoid modifying original

    for col in columns:
        col_str = df[col].astype(str).str.strip()
        is_alpha = col_str.str.contains('[A-Za-z]', regex=True)

        df[col] = np.where(
            is_alpha,
            col_str,  # keep as string
            pd.to_numeric(col_str, errors='coerce').fillna(0).astype(int)  # convert to int
        )

    return df


def clean_column_headers(df: pd.DataFrame) -> pd.DataFrame:
    def clean_name(col):
        col = str(col).strip()
        col = ' '.join(col.split())  # remove extra spaces in between
        if col.strip().upper() == 'YTD12':
            return 'YTD12'
        return col.title()  # convert to Title Case

    df.columns = [clean_name(col) for col in df.columns]
    return df



import pandas as pd

def apply_observations(d1: pd.DataFrame) -> pd.DataFrame:
    # Ensure relevant columns are strings where needed
    d1['Category for Static'] = d1['Category for Static'].astype(str).str.strip()
    d1['Lookup for Billed CC'] = d1['Lookup for Billed CC'].astype(str).str.strip().str.lower().replace('nan', '')
    d1['Check'] = d1['Check'].astype(str).str.strip().str.lower()
    
    # Make sure Observation & Comment exist
    if 'Observation' not in d1.columns:
        d1['Observation'] = ''
    if 'Comment' not in d1.columns:
        d1['Comment'] = ''

    # --------------------
    # 📌 Billed
    mask_billed = d1['Category for Static'].str.lower() == 'billed'

    # 1) FTE mismatch
    mask_fte_mismatch = mask_billed & (d1['Employee FTE'] != d1['No. of FTE'])
    d1.loc[mask_fte_mismatch, 'Comment'] = 'values are not same'

    # 2) Employee FTE not 0/1 & No. of FTE = 1
    mask_fte_neither_0_1 = mask_billed & (~d1['Employee FTE'].isin([0,1])) & (d1['No. of FTE'] == 1)
    d1.loc[mask_fte_neither_0_1, 'Observation'] = 'Update FTE value to 1'

    # 3) Employee FTE == 0 & Class == Employee
    mask_fte_zero_employee = mask_billed & (d1['Employee FTE'] == 0) & (d1['Employee Class'].str.lower() == 'employee')
    d1.loc[mask_fte_zero_employee, 'Observation'] = 'Update FTE value to 1'

    # --------------------
    # 📌 Not Billed
    mask_not_billed = d1['Category for Static'].str.lower() == 'not billed'

    # 1) Lookup for Billed CC not blank/n/a
    mask_lookup_not_blank = mask_not_billed & (d1['Lookup for Billed CC'] != '') & (d1['Lookup for Billed CC'] != 'n/a')
    d1.loc[mask_lookup_not_blank, 'Observation'] = 'Exclude'

    # 2) Lookup blank/n/a & Check True
    mask_lookup_blank_check_true = mask_not_billed & (d1['Lookup for Billed CC'].isin(['', 'n/a'])) & (d1['Check'] == 'true')
    d1.loc[mask_lookup_blank_check_true, 'Observation'] = 'Ok'

    # --------------------
    # 📌 Others
    mask_others = d1['Category for Static'].str.lower() == 'others'

    # 1) External + Check True + GCB == Not Applicable
    mask1 = (
        mask_others &
        (d1['Employee Class'].str.lower() == 'external') &
        (d1['Check'] == 'true') &
        (d1['Global Career Band'].str.strip().str.lower() == 'not applicable')
    )
    d1.loc[mask1, 'Observation'] = 'Ok'

    # 2) External + Check True + GCB != Not Applicable + Lookup not blank/n/a
    mask2 = (
        mask_others &
        (d1['Employee Class'].str.lower() == 'external') &
        (d1['Check'] == 'true') &
        (d1['Global Career Band'].str.strip().str.lower() != 'not applicable') &
        (d1['Lookup for Billed CC'] != '') & (d1['Lookup for Billed CC'] != 'n/a')
    )
    d1.loc[mask2, 'Observation'] = 'Exclude'

    # 3) Intern + Lookup not blank/n/a + GCB != Not Applicable
    mask3 = (
        mask_others &
        (d1['Employee Class'].str.lower() == 'intern') &
        (d1['Lookup for Billed CC'] != '') & (d1['Lookup for Billed CC'] != 'n/a') &
        (d1['Global Career Band'].str.strip().str.lower() != 'not applicable')
    )
    d1.loc[mask3, 'Observation'] = 'Exclude'

    # 4) Intern + GCB == Not Applicable
    mask4 = (
        mask_others &
        (d1['Employee Class'].str.lower() == 'intern') &
        (d1['Global Career Band'].str.strip().str.lower() == 'not applicable')
    )
    d1.loc[mask4, 'Observation'] = 'Ok'

    # 5) Employee + GCB in [3, MD]
    mask5 = (
        mask_others &
        (d1['Employee Class'].str.lower() == 'employee') &
        (d1['Global Career Band'].astype(str).str.strip().isin(['3', 'MD']))
    )
    d1.loc[mask5, 'Observation'] = 'Ok'

    return d1
----------------------------------
import tkinter as tk
from tkinter import filedialog

def ask_user_to_select_folder():
    root = tk.Tk()
    root.withdraw()  # Hide the main window
    folder_path = filedialog.askdirectory(title="Select a Folder")
    return folder_path

# Example usage
selected_folder = ask_user_to_select_folder()
print("Selected folder:", selected_folder)

..


def safe_float(val):
    try:
        # Convert to string and strip commas and spaces
        val_str = str(val).replace(',', '').strip()
        # Skip typical error strings
        if val_str.upper() in ['#VALUE!', '#DIV/0!', 'RECALC_ERROR', 'N/A', 'NA', '', '–']:
            return 0.0
        return float(val_str)
    except:
        return 0.0



ytd_value = sum(
    float(row[f'M{month:02d} {curr_year}']) 
    for month in range(1, curr_month + 1)
    if f'M{month:02d} {curr_year}' in sheet.columns 
    and pd.notna(row[f'M{month:02d} {curr_year}'])
)

or

ytd_value = sum(
    float(row[f'M{month:02d} {curr_year}']) 
    for month in range(1, curr_month + 1)
    if f'M{month:02d} {curr_year}' in sheet.columns 
    and pd.notna(row[f'M{month:02d} {curr_year}'])
)

or

ytd_value = sum(
    float(row[f'M{month:02d} {curr_year}']) 
    for month in range(1, curr_month + 1)
    if f'M{month:02d} {curr_year}' in sheet.columns 
    and isinstance(row[f'M{month:02d} {curr_year}'], (int, float))
)



also
Period_value = f"{month_number_to_name(curr_month)} –{str(curr_year)[-2:0]}"
should be

Period_value = f"{month_number_to_name(curr_month)} –{str(curr_year)[-2:]}"



import xlwings as xw

from openpyxl import load_workbook

def fix_product_control_openpyxl(file_path, sheet_name="Data", header_row_number=2):
    """
    Uses openpyxl to loop over rows in the sheet,
    fix PRODUCT CONTROL's Business Framework Group in-place,
    then save the file.
    """

    wb = load_workbook(file_path)
    ws = wb[sheet_name]

    # --- Get headers ---
    header_row = [cell.value.strip() if cell.value else None for cell in ws[header_row_number]]

    try:
        bf_col_index = header_row.index("Business Framework")
        bfg_col_index = header_row.index("Business Framework Group")
    except ValueError:
        raise ValueError("'Business Framework' or 'Business Framework Group' column not found!")

    # --- Loop rows ---
    fix_count = 0

    for row in ws.iter_rows(min_row=header_row_number + 1):
        bf_cell = row[bf_col_index]
        bfg_cell = row[bfg_col_index]

        bf_value = str(bf_cell.value).strip().upper() if bf_cell.value else ""
        bfg_value = str(bfg_cell.value).strip() if bfg_cell.value else ""

        if bf_value == "PRODUCT CONTROL" and bfg_value != "L3 - Financial Control & Tax":
            bfg_cell.value = "L3 - Financial Control & Tax"
            fix_count += 1

    wb.save(file_path)
    wb.close()

    print(f"✅ Fixed {fix_count} PRODUCT CONTROL rows and saved: {file_path}")

;;;;;;;;;
import xlwings as xw

def fix_product_control_xlwings(file_path, header_row, rows_to_fix):
    app = xw.App(visible=False)
    wb = app.books.open(file_path)
    ws = wb.sheets["Data"]

    headers = ws.range((header_row, 1)).expand('right').value

    bf_col_idx = headers.index("Business Framework") + 1
    bfg_col_idx = headers.index("Business Framework Group") + 1

    for idx in rows_to_fix:
        excel_row = header_row + 1 + idx  # pandas index to Excel row
        ws.range((excel_row, bfg_col_idx)).value = "L3 - Financial Control & Tax"

    wb.save()
    wb.close()
    app.quit()

# Example usage
rows_to_fix = to_fix.index.tolist()
fix_product_control_xlwings("your_file.xlsx", header_row=2, rows_to_fix=rows_to_fix)
-----------------------------------------
import xlwings as xw

def fix_product_control_xlwings(file_path, sheet_name, header_row):
    app = xw.App(visible=False)
    wb = app.books.open(file_path)
    ws = wb.sheets[sheet_name]

    headers = ws.range((header_row, 1)).expand('right').value

    try:
        bf_col_idx = headers.index("Business Framework") + 1
        bfg_col_idx = headers.index("Business Framework Group") + 1
    except ValueError:
        app.quit()
        raise Exception("One or both columns not found!")

    last_row = ws.cells.last_cell.row

    changed_count = 0

    for row in range(header_row + 1, last_row + 1):
        bf_val = ws.range((row, bf_col_idx)).value
        bfg_val = ws.range((row, bfg_col_idx)).value

        if isinstance(bf_val, str) and bf_val.strip().upper() == "PRODUCT CONTROL":
            if isinstance(bfg_val, str) and bfg_val.strip() != "L3 - Financial Control & Tax":
                ws.range((row, bfg_col_idx)).value = "L3 - Financial Control & Tax"
                changed_count += 1

    print(f"✅ Updated {changed_count} rows for PRODUCT CONTROL.")

    fixed_file = file_path.replace(".xlsx", "_product_control_fixed.xlsx")
    wb.save(fixed_file)
    wb.close()
    app.quit()

    print(f"✅ File saved: {fixed_file}")
    return fixed_file

# Example usage:
fix_product_control_xlwings(
    file_path="your_file.xlsx",
    sheet_name="Data",
    header_row=2  # Adjust if your header is on row 2
)

.......................................

import pandas as pd

def enrich_billing_entity_info(main_df: pd.DataFrame, last_month_df: pd.DataFrame, ospd_df: pd.DataFrame) -> pd.DataFrame:
    # Normalize BPCC and LE_Description
    def normalize_bpcc(series):
        return series.astype(str).str.strip().str.lstrip('0').str.upper()

    main_df['__BPCC_tmp'] = normalize_bpcc(main_df['Business Partner Cost Center'])
    last_month_df['__BPCC_tmp'] = normalize_bpcc(last_month_df['Business Partner Cost Center'])
    ospd_df['__BPCC_tmp'] = normalize_bpcc(ospd_df['CC_ID'])

    # Normalize LE_Description
    ospd_df['__LE_tmp'] = ospd_df['LE_Description'].astype(str).str.strip().str.upper()

    # Initialize columns
    if 'Comment' not in main_df.columns:
        main_df['Comment'] = ""
    main_df['Billing Entity name as per OSPD'] = ""

    # Set for faster lookup
    bpcc_last_month_set = set(last_month_df['__BPCC_tmp'])
    bpcc_ospd_set = set(ospd_df['__BPCC_tmp'])

    for idx, row in main_df.iterrows():
        bpcc = row['__BPCC_tmp']
        billing_entity = str(row['Billing Entity']).replace("_", " ").strip().upper()

        # Case 1: BPCC not found in OSPD
        if bpcc not in bpcc_ospd_set:
            main_df.at[idx, 'Comment'] = "No BPCC found in OSPD."
            continue

        # Case 2: New BPCC (not in last month file)
        if bpcc not in bpcc_last_month_set:
            matching_ospd_entries = ospd_df[ospd_df['__BPCC_tmp'] == bpcc]['__LE_tmp'].unique()

            # Join all expected LE_Descriptions from OSPD
            combined_le = " | ".join(sorted(set(matching_ospd_entries)))
            main_df.at[idx, 'Billing Entity name as per OSPD'] = combined_le

            # Compare with cleaned Billing Entity from main_df
            if billing_entity not in matching_ospd_entries:
                comment = f"New BPCC found. Billing Entity mismatch. Expected from OSPD: {combined_le}"
                main_df.at[idx, 'Comment'] = comment

    # Cleanup temporary columns
    main_df.drop(columns=['__BPCC_tmp'], inplace=True)
    return main_df
