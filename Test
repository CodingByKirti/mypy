def add_text_slide(lines, title=None):
    slide = pres.Slides.Add(pres.Slides.Count+1, 12)
    shape = slide.Shapes.AddTextbox(1, 50, 50, 800, 500)
    tf = shape.TextFrame
    tr = tf.TextRange
    tr.Font.Size = 10

    if title:
        tr.Text = title
        para = tr.Paragraphs(1)
        para.ParagraphFormat.Bullet.Visible = False
        para.IndentLevel = 1
    else:
        tr.Text = ""

    for raw in lines:
        indent = raw.count("\t")
        text = raw.replace("\t", "")
        if not text.strip():
            continue
        sep = "" if tr.Text == "" else "\r"
        tr.InsertAfter(sep + text)
        # FIX: use Paragraphs() with Count
        para = tr.Paragraphs(tr.Paragraphs().Count)
        para.ParagraphFormat.Bullet.Visible = True
        para.IndentLevel = max(1, min(5, indent + 1))


...
def add_text_slide(lines, title=None):
    slide = pres.Slides.Add(pres.Slides.Count+1, 12)  # blank layout
    tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
    tr.Font.Size = 10
    tr.Text = (title + "\r") if title else ""
    # replace tabs with spaces for consistent indentation
    tr.Text += "\r".join([ln.replace("\t", "    ") for ln in lines])



..............................
def add_text_slide(lines, title=None):
    slide = pres.Slides.Add(pres.Slides.Count+1, 12)
    shape = slide.Shapes.AddTextbox(1, 50, 50, 800, 500)
    tf = shape.TextFrame
    tr = tf.TextRange
    tr.Font.Size = 10

    if title:
        tr.Text = title
        para = tr.Paragraphs(1)
        para.ParagraphFormat.Bullet.Visible = False
        para.IndentLevel = 1
    else:
        tr.Text = ""

    for raw in lines:
        indent = raw.count("\t")
        text = raw.replace("\t", "")
        if not text.strip():
            continue
        sep = "" if tr.Text == "" else "\r"
        tr.InsertAfter(sep + text)
        para = tr.Paragraphs(tr.Paragraphs.Count)
        para.ParagraphFormat.Bullet.Visible = True
        para.IndentLevel = max(1, min(5, indent + 1))




import re
import pandas as pd

def export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              ppt_app,
                              pres,
                              max_per_slide=10,
                              show_names=True,
                              expanded_list=None):

    # ---------- helpers ----------
    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() in {"unspecified", "#n/a"} else s

    def is_md(row):
        title = clean(row.get("Position Title", ""))
        role  = clean(row.get("Role", ""))
        gcb   = str(row.get("GCB", "")).strip().upper()
        if gcb == "MD": return True
        if role.lower() in {"md", "managing director"}: return True
        if "managing director" in title.lower(): return True
        return False

    def line_for_actual(row, mgr_id=None):
        name = clean(row.get("Employee Name", "")) if show_names else ""
        title = clean(row.get("Position Title", ""))
        gcb   = clean(row.get("GCB", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = f"GCB{gcb}" if gcb and gcb not in {"MD"} else (gcb if gcb == "MD" else "")
        line = header if not footer else f"{header} | {footer}"
        if mgr_id is not None and not pd.isna(mgr_id):
            dr = int(direct_counts.get(mgr_id, 0) or 0)
            op = int(open_pos_counts.get(mgr_id, 0) or 0)
            meta = []
            if dr > 0: meta.append(f"DR:{dr}")
            if op > 0: meta.append(f"Open:{op}")
            if meta:
                line += " | " + " ".join(meta)
        return line

    def add_text_slide(lines, title=None):
        slide = pres.Slides.Add(pres.Slides.Count+1, 12)  # blank layout
        tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
        tr.Font.Size = 10
        tr.Text = (title + "\r") if title else ""
        tr.Text += "\r".join(lines)

    def combined_count_box_md34(c_md, c3, c4, tabs=2):
        lines = []
        if c_md > 0: lines.append(f"{c_md} X MD")
        if c3 > 0:  lines.append(f"{c3} X GCB3")
        if c4 > 0:  lines.append(f"{c4} X GCB4")
        if not lines: return None
        indent = "\t" * tabs
        return indent + ("\r".join(lines))

    def combined_count_box_56(c5, c6, tabs=2):
        lines = []
        if c5 > 0: lines.append(f"{c5} X GCB5")
        if c6 > 0: lines.append(f"{c6} X GCB6")
        if not lines: return None
        indent = "\t" * tabs
        return indent + ("\r".join(lines))

    def open_box(open_count, tabs=2):
        return (("\t" * tabs) + f"<Open Positions> X {open_count}") if open_count > 0 else None

    def clean_lines(lines):
        return [ln for ln in lines if ln and not re.search(r'\bnan\b', ln.strip(), flags=re.I)]

    # ---------- root ----------
    root_df = df_actual[df_actual["Employee ID"] == root_id]
    if root_df.empty: return
    root_row  = root_df.iloc[0]
    root_name = clean(root_row.get("Employee Name", ""))
    root_line = line_for_actual(root_row, mgr_id=root_id)

    # ---------- L5 under root ----------
    l5_actuals = df_actual[df_actual["Functional Manager Employee ID"] == root_id]
    l5_opens   = df_open[df_open["Functional Manager Employee ID"] == root_id]
    l5_items = [("actual", r) for _, r in l5_actuals.iterrows()]
    l5_items += [("open", r) for _, r in l5_opens.iterrows()]

    for i in range(0, len(l5_items), max_per_slide):
        batch = l5_items[i:i+max_per_slide]
        main_lines = [root_line]
        expanded_payloads = []

        for kind, l5 in batch:
            if kind == "open":
                op_line = ("\t" + f"<Open Position> | {clean(l5.get('Position Title',''))}")
                main_lines.append(op_line)
                continue

            l5_id   = l5.get("Employee ID")
            l5_name = clean(l5.get("Employee Name", ""))
            l5_line = "\t" + line_for_actual(l5, mgr_id=l5_id)
            main_lines.append(l5_line)

            # ---------- L6 under this L5 ----------
            l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
            l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]

            md_boxes, gcb3_boxes, gcb4_boxes, gcb5_boxes, gcb6_boxes = [], [], [], [], []
            for _, rr in l6_actuals.iterrows():
                line = "\t\t" + line_for_actual(rr, mgr_id=rr.get("Employee ID"))
                if is_md(rr):
                    md_boxes.append(line)
                    continue
                gcb = str(rr.get("GCB", "")).strip()
                if gcb == "3": gcb3_boxes.append(line)
                elif gcb == "4": gcb4_boxes.append(line)
                elif gcb == "5": gcb5_boxes.append(line)
                elif gcb == "6": gcb6_boxes.append(line)
                else: gcb6_boxes.append(line)

            c_md = len(md_boxes)
            c3, c4, c5, c6 = len(gcb3_boxes), len(gcb4_boxes), len(gcb5_boxes), len(gcb6_boxes)
            n_open = len(l6_opens.index)
            open_count_box = open_box(n_open, tabs=2)
            open_flag = 1 if open_count_box else 0

            total_full = c_md + c3 + c4 + c5 + c6 + open_flag
            if total_full <= max_per_slide:
                main_lines += md_boxes + gcb3_boxes + gcb4_boxes + gcb5_boxes + gcb6_boxes
                if open_count_box: main_lines.append(open_count_box)
                continue

            # ---------- Overflow: compress into two boxes ----------
            caseC = []
            b_md34 = combined_count_box_md34(c_md, c3, c4, tabs=2)
            b_56   = combined_count_box_56(c5, c6, tabs=2)
            if b_md34: caseC.append(b_md34)
            if b_56:   caseC.append(b_56)
            if open_count_box: caseC.append(open_count_box)
            main_lines += [b for b in caseC if b]

            # Expanded slide payload
            expanded_lines = [
                root_line,
                "\t" + line_for_actual(l5, mgr_id=l5_id),
                "\t[Expanded list]"
            ]
            expanded_lines += md_boxes + gcb3_boxes + gcb4_boxes
            b_56 = combined_count_box_56(c5, c6, tabs=2)
            if b_56: expanded_lines.append(b_56)
            if open_count_box: expanded_lines.append(open_count_box)

            expanded_payloads.append({
                "title": f"Expanded for L5: {l5_name}",
                "lines": expanded_lines,
                "summary_tuple": (root_name, l5_id, l5_name)
            })

        # write main slide
            # write main slide
        main_lines = clean_lines(main_lines)
        add_text_slide(main_lines)

        # write expanded slides
        for payload in expanded_payloads:
            lines = clean_lines(payload["lines"])
            add_text_slide(lines, title=payload.get("title"))
            if expanded_list is not None:
                expanded_list.append(payload["summary_tuple"])

        # completed successfully
        return True



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

import re
import pandas as pd

def export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              ppt_app,
                              pres,
                              max_per_slide=10,
                              show_names=True,
                              expanded_list=None):
    """
    Org chart for a single root (MD or standalone GCB3).
    Helpers are defined inside for drop-in usage.
    """

    # ---------- helpers ----------
    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() in {"unspecified", "#n/a"} else s

    MD_TITLE_RE = re.compile(r'\bmanaging\s*director\b', flags=re.I)
    MD_ABBR_RE  = re.compile(r'\bM\.?\s*D\.?\b', flags=re.I)

    def is_md(row):
        title = clean(row.get("Position Title", ""))
        role  = clean(row.get("Role", ""))
        t = title.lower()
        r = role.lower()
        if r in {"md", "managing director"}:
            return True
        if MD_TITLE_RE.search(t) or MD_ABBR_RE.search(title):
            return True
        if "managingdirector" in t or "director - managing" in t:
            return True
        return False

    def norm_gcb(val):
        s = clean(val).upper().replace("LEVEL", "").replace("GCB", "").strip()
        return s  # "3","4","5","6",""

    def line_for_actual(row, mgr_id=None):
        name = clean(row.get("Employee Name", "")) if show_names else ""
        title = clean(row.get("Position Title", ""))
        gcb   = clean(row.get("GCB", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = f"GCB{gcb}" if gcb and gcb not in {"MD"} else (gcb if gcb == "MD" else "")
        line = header if not footer else f"{header} | {footer}"
        if mgr_id is not None and not pd.isna(mgr_id):
            dr = int(direct_counts.get(mgr_id, 0) or 0)
            op = int(open_pos_counts.get(mgr_id, 0) or 0)
            meta = []
            if dr > 0: meta.append(f"DR:{dr}")
            if op > 0: meta.append(f"Open:{op}")
            if meta:
                line += " | " + " ".join(meta)
        return line

    def add_text_slide(lines, title=None):
        """
        COM-based slide writer. Maps tabs to PowerPoint bullet levels.
        Each item in `lines` is one paragraph; '\t' count sets IndentLevel.
        """
        slide = pres.Slides.Add(pres.Slides.Count+1, 12)  # ppLayoutBlank
        shape = slide.Shapes.AddTextbox(1, 50, 50, 800, 500)
        tf = shape.TextFrame
        tf.WordWrap = True
        tr = tf.TextRange
        tr.Font.Size = 10

        # Title (non-bullet)
        if title:
            p = tr.Paragraphs.Add()
            p.Text = title
            p.ParagraphFormat.Bullet.Visible = False
            p.IndentLevel = 1

        # Content paragraphs with bullet indentation
        for raw in lines:
            s = (raw or "").replace("\r", "")
            indent = s.count("\t")
            text = s.replace("\t", "")
            if not text.strip():
                continue
            p = tr.Paragraphs.Add()
            p.Text = text
            p.ParagraphFormat.Bullet.Visible = True
            p.IndentLevel = max(1, min(5, indent + 1))

    def combined_count_box_md34(c_md, c3, c4, tabs=2):
        total = (c_md or 0) + (c3 or 0) + (c4 or 0)
        if total <= 0: return None
        lines = []
        if c_md > 0: lines.append(f"{c_md} X MD")
        if c3 > 0:  lines.append(f"{c3} X GCB3")
        if c4 > 0:  lines.append(f"{c4} X GCB4")
        indent = "\t" * tabs
        return indent + ("\r".join(lines))

    def combined_count_box_56(c5, c6, tabs=2):
        total = (c5 or 0) + (c6 or 0)
        if total <= 0: return None
        lines = []
        if c5 > 0: lines.append(f"{c5} X GCB5")
        if c6 > 0: lines.append(f"{c6} X GCB6")
        indent = "\t" * tabs
        return indent + ("\r".join(lines))

    def open_line(open_count, tabs=2):
        oc = int(open_count or 0)
        return (("\t" * tabs) + f"<Open Positions> X {oc}") if oc > 0 else None

    def clean_lines(lines):
        return [ln for ln in lines if ln and not re.search(r'\bnan\b', ln.strip(), flags=re.I)]

    # ---------- root ----------
    root_df = df_actual[df_actual["Employee ID"] == root_id]
    if root_df.empty:
        return
    root_row  = root_df.iloc[0]
    root_name = clean(root_row.get("Employee Name", ""))
    root_line = line_for_actual(root_row, mgr_id=root_id)

    # ---------- L5 under root ----------
    l5_actuals = df_actual[df_actual["Functional Manager Employee ID"] == root_id]
    l5_opens   = df_open[df_open["Functional Manager Employee ID"] == root_id]
    l5_items = [("actual", r) for _, r in l5_actuals.iterrows()]
    l5_items += [("open", r) for _, r in l5_opens.iterrows()]

    # page L5s by max_per_slide
    for i in range(0, len(l5_items), max_per_slide):
        batch = l5_items[i:i+max_per_slide]
        main_lines = [root_line]
        expanded_payloads = []

        for kind, l5 in batch:
            if kind == "open":
                op_line = ("\t" + f"<Open Position> | {clean(l5.get('Position Title',''))}")
                main_lines.append(op_line)
                continue

            # L5 actual
            l5_id   = l5.get("Employee ID")
            l5_name = clean(l5.get("Employee Name", ""))
            l5_line = "\t" + line_for_actual(l5, mgr_id=l5_id)
            main_lines.append(l5_line)

            # ---------- L6 under this L5 ----------
            l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
            l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]

            md_boxes, gcb3_boxes, gcb4_boxes, gcb5_boxes, gcb6_boxes = [], [], [], [], []
            for _, rr in l6_actuals.iterrows():
                line = "\t\t" + line_for_actual(rr, mgr_id=rr.get("Employee ID"))

                # MD bucket first (never counted as GCB6)
                if is_md(rr):
                    md_boxes.append(line)
                    continue

                g = norm_gcb(rr.get("GCB", ""))
                if g == "3": gcb3_boxes.append(line)
                elif g == "4": gcb4_boxes.append(line)
                elif g == "5": gcb5_boxes.append(line)
                elif g == "6": gcb6_boxes.append(line)
                else:
                    # keep unknown separate (mark it) so we don't silently inflate counts
                    gcb6_boxes.append(line + " [Unclassified]")

            c_md = len(md_boxes)
            c3, c4, c5, c6 = len(gcb3_boxes), len(gcb4_boxes), len(gcb5_boxes), len(gcb6_boxes)
            n_open = len(l6_opens.index)
            open_count_line = open_line(n_open, tabs=2)
            open_flag = 1 if open_count_line else 0

            # ---------- Try full individuals first ----------
            total_full = c_md + c3 + c4 + c5 + c6 + open_flag
            if total_full <= max_per_slide:
                main_lines += md_boxes + gcb3_boxes + gcb4_boxes + gcb5_boxes + gcb6_boxes
                if open_count_line: main_lines.append(open_count_line)
                continue

            # ---------- Case C: compress MD+3+4 and 5+6 into two boxes ----------
            caseC = []
            b_md34 = combined_count_box_md34(c_md, c3, c4, tabs=2)
            b_56   = combined_count_box_56(c5, c6, tabs=2)
            if b_md34: caseC.append(b_md34)
            if b_56:   caseC.append(b_56)
            if open_count_line: caseC.append(open_count_line)
            main_lines += [b for b in caseC if b]

            # ---------- Expanded slide payload (show MD + 3/4 individuals; 5/6 compressed) ----------
            expanded_lines = [
                root_line,
                "\t" + line_for_actual(l5, mgr_id=l5_id),
                "\t[Expanded list]"
            ]
            # Full MD and 3/4 individuals
            expanded_lines += md_boxes + gcb3_boxes + gcb4_boxes
            # 5/6 combined counts
            b_56 = combined_count_box_56(c5, c6, tabs=2)
            if b_56: expanded_lines.append(b_56)
            # open positions
            if open_count_line: expanded_lines.append(open_count_line)

            expanded_payloads.append({
                "title": f"Expanded for L5: {l5_name}",
                "lines": expanded_lines,
                "summary_tuple": (root_name, l5_id, l5_name)
            })

        # ---------- write main slide ----------
        main_lines = clean_lines(main_lines)
        add_text_slide(main_lines)

        # ---------- write expanded slides ----------
        for payload in expanded_payloads:
            lines = clean_lines(payload["lines"])
            add_text_slide(lines, title=payload.get("title"))
            if expanded_list is not None:
                expanded_list.append(payload["summary_tuple"])

    # completed successfully
    return True



.............................

import re
import pandas as pd

# ---------- Helpers ----------

def clean(x):
    return "" if x is None else str(x).strip()

MD_TITLE_RE = re.compile(r'\bmanaging\s*director\b', flags=re.I)
MD_ABBR_RE  = re.compile(r'\bM\.?\s*D\.?\b', flags=re.I)

def is_md(record):
    """Detect MDs purely by role/title, not by GCB."""
    title = clean(record.get("Position Title", ""))
    role  = clean(record.get("Role", ""))
    if role.lower() in {"md", "managing director"}:
        return True
    t = title.lower()
    if MD_TITLE_RE.search(t) or MD_ABBR_RE.search(title):
        return True
    if "managingdirector" in t or "director - managing" in t:
        return True
    return False

def line_for_actual(record):
    emp_id = clean(record.get("Employee ID", ""))
    name   = clean(record.get("Employee Name", ""))
    title  = clean(record.get("Position Title", ""))
    gcb    = clean(record.get("GCB", ""))
    return f"{name} | {title} | GCB{gcb} | ID:{emp_id}"

def open_box(count, tabs=1):
    if count and count > 0:
        return ("\t"*tabs) + f"<Open Positions> X {count}"
    return None

def combined_count_box_34(c3, c4):
    total = (c3 or 0) + (c4 or 0)
    if total > 0:
        return "\t\tCombined GCB3+4 count: " + str(total)
    return None

def combined_count_box_56(c5, c6):
    total = (c5 or 0) + (c6 or 0)
    if total > 0:
        return "\t\tCombined GCB5+6 count: " + str(total)
    return None

def clean_lines(lines):
    return [line for line in lines if not re.search(r'\bnan\b', line.strip(), flags=re.I)]

# ---------- Main Export ----------

def export_indented_text_full(root_id, df_actual, df_open,
                              direct_counts, open_pos_counts,
                              ppt_app, pres,
                              max_per_slide=10,
                              show_names=True,
                              expanded_list=None,
                              summary_path=None):
    """
    Full export with MD bucket, correct counts, and COM-based slide writing.
    """

    root_line = f"Root ID: {root_id}"
    root_name = str(root_id)

    main_lines = []
    expanded_payloads = []

    # L5 actuals and opens under root
    l5_actuals = df_actual[df_actual["Functional Manager Employee ID"] == root_id]
    l5_opens   = df_open[df_open["Functional Manager Employee ID"] == root_id]

    for _, op in l5_opens.iterrows():
        op_title = clean(op.get("Position Title", ""))
        main_lines.append("\t" + f"<Open Position> | {op_title}")

    for _, l5 in l5_actuals.iterrows():
        l5_id   = l5.get("Employee ID")
        l5_name = clean(l5.get("Employee Name", ""))
        l5_line = "\t" + line_for_actual(l5)
        main_lines.append(l5_line)

        # classify L6
        l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
        l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]

        md_boxes, gcb3_boxes, gcb4_boxes, gcb5_boxes, gcb6_boxes = [], [], [], [], []
        for _, rr in l6_actuals.iterrows():
            line = "\t\t" + line_for_actual(rr)
            if is_md(rr):
                md_boxes.append(line)
                continue
            gcb = clean(rr.get("GCB", ""))
            if gcb == "3":
                gcb3_boxes.append(line)
            elif gcb == "4":
                gcb4_boxes.append(line)
            elif gcb == "5":
                gcb5_boxes.append(line)
            elif gcb == "6":
                gcb6_boxes.append(line)
            else:
                gcb6_boxes.append(line)

        c_md = len(md_boxes)
        c3, c4, c5, c6 = len(gcb3_boxes), len(gcb4_boxes), len(gcb5_boxes), len(gcb6_boxes)

        n_open_l6 = len(l6_opens.index)
        l6_open_box = open_box(n_open_l6, tabs=2)
        open_flag = 1 if l6_open_box else 0

        l5_is_md = is_md(l5)
        if l5_is_md and c_md > max_per_slide:
            expanded_lines = [root_line, "\t" + line_for_actual(l5)] + md_boxes
            non_md_total = c4 + c5 + c6 + open_flag
            if non_md_total <= max_per_slide:
                expanded_lines += gcb4_boxes + gcb5_boxes + gcb6_boxes
                if l6_open_box: expanded_lines.append(l6_open_box)
            else:
                b_34 = combined_count_box_34(0, c4)
                b_56 = combined_count_box_56(c5, c6)
                if b_34: expanded_lines.append(b_34)
                if b_56: expanded_lines.append(b_56)
                if l6_open_box: expanded_lines.append(l6_open_box)
            expanded_payloads.append({
                "lines": expanded_lines,
                "summary_tuple": (root_name, l5_id, l5_name)
            })
            continue

        total_full = c_md + c3 + c4 + c5 + c6 + open_flag
        if total_full <= max_per_slide:
            main_lines += md_boxes + gcb3_boxes + gcb4_boxes + gcb5_boxes + gcb6_boxes
            if l6_open_box: main_lines.append(l6_open_box)
            continue

        caseB = md_boxes + gcb3_boxes + gcb4_boxes
        b_56 = combined_count_box_56(c5, c6)
        if b_56: caseB.append(b_56)
        if l6_open_box: caseB.append(l6_open_box)
        if len(caseB) <= max_per_slide:
            main_lines += caseB
            continue

        caseC = md_boxes
        b_34 = combined_count_box_34(c3, c4)
        b_56 = combined_count_box_56(c5, c6)
        if b_34: caseC.append(b_34)
        if b_56: caseC.append(b_56)
        if l6_open_box: caseC.append(l6_open_box)
        main_lines += caseC

        expanded_lines = [root_line, "\t" + line_for_actual(l5)] + md_boxes + gcb3_boxes + gcb4_boxes
        b_56 = combined_count_box_56(c5, c6)
        if b_56: expanded_lines.append(b_56)
        if l6_open_box: expanded_lines.append(l6_open_box)
        expanded_payloads.append({
            "lines": expanded_lines,
            "summary_tuple": (root_name, l5_id, l5_name)
        })

    # write slides
    main_lines = clean_lines(main_lines)
    add_text_slide(main_lines, title=None)

    for payload in expanded_payloads:
        lines = clean_lines(payload["lines"])
        add_text_slide(lines, title=None)
        if expanded_list is not None:
            expanded_list.append(payload["summary_tuple"])

    return True


.....................................................
import re

def is_md(record):
    """Detect MDs explicitly."""
    gcb = str(record.get("GCB", "")).strip()
    title = str(record.get("Position Title", "")).strip().lower()
    role  = str(record.get("Role", "")).strip().lower()

    if gcb == "3":
        return True
    if role in {"md", "managing director"}:
        return True
    if "managing director" in title or re.search(r'\bMD\b', title, flags=re.I):
        return True
    return False


def clean_lines(lines):
    """Remove any line containing standalone NaN tokens."""
    cleaned = []
    for line in lines:
        s = line.strip()
        if re.search(r'\bnan\b', s, flags=re.I):
            continue
        cleaned.append(line)
    return cleaned


def build_org_chart(batch, df_actual, df_open, root_line, root_name,
                    max_per_slide, expanded_list=None):

    main_lines = []
    expanded_payloads = []

    for kind, l5 in batch:
        if kind == "open":
            op_line = ("\t" + f"<Open Position> | {clean(l5.get('Position Title',''))}")
            main_lines.append(op_line)
            continue

        # L5 actual
        l5_id   = l5.get("Employee ID")
        l5_name = clean(l5.get("Employee Name", ""))
        l5_line = "\t" + line_for_actual(l5, mgr_id=l5_id)
        main_lines.append(l5_line)

        # ---------- L6 under this L5 ----------
        l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
        l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]

        md_boxes, gcb3_boxes, gcb4_boxes, gcb5_boxes, gcb6_boxes = [], [], [], [], []
        for _, rr in l6_actuals.iterrows():
            line = "\t\t" + line_for_actual(rr, mgr_id=rr.get("Employee ID"))
            if is_md(rr):
                md_boxes.append(line)
                gcb3_boxes.append(line)  # treat MDs as GCB3
            else:
                gcb = str(rr.get("GCB", "")).strip()
                if gcb == "3": gcb3_boxes.append(line)
                elif gcb == "4": gcb4_boxes.append(line)
                elif gcb == "5": gcb5_boxes.append(line)
                elif gcb == "6": gcb6_boxes.append(line)
                else: gcb6_boxes.append(line)

        c_md = len(md_boxes)
        c3, c4, c5, c6 = len(gcb3_boxes), len(gcb4_boxes), len(gcb5_boxes), len(gcb6_boxes)

        n_open = len(l6_opens.index)
        open_count_box = open_box(n_open, tabs=2) if n_open > 0 else None
        open_box_count_flag = 1 if open_count_box else 0

        # ---------- Overflow for L5 MD with >10 MDs ----------
        l5_is_md = is_md(l5)
        if l5_is_md and c_md > max_per_slide:
            md_expanded_lines = [
                root_line,
                "\t" + line_for_actual(l5, mgr_id=l5_id)
            ]
            md_expanded_lines += md_boxes

            total_non_md = c4 + c5 + c6 + open_box_count_flag
            if total_non_md <= max_per_slide:
                md_expanded_lines += gcb4_boxes + gcb5_boxes + gcb6_boxes
                if open_count_box: md_expanded_lines.append(open_count_box)
            else:
                b_456 = combined_count_box_56(c5, c6)
                b_34  = combined_count_box_34(0, c4)
                compressed = []
                if b_34: compressed.append(b_34)
                if b_456: compressed.append(b_456)
                if open_count_box: compressed.append(open_count_box)
                md_expanded_lines += [b for b in compressed if b]

            expanded_payloads.append({
                "lines": md_expanded_lines,
                "summary_tuple": (root_name, l5_id, l5_name)
            })
            continue

        # ---------- Existing placement logic ----------
        if not gcb3_boxes and not gcb4_boxes:
            total_boxes_only_56 = c5 + c6 + open_box_count_flag
            if total_boxes_only_56 <= max_per_slide:
                main_lines += gcb5_boxes + gcb6_boxes
                if open_count_box: main_lines.append(open_count_box)
                continue

        total_full = c3 + c4 + c5 + c6 + open_box_count_flag
        if total_full <= max_per_slide:
            main_lines += gcb3_boxes + gcb4_boxes + gcb5_boxes + gcb6_boxes
            if open_count_box: main_lines.append(open_count_box)
            continue

        caseB = list(gcb3_boxes) + list(gcb4_boxes)
        b_56 = combined_count_box_56(c5, c6)
        if b_56: caseB.append(b_56)
        if open_count_box: caseB.append(open_count_box)
        if len([b for b in caseB if b]) <= max_per_slide:
            main_lines += [b for b in caseB if b]
            continue

        caseC = []
        b_34 = combined_count_box_34(c3, c4)
        b_56 = combined_count_box_56(c5, c6)
        if b_34: caseC.append(b_34)
        if b_56: caseC.append(b_56)
        if open_count_box: caseC.append(open_count_box)
        main_lines += [b for b in caseC if b]

        expanded_lines = [
            root_line,
            "\t" + line_for_actual(l5, mgr_id=l5_id)
        ]
        expanded_lines += gcb3_boxes + gcb4_boxes
        b_56 = combined_count_box_56(c5, c6)
        if b_56: expanded_lines.append(b_56)
        if open_count_box: expanded_lines.append(open_count_box)

        expanded_payloads.append({
            "lines": expanded_lines,
            "summary_tuple": (root_name, l5_id, l5_name)
        })

    # --- write slides (cleaned, no titles) ---
    main_lines = clean_lines(main_lines)
    add_text_slide(main_lines)

    for payload in expanded_payloads:
        payload["lines"] = clean_lines(payload["lines"])
        add_text_slide(payload["lines"])
        if expanded_list is not None:
            expanded_list.append(payload["summary_tuple"])












............
import re

def clean_lines(lines):
    cleaned = []
    for line in lines:
        s = line.strip()

        # Drop the entire line if it contains a standalone 'nan' token
        # (case-insensitive, but won't match words like 'Finance')
        if re.search(r'\bnan\b', s, flags=re.I):
            continue

        cleaned.append(line)

    return cleaned

Fixing alignment inside the combined count boxes

You’re seeing misalignment because each line is being prefixed with tabs or spaces independently. In PowerPoint, line-level indenting gets compounded per line. The fix is:

- Apply a single indent to the whole box.
- Use PowerPoint’s newline \r (not \n) for lines.
- Don’t add leading spaces/tabs to each line; build one string and let paragraph formatting handle alignment.

---

Updated helpers: single indent, clean lines, PowerPoint newlines

`python
def combinedbox34(c3, c4, tabs=2):
    """
    Returns ONE box string for 3/4 with clean alignment:
    - One indent applied to the whole box
    - Each line has no leading tabs/spaces
    - Uses PowerPoint newline \r
    """
    if (c3 or 0) + (c4 or 0) <= 0:
        return None
    lines = []
    if c3 and c3 > 0:
        lines.append(f"{c3} X GCB3")
    if c4 and c4 > 0:
        lines.append(f"{c4} X GCB4")
    indent = "\t" * tabs
    return indent + ("\r".join(lines))


def combinedbox56(c5, c6, tabs=2):
    """
    Returns ONE box string for 5/6 with clean alignment:
    - One indent applied to the whole box
    - Each line has no leading tabs/spaces
    - Uses PowerPoint newline \r
    """
    if (c5 or 0) + (c6 or 0) <= 0:
        return None
    lines = []
    if c5 and c5 > 0:
        lines.append(f"{c5} X GCB5")
    if c6 and c6 > 0:
        lines.append(f"{c6} X GCB6")
    indent = "\t" * tabs
    return indent + ("\r".join(lines))
`

Use these instead of returning separate lines. They produce one string per group, with consistent left edges for “3 X GCB5” and “1 X GCB6”.

---

Optional: enforce alignment via paragraph formatting

After adding text, you can normalize alignment and indent to avoid surprises:

`python
def addtextslide(lines, title=None):
    slide = pres.Slides.Add(pres.Slides.Count+1, 12)  # ppLayoutBlank
    shp = slide.Shapes.AddTextbox(1, 50, 50, 800, 500)
    tr = shp.TextFrame.TextRange
    tr.Font.Size = 10
    tr.Text = (title + "\r") if title else ""
    tr.Text += "\r".join(lines)

    # Normalize alignment for the entire text box
    tr.ParagraphFormat.Alignment = 1  # ppAlignLeft
    tr.ParagraphFormat.FirstLineIndent = 0
    tr.ParagraphFormat.LeftIndent = 0

    # For each paragraph, remove unintended extra indents
    for i in range(1, tr.Paragraphs().Count + 1):
        p = tr.Paragraphs(i)
        p.ParagraphFormat.Alignment = 1  # left
        p.ParagraphFormat.FirstLineIndent = 0
        p.ParagraphFormat.LeftIndent = 0
`

This strips accidental per-line indent and keeps everything flush-left inside the box. Your group-level indent is from the single "\t" * tabs prefix only.

---

Where to use the combined boxes

- Case B (collapse 5/6 only):
`python
caseb = gcb3boxes + gcb4_boxes
b56 = combinedbox56(c5, c6, tabs=2)
if b56: case_b.append(b56)
if opencountbox: caseb.append(opencount_box)
`

- Case C (collapse 3/4 and 5/6):
`python
case_c = []
b34 = combinedbox34(c3, c4, tabs=2)
b56 = combinedbox56(c5, c6, tabs=2)
if b34: case_c.append(b34)
if b56: case_c.append(b56)
if opencountbox: casec.append(opencount_box)
mainlines += casec
`

- Expanded slide (3/4 individuals + 5/6 combined box):
`python
expandedlines += gcb3boxes + gcb4_boxes
b56 = combinedbox56(c5, c6, tabs=2)
if b56: expanded_lines.append(b56)
if opencountbox: expandedlines.append(opencount_box)
`

---

If alignment still looks off, remove tabs completely and rely purely on paragraph indents (set LeftIndent for the combined boxes’ paragraphs to a fixed value). I can show that variant if you prefer a tabless approach.










Understood, Kirti — you don’t want a combined label like GCB5+GCB6.  
You want two separate lines when collapsing:

`
3 X GCB5
1 X GCB6
`

…and the same for GCB3 and GCB4:

`
5 X GCB3
6 X GCB4
`

Only show a line if the count is > 0.

---

Updated helper definitions

`python
def combinedbox34(c3, c4, tabs=2):
    """
    Return up to two lines: one for GCB3, one for GCB4.
    Only include if count > 0.
    """
    boxes = []
    if c3 > 0:
        boxes.append(("\t" * tabs) + f"{c3} X GCB3")
    if c4 > 0:
        boxes.append(("\t" * tabs) + f"{c4} X GCB4")
    return boxes


def combinedbox56(c5, c6, tabs=2):
    """
    Return up to two lines: one for GCB5, one for GCB6.
    Only include if count > 0.
    """
    boxes = []
    if c5 > 0:
        boxes.append(("\t" * tabs) + f"{c5} X GCB5")
    if c6 > 0:
        boxes.append(("\t" * tabs) + f"{c6} X GCB6")
    return boxes
`

---

How to use them

- Case B (collapse 5/6 only, keep 3/4 individuals):
`python
caseB = gcb3boxes + gcb4boxes
caseB += combinedbox56(c5, c6)
if opencountbox: caseB.append(opencountbox)
`

- Case C (collapse both 3/4 and 5/6):
`python
caseC = []
caseC += combinedbox34(c3, c4)
caseC += combinedbox56(c5, c6)
if opencountbox: caseC.append(opencountbox)
main_lines += caseC
`

- Expanded slide (individuals for 3/4, counts for 5/6):
`python
expandedlines += gcb3boxes + gcb4_boxes
expandedlines += combinedbox_56(c5, c6)
if opencountbox: expandedlines.append(opencount_box)
`

---

✅ Example outputs

- If c3 = 5, c4 = 6:  
  `
  5 X GCB3
  6 X GCB4
  `

- If c5 = 3, c6 = 1:  
  `
  3 X GCB5
  1 X GCB6
  `

- If one grade is zero, only the non‑zero line appears.  
- If both are zero, no box at all.

---

This way you’ll always get two boxes maximum when collapsing: one for 3/4 (with up to two lines inside), one for 5/6 (with up to two lines inside). Would you like me to paste the full corrected function with these helpers integrated, so you can drop it straight in?






def combined_count_box_34(c3, c4, tabs=2):
    """
    Return ONE combined box for GCB3+GCB4 if either count > 0.
    Shows total and only non-zero per-grade breakdown.
    """
    total = c3 + c4
    if total <= 0:
        return None
    breakdown = []
    if c3 > 0:
        breakdown.append(f"3:{c3}")
    if c4 > 0:
        breakdown.append(f"4:{c4}")
    return (("\t" * tabs) + f"{total} X GCB3+GCB4 ({', '.join(breakdown)})")


def combined_count_box_56(c5, c6, tabs=2):
    """
    Return ONE combined box for GCB5+GCB6 if either count > 0.
    Shows total and only non-zero per-grade breakdown.
    """
    total = c5 + c6
    if total <= 0:
        return None
    breakdown = []
    if c5 > 0:
        breakdown.append(f"5:{c5}")
    if c6 > 0:
        breakdown.append(f"6:{c6}")
    return (("\t" * tabs) + f"{total} X GCB5+GCB6 ({', '.join(breakdown)})")



..........
............










caseB = list(gcb3_boxes) + list(gcb4_boxes)
caseB += combined_count_box_56(c5, c6)  # EXTEND, not append
if open_count_box:
    caseB.append(open_count_box)

if len(caseB) <= max_per_slide:
    main_lines += caseB
    continue



......


caseC = []
caseC += combined_count_box_34(c3, c4)  # EXTEND, not append
caseC += combined_count_box_56(c5, c6)  # EXTEND, not append
if open_count_box:
    caseC.append(open_count_box)

main_lines += caseC





....

expanded_lines = [
    root_line,
    "\t" + line_for_actual(l5, mgr_id=l5_id),
    "\t[Expanded list]"
]
expanded_lines += gcb3_boxes
expanded_lines += gcb4_boxes
expanded_lines += combined_count_box_56(c5, c6)  # EXTEND, not append
if open_count_box:
    expanded_lines.append(open_count_box)
.....




case b
caseB = gcb3_boxes + gcb4_boxes
caseB += combined_count_box_56(c5, c6)
if open_count_box: caseB.append(open_count_box)

case c 
caseC = []
caseC += combined_count_box_34(c3, c4)
caseC += combined_count_box_56(c5, c6)
if open_count_box: caseC.append(open_count_box)


expanded_lines += gcb3_boxes + gcb4_boxes
expanded_lines += combined_count_box_56(c5, c6)
if open_count_box: expanded_lines.append(open_count_box)









def combined_count_box_34(c3, c4, tabs=2):
    """
    Return count boxes for GCB3 and GCB4 if counts > 0.
    Each grade gets its own box line.
    """
    boxes = []
    if c3 > 0:
        boxes.append(("\t" * tabs) + f"{c3} X GCB3")
    if c4 > 0:
        boxes.append(("\t" * tabs) + f"{c4} X GCB4")
    return boxes  # returns a list of strings (may be empty)


def combined_count_box_56(c5, c6, tabs=2):
    """
    Return count boxes for GCB5 and GCB6 if counts > 0.
    Each grade gets its own box line.
    """
    boxes = []
    if c5 > 0:
        boxes.append(("\t" * tabs) + f"{c5} X GCB5")
    if c6 > 0:
        boxes.append(("\t" * tabs) + f"{c6} X GCB6")
    return boxes  # returns a list of strings (may be empty)

import pandas as pd
import win32com.client

def export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              ppt_app,
                              pres,
                              max_per_slide=10,
                              show_names=True,
                              expanded_list=None):
    """
    Org chart for a single root (MD or standalone GCB3).
    """

    # ---------- helpers ----------
    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() in {"unspecified", "#n/a"} else s

    def line_for_actual(row, mgr_id=None):
        name = clean(row.get("Employee Name", "")) if show_names else ""
        title = clean(row.get("Position Title", ""))
        gcb   = clean(row.get("GCB", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = f"GCB{gcb}" if gcb and gcb not in {"MD"} else (gcb if gcb == "MD" else "")
        line = header if not footer else f"{header}\n{footer}"
        # add counts
        if mgr_id is not None and not pd.isna(mgr_id):
            dr = direct_counts.get(mgr_id, 0)
            op = open_pos_counts.get(mgr_id, 0)
            if dr > 0: line += f"\n→ Direct Reports: {dr}"
            if op > 0: line += f"\n→ Open Positions: {op}"
        return line

    def add_text_slide(lines, title=None):
        slide = pres.Slides.Add(pres.Slides.Count+1, 12)  # ppLayoutBlank
        tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
        tr.Font.Size = 10
        tr.Text = (title + "\r") if title else ""
        tr.Text += "\r".join(lines)

    def combined_count_box_34(c3, c4, tabs=2):
        total = c3 + c4
        if total <= 0: return None
        return (("\t" * tabs) + f"GCB3+GCB4: {total} (3:{c3}, 4:{c4})")

    def combined_count_box_56(c5, c6, tabs=2):
        total = c5 + c6
        if total <= 0: return None
        return (("\t" * tabs) + f"GCB5+GCB6: {total} (5:{c5}, 6:{c6})")

    def open_box(open_count, tabs=2):
        return (("\t" * tabs) + f"<Open Positions> X {open_count}") if open_count > 0 else None

    # ---------- root ----------
    root_df = df_actual[df_actual["Employee ID"] == root_id]
    if root_df.empty:
        return
    root_row  = root_df.iloc[0]
    root_name = clean(root_row.get("Employee Name", ""))
    root_line = line_for_actual(root_row, mgr_id=root_id)

    # ---------- L5 under root ----------
    l5_actuals = df_actual[df_actual["Functional Manager Employee ID"] == root_id]
    l5_opens   = df_open[df_open["Functional Manager Employee ID"] == root_id]
    l5_items = [("actual", r) for _, r in l5_actuals.iterrows()]
    l5_items += [("open", r) for _, r in l5_opens.iterrows()]

    # page L5s by max_per_slide
    for i in range(0, len(l5_items), max_per_slide):
        batch = l5_items[i:i+max_per_slide]
        main_lines = [root_line]
        expanded_payloads = []

        for kind, l5 in batch:
            if kind == "open":
                op_line = ("\t" + f"<Open Position> | {clean(l5.get('Position Title',''))}")
                main_lines.append(op_line)
                continue

            # L5 actual
            l5_id   = l5.get("Employee ID")
            l5_name = clean(l5.get("Employee Name", ""))
            l5_line = "\t" + line_for_actual(l5, mgr_id=l5_id)
            main_lines.append(l5_line)

            # ---------- L6 under this L5 ----------
            l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
            l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]

            gcb3_boxes, gcb4_boxes, gcb5_boxes, gcb6_boxes = [], [], [], []
            for _, rr in l6_actuals.iterrows():
                gcb = str(rr.get("GCB", "")).strip()
                line = "\t\t" + line_for_actual(rr, mgr_id=rr.get("Employee ID"))
                if gcb == "3": gcb3_boxes.append(line)
                elif gcb == "4": gcb4_boxes.append(line)
                elif gcb == "5": gcb5_boxes.append(line)
                elif gcb == "6": gcb6_boxes.append(line)
                else: gcb6_boxes.append(line)  # unknown → treat as 6

            c3, c4, c5, c6 = len(gcb3_boxes), len(gcb4_boxes), len(gcb5_boxes), len(gcb6_boxes)
            n_open = len(l6_opens.index)
            open_count_box = open_box(n_open, tabs=2)
            open_box_count_flag = 1 if open_count_box else 0

            # ---------- special case: only 5/6 present and fits ----------
            if not gcb3_boxes and not gcb4_boxes:
                total_boxes_only_56 = c5 + c6 + open_box_count_flag
                if total_boxes_only_56 <= max_per_slide:
                    main_lines += gcb5_boxes + gcb6_boxes
                    if open_count_box: main_lines.append(open_count_box)
                    continue

            # ---------- Try full individuals first ----------
            total_full = c3 + c4 + c5 + c6 + open_box_count_flag
            if total_full <= max_per_slide:
                main_lines += gcb3_boxes + gcb4_boxes + gcb5_boxes + gcb6_boxes
                if open_count_box: main_lines.append(open_count_box)
                continue

            # ---------- Case B: compress 5/6 into combined count, keep 3/4 individuals ----------
            caseB = list(gcb3_boxes) + list(gcb4_boxes)
            b_56 = combined_count_box_56(c5, c6)
            if b_56: caseB.append(b_56)
            if open_count_box: caseB.append(open_count_box)
            if len([b for b in caseB if b]) <= max_per_slide:
                main_lines += [b for b in caseB if b]
                continue

            # ---------- Case C: compress 3/4 as well; show counts + open, and create expanded ----------
            caseC = []
            b_34 = combined_count_box_34(c3, c4)
            b_56 = combined_count_box_56(c5, c6)
            if b_34: caseC.append(b_34)
            if b_56: caseC.append(b_56)
            if open_count_box: caseC.append(open_count_box)
            main_lines += [b for b in caseC if b]

            # Expanded slide payload
            expanded_lines = [
                root_line,
                "\t" + line_for_actual(l5, mgr_id=l5_id),
                "\t[Expanded list]"
            ]
            expanded_lines += gcb3_boxes + gcb4_boxes
            b_56 = combined_count_box_56(c5, c6)
            if b_56: expanded_lines.append(b_56)
            if open_count_box: expanded_lines.append(open_count_box)

            expanded_payloads.append({
                "title": f"Expanded for L5: {l5_name}",
                "lines": expanded_lines,
                "summary_tuple": (root_name, l5_id, l5_name)
            })

        # write main slide
        add_text_slide(main_lines, title=f"Org chart: {root_name}")
        # write expanded slides for ALL overflow L5s in this batch
        for payload in expanded_payloads:
            add_text_slide(payload["lines"], title=payload["title"])
            if expanded_list is not None:
                expanded_list.append(payload["summary_tuple"])



..........
import win32com.client

# PowerPoint setup
ppt_app = win32com.client.Dispatch("PowerPoint.Application")
ppt_app.Visible = True
pres = ppt_app.Presentations.Add()

# Build roots
all_mds = df_actual[df_actual["GCB"].astype(str).str.strip() == "MD"][["Employee ID","Functional Manager Employee ID"]].copy()

# Choose ONLY top-level MDs (manager not MD or missing). If you want all MDs, just use all_mds["Employee ID"].
md_ids = all_mds["Employee ID"].dropna()
md_manager_ids = all_mds["Functional Manager Employee ID"].dropna()
top_level_mds = all_mds[~all_mds["Functional Manager Employee ID"].isin(md_ids)]["Employee ID"].dropna().tolist()

# Standalone GCB3s (not under any MD)
gcb3_all = df_actual[df_actual["GCB"].astype(str).str.strip() == "3"]
standalone_gcb3 = gcb3_all[~gcb3_all["Functional Manager Employee ID"].isin(md_ids)]["Employee ID"].dropna().tolist()

# Final roots list (de-duped)
roots = list(dict.fromkeys(top_level_mds + standalone_gcb3))

# Collect expanded cases across all roots
expanded_across_roots = []

# Generate charts
for root_id in roots:
    export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              ppt_app,
                              pres,
                              max_per_slide=10,
                              show_names=True,
                              expanded_list=expanded_across_roots)

# Final summary slide across all roots
if expanded_across_roots:
    slide = pres.Slides.Add(pres.Slides.Count+1, 12)
    tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
    tr.Font.Size = 12
    tr.Text = "Expanded L5 managers (final fallback applied):\r" + \
              "\r".join([f"- {l5_name} (ID: {l5_id}) under {root_name}"
                         for root_name, l5_id, l5_name in expanded_across_roots])

# Save once at the end — use a full path and make sure file is not open elsewhere
pres.SaveAs(r"C:\Users\Kirti\Documents\OrgCharts_All.pptx")
pres.Close()

::::::::::


import pandas as pd
import win32com.client

def export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              ppt_app,
                              pres,
                              max_per_slide=10,
                              show_names=True,
                              expanded_list=None):
    """
    Build org chart for a single root (MD or standalone GCB3).

    Fitting rule under each L5 (max_per_slide = 10):
      - First try: show ALL individuals (GCB3, GCB4, GCB5, GCB6) + one Open Positions box if present.
      - If overflow, compress:
        Case B: keep GCB3+GCB4 individuals, show counts for GCB5 and GCB6 + open box if present.
        Case C: show counts for GCB3, GCB4, GCB5, GCB6 + open box if present. Also create an expanded slide.
      - Special case: if an L5 has ONLY GCB5/6 and total (5/6 individuals + open box) ≤ limit, show individual 5/6 boxes.
      - Expanded slide shows:
        [Expanded list] header, all GCB3+GCB4 individuals, ONE combined GCB5+GCB6 count box, and one Open Positions box (if any).
    """

    # ---------- helpers ----------
    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() in {"unspecified", "#n/a"} else s

    def line_for_actual(row, mgr_id=None):
        name = clean(row.get("Employee Name", "")) if show_names else ""
        title = clean(row.get("Position Title", ""))
        gcb   = clean(row.get("GCB", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = f"GCB{gcb}" if gcb and gcb not in {"MD"} else (gcb if gcb == "MD" else "")
        line = header if not footer else f"{header}\n{footer}"
        # add counts
        if mgr_id is not None and not pd.isna(mgr_id):
            dr = direct_counts.get(mgr_id, 0)
            op = open_pos_counts.get(mgr_id, 0)
            if dr > 0: line += f"\n→ Direct Reports: {dr}"
            if op > 0: line += f"\n→ Open Positions: {op}"
        return line

    def add_text_slide(lines, title=None):
        slide = pres.Slides.Add(pres.Slides.Count+1, 12)  # ppLayoutBlank
        tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
        tr.Font.Size = 10
        tr.Text = (title + "\r") if title else ""
        tr.Text += "\r".join(lines)

    def count_box(label, count, tabs=2):
        return (("\t" * tabs) + f"{count} X {label}") if count > 0 else None

    def open_box(open_count, tabs=2):
        return (("\t" * tabs) + f"<Open Positions> X {open_count}") if open_count > 0 else None

    # ---------- root ----------
    root_df = df_actual[df_actual["Employee ID"] == root_id]
    if root_df.empty:
        return
    root_row  = root_df.iloc[0]
    root_name = clean(root_row.get("Employee Name", ""))
    root_line = line_for_actual(root_row, mgr_id=root_id)

    # ---------- L5 under root ----------
    l5_actuals = df_actual[df_actual["Functional Manager Employee ID"] == root_id]
    l5_opens   = df_open[df_open["Functional Manager Employee ID"] == root_id]
    l5_items = [("actual", r) for _, r in l5_actuals.iterrows()]
    l5_items += [("open", r) for _, r in l5_opens.iterrows()]

    # page L5s by max_per_slide
    for i in range(0, len(l5_items), max_per_slide):
        batch = l5_items[i:i+max_per_slide]
        main_lines = [root_line]
        expanded_payloads = []

        for kind, l5 in batch:
            if kind == "open":
                op_line = ("\t" + f"<Open Position> | {clean(l5.get('Position Title',''))}")
                main_lines.append(op_line)
                continue

            # L5 actual
            l5_id   = l5.get("Employee ID")
            l5_name = clean(l5.get("Employee Name", ""))
            l5_line = "\t" + line_for_actual(l5, mgr_id=l5_id)
            main_lines.append(l5_line)

            # ---------- L6 under this L5 ----------
            l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
            l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]

            gcb3_boxes, gcb4_boxes, gcb5_boxes, gcb6_boxes = [], [], [], []
            for _, rr in l6_actuals.iterrows():
                gcb = str(rr.get("GCB", "")).strip()
                line = "\t\t" + line_for_actual(rr, mgr_id=rr.get("Employee ID"))
                if gcb == "3": gcb3_boxes.append(line)
                elif gcb == "4": gcb4_boxes.append(line)
                elif gcb == "5": gcb5_boxes.append(line)
                elif gcb == "6": gcb6_boxes.append(line)
                else: gcb6_boxes.append(line)  # unknown → treat as 6

            n_open = len(l6_opens.index)
            open_count_box = open_box(n_open, tabs=2)
            open_box_count_flag = 1 if open_count_box else 0

            # ---------- special case: only 5/6 present and fits ----------
            if not gcb3_boxes and not gcb4_boxes:
                total_boxes_only_56 = len(gcb5_boxes) + len(gcb6_boxes) + open_box_count_flag
                if total_boxes_only_56 <= max_per_slide:
                    main_lines += gcb5_boxes + gcb6_boxes
                    if open_count_box: main_lines.append(open_count_box)
                    continue

            # ---------- Try full individuals first (only combine counts when needed) ----------
            total_full = len(gcb3_boxes) + len(gcb4_boxes) + len(gcb5_boxes) + len(gcb6_boxes) + open_box_count_flag
            if total_full <= max_per_slide:
                main_lines += gcb3_boxes + gcb4_boxes + gcb5_boxes + gcb6_boxes
                if open_count_box: main_lines.append(open_count_box)
                continue

            # ---------- Case B: compress 5/6 into counts, keep 3/4 individuals ----------
            caseB = list(gcb3_boxes) + list(gcb4_boxes)
            c5 = len(gcb5_boxes)
            c6 = len(gcb6_boxes)
            if c5 > 0: caseB.append(count_box("GCB5", c5))
            if c6 > 0: caseB.append(count_box("GCB6", c6))
            if open_count_box: caseB.append(open_count_box)
            if len([b for b in caseB if b]) <= max_per_slide:
                main_lines += [b for b in caseB if b]
                continue

            # ---------- Case C: compress 3/4 as counts too, and add expanded slide ----------
            caseC = []
            if len(gcb3_boxes) > 0: caseC.append(count_box("GCB3", len(gcb3_boxes)))
            if len(gcb4_boxes) > 0: caseC.append(count_box("GCB4", len(gcb4_boxes)))
            if c5 > 0: caseC.append(count_box("GCB5", c5))
            if c6 > 0: caseC.append(count_box("GCB6", c6))
            if open_count_box: caseC.append(open_count_box)
            main_lines += [b for b in caseC if b]

            # Prepare expanded slide payload for THIS L5
            combined_56 = c5 + c6
            expanded_lines = [
                root_line,
                "\t" + line_for_actual(l5, mgr_id=l5_id),
                "\t[Expanded list]"
            ]
            expanded_lines += gcb3_boxes + gcb4_boxes
            if combined_56 > 0:
                expanded_lines.append(count_box("GCB5+GCB6", combined_56))
            if open_count_box:
                expanded_lines.append(open_count_box)

            expanded_payloads.append({
                "title": f"Expanded for L5: {l5_name}",
                "lines": expanded_lines,
                "summary_tuple": (root_name, l5_id, l5_name)
            })

        # write main slide
        add_text_slide(main_lines, title=f"Org chart: {root_name}")
        # write expanded slides for ALL overflow L5s in this batch
        for payload in expanded_payloads:
            add_text_slide(payload["lines"], title=payload["title"])
            if expanded_list is not None:
                expanded_list.append(payload["summary_tuple"])
ñnnnnnnnnnnnnnnmmmmmmmm




import pandas as pd
import win32com.client

def export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              ppt_app,
                              pres,
                              max_per_slide=10,
                              show_names=True,
                              expanded_list=None):
    """
    Org chart for a single root (MD or standalone GCB3).
    """

    # ---------- helpers ----------
    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() in {"unspecified", "#n/a"} else s

    def line_for_actual(row, mgr_id=None):
        name = clean(row.get("Employee Name", "")) if show_names else ""
        title = clean(row.get("Position Title", ""))
        gcb   = clean(row.get("GCB", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = f"GCB{gcb}" if gcb and gcb not in {"MD"} else (gcb if gcb == "MD" else "")
        line = header if not footer else f"{header}\n{footer}"
        # add counts
        if mgr_id is not None and not pd.isna(mgr_id):
            if direct_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Direct Reports: {direct_counts[mgr_id]}"
            if open_pos_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Open Positions: {open_pos_counts[mgr_id]}"
        return line

    def add_text_slide(lines, title=None):
        slide = pres.Slides.Add(pres.Slides.Count+1, 12)  # blank layout
        tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
        tr.Font.Size = 10
        tr.Text = (title + "\r") if title else ""
        tr.Text += "\r".join(lines)

    def count_box(label, count, tabs=2):
        return (("\t" * tabs) + f"{count} X {label}") if count > 0 else None

    def open_box(open_count, tabs=2):
        return (("\t" * tabs) + f"<Open Positions> X {open_count}") if open_count > 0 else None

    # ---------- root ----------
    root_df = df_actual[df_actual["Employee ID"] == root_id]
    if root_df.empty:
        return
    root_row  = root_df.iloc[0]
    root_name = clean(root_row.get("Employee Name", ""))
    root_line = line_for_actual(root_row, mgr_id=root_id)

    # ---------- L5 under root ----------
    l5_actuals = df_actual[df_actual["Functional Manager Employee ID"] == root_id]
    l5_opens   = df_open[df_open["Functional Manager Employee ID"] == root_id]
    l5_items = [("actual", r) for _, r in l5_actuals.iterrows()]
    l5_items += [("open", r) for _, r in l5_opens.iterrows()]

    # page L5s by max_per_slide
    for i in range(0, len(l5_items), max_per_slide):
        batch = l5_items[i:i+max_per_slide]
        main_lines = [root_line]
        expanded_payloads = []

        for kind, l5 in batch:
            if kind == "open":
                op_line = ("\t" + f"<Open Position> | {clean(l5.get('Position Title',''))}")
                main_lines.append(op_line)
                continue

            # L5 actual
            l5_id   = l5.get("Employee ID")
            l5_name = clean(l5.get("Employee Name", ""))
            l5_line = "\t" + line_for_actual(l5, mgr_id=l5_id)
            main_lines.append(l5_line)

            # ---------- L6 under this L5 ----------
            l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
            l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]

            gcb3_boxes, gcb4_boxes, gcb5_boxes, gcb6_boxes = [], [], [], []
            for _, rr in l6_actuals.iterrows():
                gcb = str(rr.get("GCB", "")).strip()
                line = "\t\t" + line_for_actual(rr, mgr_id=rr.get("Employee ID"))
                if gcb == "3": gcb3_boxes.append(line)
                elif gcb == "4": gcb4_boxes.append(line)
                elif gcb == "5": gcb5_boxes.append(line)
                elif gcb == "6": gcb6_boxes.append(line)
                else: gcb6_boxes.append(line)

            n_open = len(l6_opens.index)
            open_count_box = open_box(n_open, tabs=2)

            # special case: only 5/6 present and fit
            if not gcb3_boxes and not gcb4_boxes:
                total_boxes_only_56 = len(gcb5_boxes) + len(gcb6_boxes) + (1 if open_count_box else 0)
                if total_boxes_only_56 <= max_per_slide:
                    main_lines += gcb5_boxes + gcb6_boxes
                    if open_count_box: main_lines.append(open_count_box)
                    continue

            # Case A
            caseA = gcb3_boxes + gcb4_boxes
            if gcb5_boxes: caseA.append(count_box("GCB5", len(gcb5_boxes)))
            if gcb6_boxes: caseA.append(count_box("GCB6", len(gcb6_boxes)))
            if open_count_box: caseA.append(open_count_box)
            if len([b for b in caseA if b]) <= max_per_slide:
                main_lines += [b for b in caseA if b]
                continue

            # Case B
            caseB = gcb3_boxes[:]
            if gcb4_boxes: caseB.append(count_box("GCB4", len(gcb4_boxes)))
            if gcb5_boxes: caseB.append(count_box("GCB5", len(gcb5_boxes)))
            if gcb6_boxes: caseB.append(count_box("GCB6", len(gcb6_boxes)))
            if open_count_box: caseB.append(open_count_box)
            if len([b for b in caseB if b]) <= max_per_slide:
                main_lines += [b for b in caseB if b]
                continue

            # Case C
            caseC = []
            if gcb3_boxes: caseC.append(count_box("GCB3", len(gcb3_boxes)))
            if gcb4_boxes: caseC.append(count_box("GCB4", len(gcb4_boxes)))
            if gcb5_boxes: caseC.append(count_box("GCB5", len(gcb5_boxes)))
            if gcb6_boxes: caseC.append(count_box("GCB6", len(gcb6_boxes)))
            if open_count_box: caseC.append(open_count_box)
            main_lines += [b for b in caseC if b]

            # Expanded slide payload
            expanded_lines = [
                root_line,
                "\t" + line_for_actual(l5, mgr_id=l5_id),
                "\t[Expanded list]"
            ]
            expanded_lines += gcb3_boxes + gcb4_boxes
            combined_56 = len(gcb5_boxes) + len(gcb6_boxes)
            if combined_56 > 0:
                expanded_lines.append(count_box("GCB5+GCB6", combined_56))
            if open_count_box:
                expanded_lines.append(open_count_box)

            expanded_payloads.append({
                "title": f"Expanded for L5: {l5_name}",
                "lines": expanded_lines,
                "summary_tuple": (root_name, l5_id, l5_name)
            })

        # write main slide
        add_text_slide(main_lines, title=f"Org chart: {root_name}")
        # write expanded slides for all overflow L5s
        for payload in expanded_payloads:
            add_text_slide(payload["lines"], title=payload["title"])
            if expanded_list is not None:
                expanded_list.append(payload["summary_tuple"])
----




-----
import win32com.client

# Prepare shared PowerPoint app + presentation
ppt_app = win32com.client.Dispatch("PowerPoint.Application")
ppt_app.Visible = True
pres = ppt_app.Presentations.Add()

# Build roots list (MDs + uncovered GCB3s) — adjust filters to your exact rules
mds = df_actual[df_actual["GCB"].astype(str).str.strip() == "MD"]["Employee ID"].dropna().tolist()
gcb3_all = df_actual[df_actual["GCB"].astype(str).str.strip() == "3"]
uncovered_gcb3_ids = gcb3_all[~gcb3_all["Functional Manager Employee ID"].isin(mds)]["Employee ID"].dropna().tolist()
roots = list(dict.fromkeys(mds + uncovered_gcb3_ids))  # de-dupe, preserve order

# Collect expanded cases across all roots
expanded_across_roots = []

# Generate charts
for root_id in roots:
    export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              ppt_app,
                              pres,
                              max_per_slide=10,
                              show_names=True,
                              expanded_list=expanded_across_roots)

# Final summary slide across all roots
if expanded_across_roots:
    slide = pres.Slides.Add(pres.Slides.Count+1, 12)
    tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
    tr.Font.Size = 12
    tr.Text = "Expanded L5 managers (final fallback applied):\r" + \
              "\r".join([f"- {l5_name} (ID: {l5_id}) under {root_name}"
                         for root_name, l5_id, l5_name in expanded_across_roots])

# Save once at the end — use a full, valid path
pres.SaveAs(r"C:\Users\Kirti\Documents\OrgCharts_All.pptx")
pres.Close()
////////////////////////////////////////


def export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              ppt_app,
                              pres,
                              max_per_slide=10,
                              show_names=True,
                              expanded_list=None):
    """
    Generate org chart for a single root (MD or standalone GCB3).
    Progressive compression at L6:
      A) ≤ max_per_slide: show all
      B) > max_per_slide: collapse GCB5+6 counts
      C) > max_per_slide: collapse GCB4+5+6 counts
      D) > max_per_slide: collapse all 3/4/5/6 counts, mark 'Expanded' and add expanded slide
    Always keep open positions as boxes.
    expanded_list: list to collect overflow cases for summary slide.
    """

    import pandas as pd

    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() in {"unspecified", "#n/a"} else s

    def line_for_actual(row, mgr_id=None, level=0):
        name = clean(row.get("Employee Name", "")) if show_names else ""
        title = clean(row.get("Position Title", ""))
        gcb   = clean(row.get("GCB", ""))
        country = clean(row.get("Country R3", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = " | ".join([p for p in [gcb, country] if p])
        line = f"{header}\n{footer}" if footer else header
        return line

    def line_for_open(op_row, level=0):
        title = clean(op_row.get("Position Title", ""))
        if not title: return None
        header = f"<Open Position> | {title}"
        return ("\t"*level) + header

    def gcb_rank(val):
        val = str(val).strip()
        if val == "MD": return 1
        if val == "3": return 2
        if val == "4": return 3
        if val == "5": return 4
        if val == "6": return 5
        return 99

    root_df = df_actual[df_actual["Employee ID"] == root_id]
    if root_df.empty:
        return
    root_row = root_df.iloc[0]
    root_line = line_for_actual(root_row, root_id, level=4)

    child_actuals = df_actual[df_actual["Functional Manager Employee ID"] == root_id]
    child_opens   = df_open[df_open["Functional Manager Employee ID"] == root_id]
    child_items = [("actual", r) for _, r in child_actuals.iterrows()]
    child_items += [("open", r) for _, r in child_opens.iterrows()]

    def write_slide(lines, title=None):
        slide = pres.Slides.Add(pres.Slides.Count+1, 12)
        tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
        tr.Font.Size = 9
        tr.Text = (title + "\r") if title else ""
        tr.Text += "\r".join(lines)

    def create_expanded_slide(l5_row, gc_actuals, gc_opens):
        l5_id = l5_row.get("Employee ID")
        l5_line = "\t" + line_for_actual(l5_row, l5_id, level=5)
        lines_exp = [root_line, l5_line]
        gc_items = [("actual", rr) for _, rr in gc_actuals.iterrows()]
        gc_items += [("open", rr) for _, rr in gc_opens.iterrows()]
        gc_items.sort(key=lambda tup: gcb_rank(tup[1].get("GCB", "")))
        for kind2, gc in gc_items:
            if kind2 == "actual":
                gid = gc.get("Employee ID")
                lines_exp.append("\t\t" + line_for_actual(gc, gid, level=6))
            else:
                op_line = line_for_open(gc, level=2)
                if op_line: lines_exp.append(op_line)
        write_slide(lines_exp, title="Expanded L5 details")

    # --- Batch children ---
    for i in range(0, len(child_items), max_per_slide):
        batch = child_items[i:i+max_per_slide]
        lines = [root_line]

        for kind, child in batch:
            if kind == "actual":
                cid = child.get("Employee ID")
                child_line = "\t" + line_for_actual(child, cid, level=5)
                lines.append(child_line)

                gc_actuals = df_actual[df_actual["Functional Manager Employee ID"] == cid]
                gc_opens   = df_open[df_open["Functional Manager Employee ID"] == cid]
                gc_items = [("actual", rr) for _, rr in gc_actuals.iterrows()]
                gc_items += [("open", rr) for _, rr in gc_opens.iterrows()]
                gc_items.sort(key=lambda tup: gcb_rank(tup[1].get("GCB", "")))

                if len(gc_items) <= max_per_slide:
                    for kind2, gc in gc_items:
                        if kind2 == "actual":
                            gid = gc.get("Employee ID")
                            lines.append("\t\t" + line_for_actual(gc, gid, level=6))
                        else:
                            op_line = line_for_open(gc, level=2)
                            if op_line: lines.append(op_line)
                else:
                    details = []
                    open_boxes = []
                    gcb_counts = {"3":0,"4":0,"5":0,"6":0}
                    for kind2, gc in gc_items:
                        gcb_val = str(gc.get("GCB", "")).strip()
                        if kind2 == "open":
                            op_line = line_for_open(gc, level=2)
                            if op_line: open_boxes.append(op_line)
                        else:
                            if gcb_val == "3":
                                details.append("\t\t" + line_for_actual(gc, gc.get("Employee ID"), level=6))
                            elif gcb_val in ["4","5","6"]:
                                gcb_counts[gcb_val] += 1

                    count_lines = []
                    new_total = len(details) + len(open_boxes) + sum(gcb_counts.values())

                    if new_total > max_per_slide:
                        # Case B: collapse 5+6
                        if gcb_counts["5"]>0: count_lines.append(f"\t\t{gcb_counts['5']} X GCB5")
                        if gcb_counts["6"]>0: count_lines.append(f"\t\t{gcb_counts['6']} X GCB6")
                        new_total = len(details)+len(open_boxes)+len(count_lines)

                        if new_total > max_per_slide:
                            # Case C: collapse 4+5+6
                            if gcb_counts["4"]>0: count_lines.append(f"\t\t{gcb_counts['4']} X GCB4")
                            new_total = len(details)+len(open_boxes)+len(count_lines)

                            if new_total > max_per_slide:
                                # Case D: collapse all
                                count_lines = []
                                for lvl in ["3","4","5","6"]:
                                    if gcb_counts[lvl]>0:
                                        count_lines.append(f"\t\t{gcb_counts[lvl]} X GCB{lvl}")
                                if expanded_list is not None:
                                    expanded_list.append((clean(root_row.get("Employee Name","")),
                                                          clean(child.get("Employee ID")),
                                                          clean(child.get("Employee Name",""))))
                                # Write compressed slide first
                                for d in details: lines.append(d)
                                for op in open_boxes: lines.append(op)
                                if count_lines: lines.append("\n".join(count_lines))
                                write_slide(lines)
                                # Then expanded slide
                                create_expanded_slide(child, gc_actuals, gc_opens)
                                continue

                    for d in details: lines.append(d)
                    for op in open_boxes: lines.append(op)
                    if count_lines: lines.append("\n".join(count_lines))

            else:
                op_line = line_for_open(child, level=1)
                if op_line: lines.append(op_line)

        write_slide(lines)


import win32com.client

ppt_app = win32com.client.Dispatch("PowerPoint.Application")
ppt_app.Visible = True
pres = ppt_app.Presentations.Add()

expanded_across_roots = []

for root_id in roots:   # roots = MDs + uncovered GCB3 IDs
    export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,


--------


=====
def export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              excel_path=None,
                              ppt_path=None,
                              ppt_app=None,
                              pres=None,
                              max_per_slide=10,
                              show_names=True,
                              expanded_list=None):
    """
    Generate org chart for a single root (MD or standalone GCB3).

    Progressive L6 compression:
      A) ≤ max_per_slide: show all
      B) > max_per_slide: collapse GCB5+6 counts (keep MD/3/4 details + opens)
      C) > max_per_slide: collapse GCB4+5+6 counts (keep GCB3 details + opens)
      D) > max_per_slide: collapse all 3/4/5/6 counts (single box) + opens, mark 'Expanded' and add expanded slide

    Always keep open positions as boxes.

    expanded_list (optional): list to collect tuples for summary across roots:
      (root_name, l5_id, l5_name)
    """

    import os
    import pandas as pd
    import win32com.client
    from openpyxl import Workbook

    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() in {"unspecified", "#n/a"} else s

    def line_for_actual(row, mgr_id=None, level=0):
        name = clean(row.get("Employee Name", "")) if show_names else ""
        title = clean(row.get("Position Title", ""))
        gcb   = clean(row.get("GCB", ""))
        country = clean(row.get("Country R3", ""))
        header = " | ".join([p for p in [name, title] if p])
        footer = " | ".join([p for p in [gcb, country] if p])
        line = f"{header}\n{footer}" if footer else header
        has_mgr = (mgr_id is not None) and (not pd.isna(mgr_id))
        if level >= 5 and has_mgr:
            if open_pos_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Open Positions: {open_pos_counts[mgr_id]}"
            if direct_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Direct Reports: {direct_counts[mgr_id]}"
        return line

    def line_for_open(op_row, level=0):
        title = clean(op_row.get("Position Title", ""))
        if not title: return None
        pid = op_row.get("PID")
        gcb, country = "", ""
        match = df_actual[df_actual["PID"] == pid]
        if not match.empty:
            gcb = clean(match.iloc[0].get("GCB", ""))
            country = clean(match.iloc[0].get("Country R3", ""))
        header = f"<Open Position> | {title}"
        footer = " | ".join([p for p in [gcb, country] if p])
        line = f"{header}\n{footer}" if footer else header
        return ("\t"*level) + line

    def gcb_rank(val):
        val = str(val).strip()
        if val == "MD": return 1
        if val == "3": return 2
        if val == "4": return 3
        if val == "5": return 4
        if val == "6": return 5
        return 99

    # Root row
    root_df = df_actual[df_actual["Employee ID"] == root_id]
    if root_df.empty:
        return  # skip if not found
    root_row = root_df.iloc[0]
    root_gcb = str(root_row.get("GCB", "")).strip()

    if root_gcb == "MD":
        root_line = line_for_actual(root_row, root_id, level=4)
    elif root_gcb == "3":
        root_line = line_for_actual(root_row, root_id, level=3)
    else:
        root_line = line_for_actual(root_row, root_id, level=4)

    # Children under root (L5 actual and open)
    child_actuals = df_actual[df_actual["Functional Manager Employee ID"] == root_id]
    child_opens   = df_open[df_open["Functional Manager Employee ID"] == root_id]
    child_items = [("actual", r) for _, r in child_actuals.iterrows()]
    child_items += [("open", r) for _, r in child_opens.iterrows()]

    # Excel + PPT setup
    wb = Workbook()
    ws = wb.active
    ws.title = "Slide_1"
    slide_idx = 1

    if pres is None:
        ppt = ppt_app or win32com.client.Dispatch("PowerPoint.Application")
        ppt.Visible = True
        pres_local = ppt.Presentations.Add()
    else:
        pres_local = pres

    def write_slide(lines, title=None):
        nonlocal slide_idx
        if slide_idx == 1 and wb.active.title == "Slide_1" and wb.active.max_row == 1:
            ws = wb.active
            ws.delete_rows(1, ws.max_row)
        else:
            ws = wb.create_sheet(title=f"Slide_{slide_idx}")
        ws.append(["Hierarchy"])
        for ln in lines:
            ws.append([ln])
        slide = pres_local.Slides.Add(pres_local.Slides.Count+1, 12)  # ppLayoutBlank
        tr = slide.Shapes.AddTextbox(1, 50, 50, 800, 500).TextFrame.TextRange
        tr.Font.Size = 9
        tr.Text = (title + "\r") if title else ""
        tr.Text += "\r".join(lines)
        slide_idx += 1

    def create_expanded_slide(root_row, l5_row, gc_actuals, gc_opens):
        """Create a separate expanded slide showing all L6 (actual+open) under the L5."""
        root_line_exp = line_for_actual(root_row, root_row.get("Employee ID"), level=4)
        l5_id = l5_row.get("Employee ID")
        l5_line_exp = "\t" + line_for_actual(l5_row, l5_id, level=5)
        lines_exp = [root_line_exp, l5_line_exp, "\t[Expanded details]"]

        gc_items = [("actual", rr) for _, rr in gc_actuals.iterrows()]
        gc_items += [("open", rr) for _, rr in gc_opens.iterrows()]
        gc_items.sort(key=lambda tup: gcb_rank(tup[1].get("GCB", "")))

        for kind2, gc in gc_items:
            if kind2 == "actual":
                gid = gc.get("Employee ID")
                gid = None if pd.isna(gid) else gid
                lines_exp.append("\t\t" + line_for_actual(gc, gid, level=6))
            else:
                op_line = line_for_open(gc, level=2)
                if op_line: lines_exp.append(op_line)

        write_slide(lines_exp, title="Expanded L5 details")

    # --- Batch L5 children across slides ---
    for i in range(0, len(child_items), max_per_slide):
        batch = child_items[i:i+max_per_slide]
        lines = [root_line]

        for kind, child in batch:
            if kind == "actual":
                cid = child.get("Employee ID")
                cid = None if pd.isna(cid) else cid
                child_line = "\t" + line_for_actual(child, cid, level=5)
                lines.append(child_line)

                # L6 under this L5
                gc_actuals = df_actual[df_actual["Functional Manager Employee ID"] == cid]
                gc_opens   = df_open[df_open["Functional Manager Employee ID"] == cid]
                gc_items = [("actual", rr) for _, rr in gc_actuals.iterrows()]
                gc_items += [("open", rr) for _, rr in gc_opens.iterrows()]
                gc_items.sort(key=lambda tup: gcb_rank(tup[1].get("GCB", "")))

                if len(gc_items) <= max_per_slide:
                    # Case A: show all
                    for kind2, gc in gc_items:
                        if kind2 == "actual":
                            gid = gc.get("Employee ID")
                            gid = None if pd.isna(gid) else gid
                            lines.append("\t\t" + line_for_actual(gc, gid, level=6))
                        else:
                            op_line = line_for_open(gc, level=2)
                            if op_line: lines.append(op_line)
                else:
                    # Cases B/C/D: progressive compression
                    details = []      # MD, GCB3, GCB4 individuals
                    open_boxes = []   # open positions
                    gcb_counts = {"3": 0, "4": 0, "5": 0, "6": 0}

                    for kind2, gc in gc_items:
                        gcb_val = str(gc.get("GCB", "")).strip()
                        if kind2 == "open":
                            op_line = line_for_open(gc, level=2)
                            if op_line: open_boxes.append(op_line)
                        else:
                            if gcb_val in ["MD", "3", "4"]:
                                gid = gc.get("Employee ID")
                                gid = None if pd.isna(gid) else gid
                                details.append("\t\t" + line_for_actual(gc, gid, level=6))
                            elif gcb_val in ["5", "6"]:
                                gcb_counts[gcb_val] += 1
                            else:
                                gcb_counts["6"] += 1  # unknown → treat as 6

                    # Start with raw totals (details + opens + individual 5/6 entries)
                    count_lines = []
                    new_total = len(details) + len(open_boxes) + sum(gcb_counts.values())

                    if new_total > max_per_slide:
                        # Step B: collapse 5+6 into counts (keep MD/3/4 details + opens)
                        count_lines = []
                        if gcb_counts["5"] > 0:
                            count_lines.append(f"\t\t{gcb_counts['5']} X GCB5")
                        if gcb_counts["6"] > 0:
                            count_lines.append(f"\t\t{gcb_counts['6']} X GCB6")
                        new_total = len(details) + len(open_boxes) + len(count_lines)

                        if new_total > max_per_slide:
                            # Step C: collapse 4+5+6 into counts (keep only GCB3 details + opens)
                            # Drop GCB4 details from 'details'
                            keep_details = []
                            for d in details:
                                # Heuristic: if line footer contains GCB4, drop it
                                # We rely on '\n' footer formatting; safer: check the row, but we only have strings here.
                                if " GCB4" in d or " GCBMD" in d:
                                    continue
                                keep_details.append(d)
                            details = keep_details

                            count_lines = []
                            if gcb_counts["4"] > 0:
                                count_lines.append(f"\t\t{gcb_counts['4']} X GCB4")
                            if gcb_counts["5"] > 0:
                                count_lines.append(f"\t\t{gcb_counts['5']} X GCB5")
                            if gcb_counts["6"] > 0:
                                count_lines.append(f"\t\t{gcb_counts['6']} X GCB6")
                            new_total = len(details) + len(open_boxes) + len(count_lines)

                            if new_total > max_per_slide:
                                # Step D: collapse all 3/4/5/6 into one combined count box + opens, mark expanded
                                total_counts = gcb_counts["3"] + gcb_counts["4"] + gcb_counts["5"] + gcb_counts["6"]
                                details = []  # drop all individual L6
                                count_lines = [f"\t\t{total_counts} X GCB3+4+5+6\n\t\t[Expanded]"]

                                # Track expanded for summary and create expanded slide
                                if expanded_list is not None:
                                    expanded_list.append((
                                        clean(root_row.get("Employee Name", "")),
                                        clean(child.get("Employee ID")),
                                        clean(child.get("Employee Name", ""))
                                    ))
                                create_expanded_slide(root_row, child, gc_actuals, gc_opens)

                    # Append after compression (always)
                    for d in details:
                        lines.append(d)
                    for op in open_boxes:
                        lines.append(op)
                    if count_lines:
                        # Keep counts grouped in one "box" string
                        lines.append("\n".join(count_lines))

            else:
                # L5 open under root
                op_line = line_for_open(child, level=1)
                if op_line: lines.append(op_line)

        # Write the slide for this batch of L5s
        write_slide(lines)

    # Save outputs once per root function call
    final_excel_path = excel_path or os.path.join(os.getcwd(), f"Indented_{root_id}.xlsx")
    wb.save(final_excel_path)

    if pres is None and ppt_path:
        pres_local.SaveAs(ppt_path)
        pres_local.Close()

## main
expanded_across_roots = []

# pres/ppt_app you control externally so all roots go into one PPT, or pass None to create per-root PPTs
pres = None
ppt_app = None
ppt_path = r"C:\path\to\OrgCharts_All.pptx"  # if you want one file per function call with pres=None

for root_id in roots:  # roots = MDs + uncovered GCB3 IDs
    export_indented_text_full(root_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              excel_path=None,      # or path per root
                              ppt_path=ppt_path,    # saved once per call when pres is None
                              ppt_app=ppt_app,
                              pres=pres,            # pass a shared pres if you want one PPT across all roots
                              max_per_slide=10,
                              show_names=True,
                              expanded_list=expanded_across_roots)

# If you want a single summary slide across all roots, add it after your loop using the shared pres
# (if you passed a shared pres object). If you used pres=None, each call saved/closed its own PPT.

...........................................................................................................................


import tkinter as tk
from tkinter import ttk

def selectbfg_filter(df_input):
    root = tk.Tk()
    root.title("Select BFG and Options")

    # --- BFG selection ---
    tk.Label(root, text="Select BFG:").grid(row=0, column=0, padx=10, pady=5, sticky="w")
    bfg_values = sorted(df_input["BFG"].dropna().unique().tolist())
    bfg_combo = ttk.Combobox(root, values=bfg_values, state="readonly")
    bfg_combo.grid(row=0, column=1, padx=10, pady=5)

    # --- Show names option ---
    tk.Label(root, text="Show Employee Names in Org Chart?").grid(row=1, column=0, padx=10, pady=5, sticky="w")
    name_combo = ttk.Combobox(root, values=["Yes", "No"], state="readonly")
    name_combo.grid(row=1, column=1, padx=10, pady=5)
    name_combo.current(0)  # default Yes

    # --- Month selection ---
    tk.Label(root, text="Select Current Month:").grid(row=2, column=0, padx=10, pady=5, sticky="w")
    months = ["January","February","March","April","May","June",
              "July","August","September","October","November","December"]
    month_combo = ttk.Combobox(root, values=months, state="readonly")
    month_combo.grid(row=2, column=1, padx=10, pady=5)

    # --- Year selection ---
    tk.Label(root, text="Select Current Year:").grid(row=3, column=0, padx=10, pady=5, sticky="w")
    years = [str(y) for y in range(2020, 2031)]  # adjust range as needed
    year_combo = ttk.Combobox(root, values=years, state="readonly")
    year_combo.grid(row=3, column=1, padx=10, pady=5)

    # --- Submit button ---
    def submit():
        root.selected_bfg = bfg_combo.get()
        root.show_names = (name_combo.get().lower() == "yes")
        root.selected_month = month_combo.get()
        root.selected_year = year_combo.get()
        root.destroy()

    tk.Button(root, text="Submit", command=submit).grid(row=4, column=0, columnspan=2, pady=10)

    root.mainloop()

    return root.selected_bfg, root.show_names, root.selected_month, root.selected_year



def initialize_counts(df_final, bfg_filter):
    """
    Capture initial counts of GCB3, GCB4, GCB5 employees
    when user selects a BFG level.
    """
    df_bfg = df_final[df_final["BFG"] == bfg_filter]
    counts = {
        "GCB3": len(df_bfg[df_bfg["GCB"] == "GCB3"]),
        "GCB4": len(df_bfg[df_bfg["GCB"] == "GCB4"]),
        "GCB5": len(df_bfg[df_bfg["GCB"] == "GCB5"]),
    }
    return counts


def update_coverage(covered_counts, emp_gcb):
    """
    Increment covered count for an employee’s GCB level.
    """
    if emp_gcb in covered_counts:
        covered_counts[emp_gcb] += 1


def export_summary(initial_counts, covered_counts, output_path="Coverage_Summary.xlsx", bfg_level="Selected BFG"):
    """
    Save summary into Excel with Analpan, Covered, Uncovered counts.
    """
    from openpyxl import Workbook
    wb = Workbook()
    ws = wb.active
    ws.title = "Coverage Summary"

    ws.append([bfg_level])
    ws.append(["GCB", "Analpan Count", "Org Chart Count Covered", "Org Chart Uncovered count"])

    for gcb in ["GCB3", "GCB4", "GCB5"]:
        initial = initial_counts.get(gcb, 0)
        covered = covered_counts.get(gcb, 0)
        uncovered = initial - covered
        ws.append([gcb, initial, covered, uncovered])

    wb.save(output_path)
    print(f"✅ Coverage summary saved to {output_path}")

---
# Step 1: When user selects BFG level
initial_counts = initialize_counts(df_final, selected_bfg)
covered_counts = {"GCB3": 0, "GCB4": 0, "GCB5": 0}

# Step 2: During org chart generation
for emp_id in employees_in_chart:
    emp_gcb = df_final.loc[df_final["Employee ID"] == emp_id, "GCB"].values[0]
    update_coverage(covered_counts, emp_gcb)

# Step 3: After all charts are generated
export_summary(initial_counts, covered_counts,
               output_path=os.path.join(output_dir, "Coverage_Summary.xlsx"),
               bfg_level=selected_bfg)

=========================================

import pandas as pd
import pandas as pd

def update_base_with_amendments(base_df_updated: pd.DataFrame, amend_df: pd.DataFrame, suffix: str) -> pd.DataFrame:
    """
    Update base_df_updated with values from amend_df based on PSID lookup.

    Rules:
    1. For rows where DEP_CODE/PS_HR_ID_<suffix> == '#N/A':
       - Lookup PSID in amend_df['EMPLOYEE_ID'].
       - If found, update DEP_CODE/PS_HR_ID_<suffix>, AID (Billed)<suffix>, EXCLUDED<suffix>, EXCLUDED_REASON<suffix>.
         Also set Observations_<suffix> = "To Check- Data correction -Amendments".
       - If not found, leave those data columns untouched, but set Observations_<suffix> = "To Check - Resource left".
    2. Wherever EXCLUDED_<suffix> == 0, set EXCLUDED_REASON_<suffix> = 0.
    3. Row count is preserved.
    """

    # Normalize keys
    base_df_updated['PSID'] = base_df_updated['PSID'].astype(str).str.strip()
    amend_df['EMPLOYEE_ID'] = amend_df['EMPLOYEE_ID'].astype(str).str.strip()

    # Dynamic columns
    dep_col = f"DEP_CODE/PS_HR_ID{suffix}"
    obs_col = f"Observations{suffix}"
    excluded_col = f"EXCLUDED{suffix}"
    excluded_reason_col = f"EXCLUDED_REASON{suffix}"
    aid_col = f"AID (Billed){suffix}"

    # Mask rows needing amendment
    mask_na = (
        base_df_updated[dep_col].astype(str).str.strip().isin(["#N/A", "NaN"]) |
        base_df_updated[dep_col].isna()
    )

    # Subset with original indices
    subset = base_df_updated.loc[mask_na].copy()
    subset['__orig_index__'] = subset.index

    # Merge with amendments
    merged = subset.merge(
        amend_df[['EMPLOYEE_ID','DEP_CODE/PS_HR_ID','AID (Billed)','EXCLUDED','EXCLUDED_REASON']],
        left_on='PSID',
        right_on='EMPLOYEE_ID',
        how='left'
    )

    # Iterate row by row to update both data and observations together
    for _, row in merged.iterrows():
        idx = row['__orig_index__']
        if pd.notna(row['EMPLOYEE_ID']):
            # Found a match → update all relevant cols
            base_df_updated.at[idx, dep_col] = row['DEP_CODE/PS_HR_ID']
            base_df_updated.at[idx, aid_col] = row['AID (Billed)']
            base_df_updated.at[idx, excluded_col] = row['EXCLUDED']
            base_df_updated.at[idx, excluded_reason_col] = row['EXCLUDED_REASON']
            base_df_updated.at[idx, obs_col] = "To Check- Data correction -Amendments"
        else:
            # No match → only update observations
            base_df_updated.at[idx, obs_col] = "To Check - Resource left"

    # Fix EXCLUDED_REASON when EXCLUDED == 0
    mask_excluded_zero = base_df_updated[excluded_col] == 0
    base_df_updated.loc[mask_excluded_zero, excluded_reason_col] = 0

    return base_df_updated

-------------------
import pandas as pd

def update_base_with_amendments(base_df_updated: pd.DataFrame, amend_df: pd.DataFrame, suffix: str) -> pd.DataFrame:
    """
    Update base_df_updated with values from amend_df based on PSID lookup.
    
    Rules:
    1. For rows where DEP_CODE/PS_HR_ID_<suffix> == '#N/A':
       - Lookup PSID in amend_df['EMPLOYEE_ID'].
       - If found, update DEP_CODE/PS_HR_ID_<suffix>, AID (Billed)<suffix>, EXCLUDED<suffix>, EXCLUDED_REASON<suffix>.
       - Set Observations_<suffix> = "To Check- Data correction -Amendments".
       - If not found, only set Observations_<suffix> = "To Check - Resource left".
    2. Wherever EXCLUDED_<suffix> == 0, set EXCLUDED_REASON_<suffix> = 0 (replace '#N/A' with 0).
    3. Row count is preserved (no increase).
    """

    # Normalize key columns for matching
    base_df_updated['PSID'] = base_df_updated['PSID'].astype(str).str.strip()
    amend_df['EMPLOYEE_ID'] = amend_df['EMPLOYEE_ID'].astype(str).str.strip()

    # Build dynamic column names
    dep_col = f"DEP_CODE/PS_HR_ID{suffix}"
    obs_col = f"Observations{suffix}"
    excluded_col = f"EXCLUDED{suffix}"
    excluded_reason_col = f"EXCLUDED_REASON{suffix}"
    aid_col = f"AID (Billed){suffix}"

    # Mask rows with '#N/A' in DEP_CODE/PS_HR_ID
    mask_na = base_df_updated[dep_col] == "#N/A"

    # Merge only those rows with amend_df
    merged = base_df_updated.loc[mask_na].merge(
        amend_df[['EMPLOYEE_ID','DEP_CODE/PS_HR_ID','AID (Billed)','EXCLUDED','EXCLUDED_REASON']],
        left_on='PSID',
        right_on='EMPLOYEE_ID',
        how='left'
    )

    # Update values for matched rows
    for col in ['DEP_CODE/PS_HR_ID','AID (Billed)','EXCLUDED','EXCLUDED_REASON']:
        base_df_updated.loc[mask_na, f"{col}{suffix}"] = merged[col].values

    # Update Observations column
    base_df_updated.loc[mask_na & merged['EMPLOYEE_ID'].notna(), obs_col] = "To Check- Data correction -Amendments"
    base_df_updated.loc[mask_na & merged['EMPLOYEE_ID'].isna(), obs_col] = "To Check - Resource left"

    # Fix EXCLUDED_REASON when EXCLUDED == 0
    mask_excluded_zero = base_df_updated[excluded_col] == 0
    base_df_updated.loc[mask_excluded_zero, excluded_reason_col] = 0

    return base_df_updated





# -----------------------------
# Step 6: PowerPoint generation (actuals + open positions, with counts at L6)
# -----------------------------
import win32com.client
import pandas as pd

def draw_orgchart(level4_id, df_actual, df_open, direct_counts, open_pos_counts, ppt_path="OrgChart_Output.pptx"):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()

    # Box sizes
    L4_W,L4_H = 320,110
    L5_W,L5_H = 280,100
    L6_W,L6_H = 240,90
    TOP_MARGIN = 30
    L5_TOP = 180
    L6_TOP_BASE = 320
    COL_GAP = 50
    ROW_GAP = 20

    # --- Helpers ---
    def add_box(slide,left,top,w,h,text):
        shape = slide.Shapes.AddShape(1,left,top,w,h)
        shape.TextFrame.TextRange.Text = text
        shape.TextFrame.TextRange.ParagraphFormat.Alignment = 1
        return shape

    def connect(slide,parent,child):
        conn = slide.Shapes.AddConnector(1,0,0,0,0)
        conn.ConnectorFormat.BeginConnect(parent,3)
        conn.ConnectorFormat.EndConnect(child,1)

    def place_row(sw,n,box_w):
        total_w = n*box_w+(n-1)*COL_GAP
        start_left = max(20,(sw-total_w)/2)
        return [start_left+i*(box_w+COL_GAP) for i in range(n)]

    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower()=="unspecified" else s

    def box_text_actual(emp_id, level=None):
        row = df_actual[df_actual["Employee ID"]==emp_id].iloc[0]
        name = clean(row["Employee Name"])
        title = clean(row["Position Title"])
        gcb = clean(row["GCB"])
        country = clean(row["Country R3"])
        header = "\n".join([p for p in [name,title] if p])
        footer = " | ".join([p for p in [gcb,country] if p])
        text = f"{header}\n{footer}" if footer else header
        # At L6, append counts
        if level==6:
            if open_pos_counts.get(emp_id,0)>0:
                text += f"\n→ Open Positions: {open_pos_counts[emp_id]}"
            if direct_counts.get(emp_id,0)>0:
                text += f"\n→ Direct Reports: {direct_counts[emp_id]}"
        return text

    def box_text_open(op_row):
        title = clean(op_row.get("Position Title",""))
        if not title: return None
        pid = op_row.get("PID")
        gcb, country = "", ""
        match = df_actual[df_actual["PID"]==pid]
        if not match.empty:
            gcb = clean(match.iloc[0].get("GCB",""))
            country = clean(match.iloc[0].get("Country R3",""))
        header = f"<Open Position>\n{title}"
        footer = " | ".join([p for p in [gcb,country] if p])
        return f"{header}\n{footer}" if footer else header

    def get_direct_reports(manager_id):
        actuals = df_actual[df_actual["Functional Manager Employee ID"] == manager_id]
        opens   = df_open[df_open["Functional Manager Employee ID"] == manager_id]
        return actuals, opens

    # --- Slide builder ---
    def add_l4_slide(l4_id,l5_rows):
        slide = pres.Slides.Add(pres.Slides.Count+1,12)
        sw = pres.PageSetup.SlideWidth

        # L4 box
        l4_left = (sw-L4_W)/2
        l4_box = add_box(slide,l4_left,TOP_MARGIN,L4_W,L4_H,box_text_actual(l4_id, level=4))

        # Place L5 boxes
        l5_positions = place_row(sw,len(l5_rows),L5_W)
        for i,l5_row in enumerate(l5_rows):
            l5_id = l5_row["Employee ID"]
            if pd.isna(l5_id): continue
            left = l5_positions[i]
            l5_box = add_box(slide,left,L5_TOP,L5_W,L5_H,box_text_actual(l5_id, level=5))
            connect(slide,l4_box,l5_box)

            # Get L6 direct reports (actual + open)
            actuals, opens = get_direct_reports(l5_id)
            l6_rows = [row for _,row in actuals.iterrows() if pd.notna(row["Employee ID"])]
            open_rows = [row for _,row in opens.iterrows()]

            # Draw actual L6 employees (with counts inside their box, no expansion)
            for j,l6_row in enumerate(l6_rows):
                l6_id = l6_row["Employee ID"]
                l6_left = left+(L5_W-L6_W)/2
                l6_top = L6_TOP_BASE+j*(L6_H+ROW_GAP)
                l6_box = add_box(slide,l6_left,l6_top,L6_W,L6_H,box_text_actual(l6_id, level=6))
                connect(slide,l5_box,l6_box)

            # Draw open positions under L5
            for k,op_row in enumerate(open_rows):
                op_text = box_text_open(op_row)
                if not op_text: continue
                l6_left = left+(L5_W-L6_W)/2
                l6_top = L6_TOP_BASE+(len(l6_rows)+k)*(L6_H+ROW_GAP)
                l6_box = add_box(slide,l6_left,l6_top,L6_W,L6_H,op_text)
                connect(slide,l5_box,l6_box)

    # --- Build chart starting from L4 ---
    l5_reports, _ = get_direct_reports(level4_id)
    l5_rows = [row for _,row in l5_reports.iterrows() if pd.notna(row["Employee ID"])]
    add_l4_slide(level4_id,l5_rows)

    # Save presentation
    pres.SaveAs(ppt_path)
    print(f"Org chart saved to {ppt_path}")

..................

def export_indented_text_full(level4_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              excel_path="OrgChart_Indented.xlsx",
                              ppt_path="OrgChart_Indented.pptx"):
    """
    Export indented hierarchy lines with employees + open positions.
    - L4/L5: list all direct reports explicitly.
    - L6: show counts only (Direct Reports, Open Positions).
    - Skip open positions if Position Title missing/blank/Unspecified.
    """

    def clean(x):
        if pd.isna(x): return ""
        s = str(x).strip()
        return "" if s.lower() == "unspecified" else s

    def line_for_actual(row, mgr_id=None, level=0):
        name = clean(row.get("Employee Name",""))
        title = clean(row.get("Position Title",""))
        gcb   = clean(row.get("GCB",""))
        country = clean(row.get("Country R3",""))
        header = " | ".join([p for p in [name,title] if p])
        footer = " | ".join([p for p in [gcb,country] if p])
        line = f"{header}\n{footer}" if footer else header

        # At L6, append counts instead of expanding further
        if level == 6 and mgr_id:
            if open_pos_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Open Positions: {open_pos_counts[mgr_id]}"
            if direct_counts.get(mgr_id, 0) > 0:
                line += f"\n→ Direct Reports: {direct_counts[mgr_id]}"
        return line

    def line_for_open(op_row):
        title = clean(op_row.get("Position Title",""))
        if not title: return None
        pid = op_row.get("PID")
        gcb, country = "", ""
        match = df_actual[df_actual["PID"] == pid]
        if not match.empty:
            gcb = clean(match.iloc[0].get("GCB",""))
            country = clean(match.iloc[0].get("Country R3",""))
        header = f"<Open Position> | {title}"
        footer = " | ".join([p for p in [gcb,country] if p])
        return f"{header}\n{footer}" if footer else header

    lines = []

    # --- L4 manager ---
    mgr_row = df_actual[df_actual["Employee ID"] == level4_id].iloc[0]
    lines.append(line_for_actual(mgr_row, level4_id, level=4))

    # --- L5 reports ---
    l5_actuals = df_actual[df_actual["Functional Manager Employee ID"] == level4_id]
    l5_opens   = df_open[df_open["Functional Manager Employee ID"] == level4_id]

    for _, l5 in l5_actuals.iterrows():
        l5_id = l5.get("Employee ID")
        if pd.isna(l5_id): continue
        lines.append(f"\t{line_for_actual(l5, l5_id, level=5)}")

        # --- L6 reports ---
        l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
        l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]

        for _, l6 in l6_actuals.iterrows():
            l6_id = l6.get("Employee ID")
            if pd.isna(l6_id): continue
            # At L6, show counts instead of expanding
            lines.append(f"\t\t{line_for_actual(l6, l6_id, level=6)}")

        for _, op in l6_opens.iterrows():
            op_line = line_for_open(op)
            if op_line:
                lines.append(f"\t\t{op_line}")

    # --- Open positions directly under L4 ---
    for _, op in l5_opens.iterrows():
        op_line = line_for_open(op)
        if op_line:
            lines.append(f"\t{op_line}")

    # --- Export ---
    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to Excel: {excel_path}")

    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()
    slide = pres.Slides.Add(1, 12)
    textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
    tr = textbox.TextFrame.TextRange
    tr.Text = "\r".join(lines)
    tr.Font.Size = 8
    pres.SaveAs(ppt_path)
    print(f"Indented hierarchy exported to PPT: {ppt_path}")

    return lines....................................

def export_indented_text_full(level4_id,
                              df_actual,
                              df_open,
                              direct_counts,
                              open_pos_counts,
                              excel_path="OrgChart_Indented.xlsx",
                              ppt_path="OrgChart_Indented.pptx"):
    """
    Export indented hierarchy lines with both direct report counts and open positions shown separately.
    """

    def _clean_str(x):
        if pd.isna(x):
            return ""
        s = str(x).strip()
        return "" if s.lower() == "unspecified" else s

    def _compose_header(name, title):
        name = _clean_str(name)
        title = _clean_str(title)
        if name and title:
            return f"{name} | {title}"
        elif name:
            return f"{name}"
        elif title:
            return f"{title}"
        else:
            return ""

    def _compose_footer(gcb, country):
        gcb = _clean_str(gcb)
        country = _clean_str(country)
        if gcb and country:
            return f"{gcb} | {country}"
        elif gcb:
            return f"{gcb}"
        elif country:
            return f"{country}"
        else:
            return ""

    def _line_for_actual(row, mgr_id):
        header = _compose_header(row.get("Employee Name", ""), row.get("Position Title", ""))
        footer = _compose_footer(row.get("GCB", ""), row.get("Country R3", ""))
        line = f"{header}\n{footer}" if footer else header
        # add counts
        if open_pos_counts.get(mgr_id, 0) > 0:
            line += f"\n→ Open Positions: {open_pos_counts[mgr_id]}"
        if direct_counts.get(mgr_id, 0) > 0:
            line += f"\n→ Direct Reports: {direct_counts[mgr_id]}"
        return line

    def _line_for_open(op_row):
        title = _clean_str(op_row.get("Position Title", ""))
        if not title:
            return None
        pid = op_row.get("PID")
        gcb, country = "", ""
        match = df_actual[df_actual["PID"] == pid]
        if not match.empty:
            gcb = _clean_str(match.iloc[0].get("GCB", ""))
            country = _clean_str(match.iloc[0].get("Country R3", ""))
        header = _compose_header("<Open Position>", title)
        footer = _compose_footer(gcb, country)
        return f"{header}\n{footer}" if footer else header

    lines = []

    # --- L4 manager ---
    mgr_row = df_actual[df_actual["Employee ID"] == level4_id].iloc[0]
    lines.append(_line_for_actual(mgr_row, level4_id))

    # --- L5 reports ---
    l5_actuals = df_actual[df_actual["Functional Manager Employee ID"] == level4_id]
    l5_opens   = df_open[df_open["Functional Manager Employee ID"] == level4_id]

    for _, l5 in l5_actuals.iterrows():
        l5_id = l5.get("Employee ID")
        if pd.isna(l5_id):
            continue
        lines.append(f"\t{_line_for_actual(l5, l5_id)}")

        # --- L6 reports ---
        l6_actuals = df_actual[df_actual["Functional Manager Employee ID"] == l5_id]
        l6_opens   = df_open[df_open["Functional Manager Employee ID"] == l5_id]

        for _, l6 in l6_actuals.iterrows():
            l6_id = l6.get("Employee ID")
            if pd.isna(l6_id):
                continue
            lines.append(f"\t\t{_line_for_actual(l6, l6_id)}")

        for _, op in l6_opens.iterrows():
            op_line = _line_for_open(op)
            if op_line:
                lines.append(f"\t\t{op_line}")

    # --- Open positions directly under L4 ---
    for _, op in l5_opens.iterrows():
        op_line = _line_for_open(op)
        if op_line:
            lines.append(f"\t{op_line}")

    # --- Export ---
    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to Excel: {excel_path}")

    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()
    slide = pres.Slides.Add(1, 12)
    textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
    tr = textbox.TextFrame.TextRange
    tr.Text = "\r".join(lines)
    tr.Font.Size = 8
    pres.SaveAs(ppt_path)
    print(f"Indented hierarchy exported to PPT: {ppt_path}")

    return lines
def box_text_open(row, df_actual):
    pid = row["PID"]

    # Look up GCB and Country R3 from df_actual using PID
    gcb = ""
    country = ""
    match = df_actual[df_actual["PID"] == pid]
    if not match.empty:
        gcb = str(match.iloc[0]["GCB"])
        country = str(match.iloc[0]["Country R3"])

    return f"{row['Position Title']}\n{gcb}\n{country}\n<Open Position>"

for k,open_row in enumerate(open_rows):
    l6_left = left+(L5_W-L6_W)/2
    l6_top = L6_TOP_BASE+(len(l6_rows)+k)*(L6_H+ROW_GAP)
    l6_box = add_box(slide,l6_left,l6_top,L6_W,L6_H,box_text_open(open_row, df_actual))
    connect(slide,l5_box,l6_box)


----------



# -----------------------------
# Step 6: PowerPoint generation (actuals + open positions)
# -----------------------------
import win32com.client
import pandas as pd

def draw_orgchart(level4_id, df_actual, df_open, ppt_path="OrgChart_Output.pptx"):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()

    # Box sizes
    L4_W,L4_H = 320,110
    L5_W,L5_H = 280,100
    L6_W,L6_H = 240,90
    TOP_MARGIN = 30
    L5_TOP = 180
    L6_TOP_BASE = 320
    COL_GAP = 50
    ROW_GAP = 20

    # --- Helpers ---
    def add_box(slide,left,top,w,h,text):
        shape = slide.Shapes.AddShape(1,left,top,w,h)
        shape.TextFrame.TextRange.Text = text
        shape.TextFrame.TextRange.ParagraphFormat.Alignment = 1
        return shape

    def connect(slide,parent,child):
        conn = slide.Shapes.AddConnector(1,0,0,0,0)
        conn.ConnectorFormat.BeginConnect(parent,3)
        conn.ConnectorFormat.EndConnect(child,1)

    def place_row(sw,n,box_w):
        total_w = n*box_w+(n-1)*COL_GAP
        start_left = max(20,(sw-total_w)/2)
        return [start_left+i*(box_w+COL_GAP) for i in range(n)]

    def box_text_actual(emp_id,is_l6=False):
        row = df_actual[df_actual["Employee ID"]==emp_id].iloc[0]
        return f"{row['Employee Name']}\n{row['Position Title']}\n{row['GCB']}\n{row['Country R3']}"

    def box_text_open(row):
        return f"{row['Position Title']}\n{row['GCB']}\n{row['Country R3']}\n<Open Position>"

    def get_direct_reports(manager_id):
        actuals = df_actual[df_actual["Functional Manager Employee ID"] == manager_id]
        opens   = df_open[df_open["Functional Manager Employee ID"] == manager_id]
        return actuals, opens

    # --- Slide builder ---
    def add_l4_slide(l4_id,l5_rows):
        slide = pres.Slides.Add(pres.Slides.Count+1,12)
        sw = pres.PageSetup.SlideWidth

        # L4 box
        l4_left = (sw-L4_W)/2
        l4_box = add_box(slide,l4_left,TOP_MARGIN,L4_W,L4_H,box_text_actual(l4_id))

        # Place L5 boxes
        l5_positions = place_row(sw,len(l5_rows),L5_W)
        for i,l5_row in enumerate(l5_rows):
            l5_id = l5_row["Employee ID"]
            if pd.isna(l5_id): continue
            left = l5_positions[i]
            l5_box = add_box(slide,left,L5_TOP,L5_W,L5_H,box_text_actual(l5_id))
            connect(slide,l4_box,l5_box)

            # Get L6 direct reports (actual + open)
            actuals, opens = get_direct_reports(l5_id)
            l6_rows = [row for _,row in actuals.iterrows() if pd.notna(row["Employee ID"])]
            open_rows = [row for _,row in opens.iterrows()]

            # Handle overflow for actual employees
            if len(l6_rows)>10:
                info_box = add_box(slide,left+(L5_W-L6_W)/2,L6_TOP_BASE,L6_W,L6_H,f"Direct Reports: {len(l6_rows)}")
                connect(slide,l5_box,info_box)
                batch=[]
                for idx,l6_row in enumerate(l6_rows):
                    batch.append(l6_row)
                    if len(batch)==10 or idx==len(l6_rows)-1:
                        ov_slide = pres.Slides.Add(pres.Slides.Count+1,12)
                        sw2 = pres.PageSetup.SlideWidth
                        l5_left = (sw2-L5_W)/2
                        ov_l5_box = add_box(ov_slide,l5_left,TOP_MARGIN,L5_W,L5_H,box_text_actual(l5_id))
                        l6_positions = place_row(sw2,len(batch),L6_W)
                        for j,b in enumerate(batch):
                            l6_id = b["Employee ID"]
                            l6_box = add_box(ov_slide,l6_positions[j],L6_TOP_BASE,L6_W,L6_H,box_text_actual(l6_id,is_l6=True))
                            connect(ov_slide,ov_l5_box,l6_box)
                        batch=[]
            else:
                for j,l6_row in enumerate(l6_rows):
                    l6_id = l6_row["Employee ID"]
                    l6_left = left+(L5_W-L6_W)/2
                    l6_top = L6_TOP_BASE+j*(L6_H+ROW_GAP)
                    l6_box = add_box(slide,l6_left,l6_top,L6_W,L6_H,box_text_actual(l6_id,is_l6=True))
                    connect(slide,l5_box,l6_box)

            # Add open positions as boxes under L5
            for k,open_row in enumerate(open_rows):
                l6_left = left+(L5_W-L6_W)/2
                l6_top = L6_TOP_BASE+(len(l6_rows)+k)*(L6_H+ROW_GAP)
                l6_box = add_box(slide,l6_left,l6_top,L6_W,L6_H,box_text_open(open_row))
                connect(slide,l5_box,l6_box)

    # --- Build chart starting from L4 ---
    l5_reports, _ = get_direct_reports(level4_id)
    l5_rows = [row for _,row in l5_reports.iterrows() if pd.notna(row["Employee ID"])]
    add_l4_slide(level4_id,l5_rows)

    # Save presentation
    pres.SaveAs(ppt_path)
    print(f"Org chart saved to {ppt_path}")

df_final, df_open_enriched = step3_append_open_positions(df)

# Step 6: Generate PowerPoint org chart starting from a Level 4 manager
draw_orgchart(level4_id=12345, df_actual=df_final, df_open=df_open_enriched)

def get_direct_reports(manager_id, df_actual, df_open):
    """Return both actual employees and open positions reporting to a manager."""
    # Actual employees
    actuals = df_actual[df_actual["Functional Manager Employee ID"] == manager_id]

    # Open positions
    opens = df_open[df_open["Functional Manager Employee ID"] == manager_id]

    return actuals, opens


def box_text_actual(row):
    """Format box for actual employee."""
    return f"{row['Employee Name']}\n{row['Position Title']}\n{row['GCB']}\n{row['Country R3']}"


def box_text_open(row):
    """Format box for open position (no employee name)."""
    return f"{row['Position Title']}\n{row['GCB']}\n{row['Country R3']}\n<Open Position>"


def render_hierarchy(manager_id, df_actual, df_open, level=0):
    """Recursive hierarchy renderer with open positions included."""
    # Show manager box
    mgr_row = df_actual[df_actual["Employee ID"] == manager_id].iloc[0]
    print("    " * level + box_text_actual(mgr_row))

    # Get direct reports
    actuals, opens = get_direct_reports(manager_id, df_actual, df_open)

    # Render actual employees
    for _, row in actuals.iterrows():
        print("    " * (level+1) + box_text_actual(row))
        render_hierarchy(row["Employee ID"], df_actual, df_open, level+2)

    # Render open positions
    for _, row in opens.iterrows():
        print("    " * (level+1) + box_text_open(row))



df_final, df_open_enriched = step3_append_open_positions(df)

# Actual direct reports
direct_counts_actual = (
    df_final[df_final["Employee ID"].notna()]
    .groupby("Functional Manager Employee ID")["Employee ID"]
    .nunique()
    .to_dict()
)

# Open positions
open_counts = (
    df_open_enriched.groupby("Functional Manager Employee ID")["PID"]
    .size()
    .to_dict()
)

# Combined
direct_counts_total = {
    mgr: direct_counts_actual.get(mgr, 0) + open_counts.get(mgr, 0)
    for mgr in set(direct_counts_actual) | set(open_counts)
}


# -----------------------------
# Step 3: Append open positions (strict filtering + update)
# -----------------------------

def step3_append_open_positions(df, org_data_path="org_data.xlsx", open_pos_path="open_position.xlsx"):
    """
    Fetches open positions, applies org_data constraints, coalesces manager info,
    and updates df_final in place. Returns df_final and df_open_enriched.
    """

    # --- Load org_data for constraints ---
    needed_cols = [
        "Employee ID","Employee Name","Functional Manager Employee ID",
        "Functional Manager Employee Name","Stack","FTE FCST","PID",
        "Country R3","GCB","Position Title"
    ]
    df_base = pd.read_excel(org_data_path, skiprows=1, sheet_name="Data", usecols=needed_cols)

    # Clean and coerce
    df_base["PID"] = pd.to_numeric(df_base["PID"], errors="coerce").astype("Int64")
    df_base["FTE FCST"] = pd.to_numeric(df_base["FTE FCST"], errors="coerce")
    df_base["Stack"] = df_base["Stack"].astype(str).str.strip()

    # Filter candidates
    mask_candidates = (
        (df_base["Stack"] != "ACTUALS") &
        (df_base["FTE FCST"] > 0) &
        (df_base["PID"].notna())
    )
    df_open_candidates = (
        df_base.loc[mask_candidates, ["PID","Functional Manager Employee ID","Functional Manager Employee Name"]]
        .drop_duplicates(subset=["PID"])
        .copy()
    )

    # --- Load open positions ---
    open_pos = pd.read_excel(
        open_pos_path,
        usecols=[
            "Position Number","Position Title",
            "Functional Manager Position Level Employee ID",
            "Functional Manager Position Level Employee Name"
        ]
    )
    open_pos["Position Number"] = pd.to_numeric(open_pos["Position Number"], errors="coerce").astype("Int64")
    open_pos["Functional Manager Position Level Employee ID"] = pd.to_numeric(
        open_pos["Functional Manager Position Level Employee ID"], errors="coerce"
    ).astype("Int64")

    for col in ["Position Title","Functional Manager Position Level Employee Name"]:
        open_pos[col] = open_pos[col].astype(str).str.strip().replace("Unspecified","")

    # --- Merge candidates with open positions ---
    df_open_enriched = df_open_candidates.merge(
        open_pos,
        left_on="PID",
        right_on="Position Number",
        how="inner",
        suffixes=("_org","_open")
    )

    # --- Coalesce manager fields ---
    df_open_enriched["Manager_ID_Final"] = df_open_enriched["Functional Manager Position Level Employee ID"].fillna(
        df_open_enriched["Functional Manager Employee ID"]
    )
    df_open_enriched["Manager_Name_Final"] = df_open_enriched["Functional Manager Position Level Employee Name"].replace("", pd.NA).fillna(
        df_open_enriched["Functional Manager Employee Name"]
    )

    # --- Prepare placeholder rows ---
    df_open_enriched["Employee ID"] = pd.NA
    df_open_enriched["Employee Name"] = ""
    df_open_enriched["Position Title"] = df_open_enriched["Position Title"].fillna("<blank>")

    # --- Final schema for open positions ---
    df_open_enriched = df_open_enriched[[
        "Employee ID","Employee Name","PID","Position Title",
        "Manager_ID_Final","Manager_Name_Final"
    ]].rename(columns={
        "Manager_ID_Final":"Functional Manager Employee ID",
        "Manager_Name_Final":"Functional Manager Employee Name"
    })

    # --- Update df_final in place ---
    df["PID"] = pd.to_numeric(df["PID"], errors="coerce").astype("Int64")
    updated = 0
    for _, row in df_open_enriched.iterrows():
        mask = df["PID"].eq(row["PID"])
        if mask.any():
            df.loc[mask, ["Functional Manager Employee ID","Functional Manager Employee Name"]] = [
                row["Functional Manager Employee ID"],
                row["Functional Manager Employee Name"]
            ]
            updated += int(mask.sum())

    print(f"Open positions merged: {len(df_open_enriched)}")
    print(f"Rows updated in df_final: {updated}")

    return df.copy(), df_open_enriched

df_final, df_open_enriched = step3_append_open_positions(df)

import pandas as pd
import win32com.client
import tkinter as tk
from tkinter import simpledialog

# -----------------------------
# Helpers
# -----------------------------
def safe_str(x):
    return "" if pd.isna(x) else str(x).strip()

def is_missing(val):
    if pd.isna(val):
        return True
    s = str(val).strip()
    return s == "" or s.lower() == "unspecified"

# -----------------------------
# Step 1: Read org_data.xlsx
# -----------------------------
df = pd.read_excel("org_data.xlsx", sheet_name="Data", skiprows=1)

# Clean text
for col in ["Employee Name","Functional Manager Employee Name","Country R3","GCB","Position Title"]:
    if col in df.columns:
        df[col] = df[col].astype(str).str.strip().replace("Unspecified","")

# Coerce IDs
df["Employee ID"] = pd.to_numeric(df["Employee ID"], errors="coerce").astype("Int64")
df["Functional Manager Employee ID"] = pd.to_numeric(df["Functional Manager Employee ID"], errors="coerce").astype("Int64")
if "PID" in df.columns:
    df["PID"] = pd.to_numeric(df["PID"], errors="coerce").astype("Int64")
else:
    df["PID"] = pd.NA

# -----------------------------
# Step 2: Merge Position Title from gha
# -----------------------------
lookup = pd.read_excel("ghaOct.xlsx", sheet_name="Headcount - Employee Detail",
                       usecols=["Employee ID","Position Title"])
lookup["Employee ID"] = pd.to_numeric(lookup["Employee ID"], errors="coerce").astype("Int64")
lookup["Position Title"] = lookup["Position Title"].astype(str).str.strip().replace("Unspecified","")

# Rename to avoid clash
lookup = lookup.rename(columns={"Position Title":"Position_Title_gha"})

# Merge
df = df.merge(lookup, on="Employee ID", how="left")
df["Position Title"] = df["Position_Title_gha"].fillna(df["Position Title"])
df.drop(columns=["Position_Title_gha"], inplace=True)
df["Position Title"] = df["Position Title"].fillna("<blank>")

# -----------------------------
# Step 3: Append open positions
# -----------------------------
open_pos = pd.read_excel("open_position.xlsx",
                         usecols=["Position Number","Position Title",
                                  "Functional Manager Position Level Employee ID",
                                  "Functional Manager Position Level Employee Name"])
open_pos["Position Number"] = pd.to_numeric(open_pos["Position Number"], errors="coerce").astype("Int64")
open_pos["Functional Manager Position Level Employee ID"] = pd.to_numeric(open_pos["Functional Manager Position Level Employee ID"], errors="coerce").astype("Int64")

df_open = open_pos.rename(columns={
    "Position Number":"PID",
    "Functional Manager Position Level Employee ID":"Functional Manager Employee ID",
    "Functional Manager Position Level Employee Name":"Functional Manager Employee Name"
})
df_open["Employee ID"] = pd.NA
df_open["Employee Name"] = ""
df_open = df_open[["Employee ID","Employee Name","Functional Manager Employee ID",
                   "Functional Manager Employee Name","PID","Position Title"]]

df_final = pd.concat([df, df_open], ignore_index=True)
df_final = df_final.drop_duplicates(subset=["Employee ID","PID","Functional Manager Employee ID"], keep="first")

# -----------------------------
# Step 4: Precompute counts
# -----------------------------
direct_counts = df_final.groupby("Functional Manager Employee ID").size().to_dict()
open_pos_counts = df_open.groupby("Functional Manager Employee ID").size().to_dict()

# -----------------------------
# Step 5: Helpers for hierarchy
# -----------------------------
def get_direct_reports(manager_id):
    return df_final[df_final["Functional Manager Employee ID"] == manager_id].drop_duplicates(subset=["Employee ID","PID"]).copy()

def box_text(emp_id, is_l6=False):
    row = df_final[df_final["Employee ID"] == emp_id]
    if row.empty:
        return "<unknown>"
    r = row.iloc[0]
    lines = [
        f"{safe_str(r.get('Employee Name'))}",
        f"{safe_str(r.get('Position Title'))}",
        f"{safe_str(r.get('GCB'))} | {safe_str(r.get('Country R3'))}"
    ]
    if is_l6:
        l7_count = direct_counts.get(emp_id, 0)
        lines.append(f"Reports: {int(l7_count)}")
    op = open_pos_counts.get(emp_id, 0)
    if op > 0:
        lines.append(f"Open Positions: {op}")
    return "\n".join(lines)

# -----------------------------
# Step 6: PowerPoint generation
# -----------------------------
def draw_orgchart(level4_id, ppt_path="OrgChart_Output.pptx"):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()

    L4_W,L4_H = 320,110
    L5_W,L5_H = 280,100
    L6_W,L6_H = 240,90
    TOP_MARGIN = 30
    L5_TOP = 180
    L6_TOP_BASE = 320
    COL_GAP = 50
    ROW_GAP = 20

    def add_box(slide,left,top,w,h,text):
        shape = slide.Shapes.AddShape(1,left,top,w,h)
        shape.TextFrame.TextRange.Text = text
        shape.TextFrame.TextRange.ParagraphFormat.Alignment = 1
        return shape

    def connect(slide,parent,child):
        conn = slide.Shapes.AddConnector(1,0,0,0,0)
        conn.ConnectorFormat.BeginConnect(parent,3)
        conn.ConnectorFormat.EndConnect(child,1)

    def place_row(sw,n,box_w):
        total_w = n*box_w+(n-1)*COL_GAP
        start_left = max(20,(sw-total_w)/2)
        return [start_left+i*(box_w+COL_GAP) for i in range(n)]

    def add_l4_slide(l4_id,l5_rows):
        slide = pres.Slides.Add(pres.Slides.Count+1,12)
        sw = pres.PageSetup.SlideWidth
        l4_left = (sw-L4_W)/2
        l4_box = add_box(slide,l4_left,TOP_MARGIN,L4_W,L4_H,box_text(l4_id))
        l5_positions = place_row(sw,len(l5_rows),L5_W)
        for i,l5_row in enumerate(l5_rows):
            l5_id = l5_row["Employee ID"]
            if pd.isna(l5_id): continue
            left = l5_positions[i]
            l5_box = add_box(slide,left,L5_TOP,L5_W,L5_H,box_text(l5_id))
            connect(slide,l4_box,l5_box)
            l6_reports = get_direct_reports(l5_id)
            l6_rows = [row for _,row in l6_reports.iterrows() if pd.notna(row["Employee ID"])]
            if len(l6_rows)==0: continue
            if len(l6_rows)>10:
                # Show L5 details on main slide
                info_box = add_box(slide,left+(L5_W-L6_W)/2,L6_TOP_BASE,L6_W,L6_H,f"Direct Reports: {len(l6_rows)}")
                connect(slide,l5_box,info_box)
                # Overflow slides for this L5
                batch=[]
                for idx,l6_row in enumerate(l6_rows):
                    batch.append(l6_row)
                    if len(batch)==10 or idx==len(l6_rows)-1:
                        ov_slide = pres.Slides.Add(pres.Slides.Count+1,12)
                        sw2 = pres.PageSetup.SlideWidth
                        l5_left = (sw2-L5_W)/2
                        ov_l5_box = add_box(ov_slide,l5_left,TOP_MARGIN,L5_W,L5_H,box_text(l5_id))
                        l6_positions = place_row(sw2,len(batch),L6_W)
                        for j,b in enumerate(batch):
                            l6_id = b["Employee ID"]
                            l6_box = add_box(ov_slide,l6_positions[j],L6_TOP_BASE,L6_W,L6_H,box_text(l6_id,is_l6=True))
                            connect(ov_slide,ov_l5_box,l6_box)
                        batch=[]
            else:
                for j,l6_row in enumerate(l6_rows):
                    l6_id = l6_row["Employee ID"]
                    l6_left = left+(L5_W-L6_W)/2
                    l6_top = L6_TOP_BASE+j*(L6_H+ROW_GAP)
                    l6_box = add_box(slide,l6_left,l6_top,L6_W,L6_H,box_text(l6_id,is_l6=True))
                    connect(slide,l5_box,l6_box)

    # Build slides for L4
    l5_reports = get


def export_indented_text_full(level4_id, excel_path="OrgChart_Indented.xlsx", ppt_path="OrgChart_Indented.pptx"):
    """
    Export indented hierarchy lines (with open positions and direct reports counts) to Excel and PowerPoint.
    """

    lines = []

    # --- L4 manager details ---
    mgr_row = df_final[df_final["Employee ID"] == level4_id].iloc[0]
    mgr_details = f"{mgr_row['Employee Name']} | {mgr_row.get('Position Title','<blank>')}\n{mgr_row.get('GCB','')} | {mgr_row.get('Country R3','')}"
    count_open = open_pos_counts.get(level4_id, 0)
    if count_open > 0:
        mgr_details += f"\n→ Open Positions: {count_open}"
    count_reports = direct_counts.get(level4_id, 0)
    if count_reports > 0:
        mgr_details += f"\n→ Direct Reports: {count_reports}"
    lines.append(mgr_details)

    # --- L5 reports ---
    l5_reports = get_direct_reports(level4_id)
    for _, l5 in l5_reports.iterrows():
        l5_id = l5["Employee ID"]
        if pd.isna(l5_id):
            continue
        l5_row = df_final[df_final["Employee ID"] == l5_id].iloc[0]
        l5_details = f"{l5_row.get('Employee Name','')} | {l5_row.get('Position Title','<blank>')}\n{l5_row.get('GCB','')} | {l5_row.get('Country R3','')}"
        count_open = open_pos_counts.get(l5_id, 0)
        if count_open > 0:
            l5_details += f"\n→ Open Positions: {count_open}"
        count_reports = direct_counts.get(l5_id, 0)
        if count_reports > 0:
            l5_details += f"\n→ Direct Reports: {count_reports}"
        lines.append(f"\t{l5_details}")

        # --- L6 reports ---
        l6_reports = get_direct_reports(l5_id)
        for _, l6 in l6_reports.iterrows():
            l6_id = l6["Employee ID"]
            if pd.isna(l6_id):
                continue
            l6_row = df_final[df_final["Employee ID"] == l6_id].iloc[0]
            l6_details = f"{l6_row.get('Employee Name','')} | {l6_row.get('Position Title','<blank>')}\n{l6_row.get('GCB','')} | {l6_row.get('Country R3','')}"
            count_open = open_pos_counts.get(l6_id, 0)
            if count_open > 0:
                l6_details += f"\n→ Open Positions: {count_open}"
            count_reports = direct_counts.get(l6_id, 0)
            if count_reports > 0:
                l6_details += f"\n→ Direct Reports: {count_reports}"
            lines.append(f"\t\t{l6_details}")

    # --- Write to Excel ---
    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to Excel: {excel_path}")

    # --- Write to PowerPoint ---
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()
    slide = pres.Slides.Add(1, 12)
    textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
    tr = textbox.TextFrame.TextRange
    tr.Text = "\r".join(lines)
    tr.Font.Size = 4  # compact font
    pres.SaveAs(ppt_path)
    print(f"Indented hierarchy exported to PPT: {ppt_path}")

    return lines


# -----------------------------
# Step 3: Append open positions (strict filtering)
# -----------------------------
needed_cols = ["Employee ID","Employee Name","Functional Manager Employee ID",
               "Functional Manager Employee Name","Stack","FTE FCST","PID",
               "Country R3","GCB","Position Title"]
df_base = pd.read_excel("org_data.xlsx", skiprows=1, sheet_name="Data", usecols=needed_cols)

# Clean and coerce
df_base["PID"] = pd.to_numeric(df_base["PID"], errors="coerce").astype("Int64")
df_base["FTE FCST"] = pd.to_numeric(df_base["FTE FCST"], errors="coerce")
df_base["Stack"] = df_base["Stack"].astype(str).str.strip()

# Filter: non-actuals, FTE FCST > 0, PID present
mask_candidates = (
    (df_base["Stack"] != "ACTUALS") &
    (df_base["FTE FCST"] > 0) &
    (df_base["PID"].notna())
)
df_open_candidates = (
    df_base.loc[mask_candidates, ["PID","Functional Manager Employee ID","Functional Manager Employee Name"]]
    .drop_duplicates(subset=["PID"])
    .copy()
)

# Load open_position.xlsx
open_pos = pd.read_excel(
    "open_position.xlsx",
    usecols=[
        "Position Number","Position Title",
        "Functional Manager Position Level Employee ID",
        "Functional Manager Position Level Employee Name"
    ]
)
open_pos["Position Number"] = pd.to_numeric(open_pos["Position Number"], errors="coerce").astype("Int64")
open_pos["Functional Manager Position Level Employee ID"] = pd.to_numeric(
    open_pos["Functional Manager Position Level Employee ID"], errors="coerce"
).astype("Int64")
for col in ["Position Title","Functional Manager Position Level Employee Name"]:
    open_pos[col] = open_pos[col].astype(str).str.strip().replace("Unspecified","")

# Inner join: only open positions whose Position Number matches a PID in org_data
df_open_enriched = df_open_candidates.merge(
    open_pos,
    left_on="PID",
    right_on="Position Number",
    how="inner"
)

# Prepare placeholder rows
df_open_enriched["Employee ID"] = pd.NA
df_open_enriched["Employee Name"] = ""
df_open_enriched.rename(columns={
    "Functional Manager Position Level Employee ID": "Functional Manager Employee ID",
    "Functional Manager Position Level Employee Name": "Functional Manager Employee Name"
}, inplace=True)
df_open_enriched["Position Title"] = df_open_enriched["Position Title"].fillna("<blank>")
df_open_enriched = df_open_enriched[[
    "Employee ID","Employee Name","Functional Manager Employee ID",
    "Functional Manager Employee Name","PID","Position Title"
]]

# Combine ACTUALS + filtered open positions
df_final = pd.concat([df, df_open_enriched], ignore_index=True)
df_final = df_final.drop_duplicates(subset=["Employee ID","PID","Functional Manager Employee ID"], keep="first")

# Recompute counts
direct_counts = df_final.groupby("Functional Manager Employee ID").size().to_dict()
open_pos_counts = df_open_enriched.groupby("Functional Manager Employee ID").size().to_dict()



______________
import pandas as pd
import win32com.client
import tkinter as tk
from tkinter import simpledialog

# -----------------------------
# Helpers
# -----------------------------
def safe_str(x):
    return "" if pd.isna(x) else str(x).strip()

def is_missing(val):
    if pd.isna(val):
        return True
    s = str(val).strip()
    return s == "" or s.lower() == "unspecified"

# -----------------------------
# Step 1: Read org_data.xlsx
# -----------------------------
df = pd.read_excel("org_data.xlsx", sheet_name="Data", skiprows=1)

# Clean text
for col in ["Employee Name","Functional Manager Employee Name","Country R3","GCB","Position Title"]:
    if col in df.columns:
        df[col] = df[col].astype(str).str.strip().replace("Unspecified","")

# Coerce IDs
df["Employee ID"] = pd.to_numeric(df["Employee ID"], errors="coerce").astype("Int64")
df["Functional Manager Employee ID"] = pd.to_numeric(df["Functional Manager Employee ID"], errors="coerce").astype("Int64")
if "PID" in df.columns:
    df["PID"] = pd.to_numeric(df["PID"], errors="coerce").astype("Int64")
else:
    df["PID"] = pd.NA

# -----------------------------
# Step 2: Merge Position Title from gha
# -----------------------------
lookup = pd.read_excel("ghaOct.xlsx", sheet_name="Headcount - Employee Detail",
                       usecols=["Employee ID","Position Title"])
lookup["Employee ID"] = pd.to_numeric(lookup["Employee ID"], errors="coerce").astype("Int64")
lookup["Position Title"] = lookup["Position Title"].astype(str).str.strip().replace("Unspecified","")

# Rename to avoid clash
lookup = lookup.rename(columns={"Position Title":"Position_Title_gha"})

# Merge
df = df.merge(lookup, on="Employee ID", how="left")
df["Position Title"] = df["Position_Title_gha"].fillna(df["Position Title"])
df.drop(columns=["Position_Title_gha"], inplace=True)
df["Position Title"] = df["Position Title"].fillna("<blank>")

# -----------------------------
# Step 3: Append open positions
# -----------------------------
open_pos = pd.read_excel("open_position.xlsx",
                         usecols=["Position Number","Position Title",
                                  "Functional Manager Position Level Employee ID",
                                  "Functional Manager Position Level Employee Name"])
open_pos["Position Number"] = pd.to_numeric(open_pos["Position Number"], errors="coerce").astype("Int64")
open_pos["Functional Manager Position Level Employee ID"] = pd.to_numeric(open_pos["Functional Manager Position Level Employee ID"], errors="coerce").astype("Int64")

df_open = open_pos.rename(columns={
    "Position Number":"PID",
    "Functional Manager Position Level Employee ID":"Functional Manager Employee ID",
    "Functional Manager Position Level Employee Name":"Functional Manager Employee Name"
})
df_open["Employee ID"] = pd.NA
df_open["Employee Name"] = ""
df_open = df_open[["Employee ID","Employee Name","Functional Manager Employee ID",
                   "Functional Manager Employee Name","PID","Position Title"]]

df_final = pd.concat([df, df_open], ignore_index=True)
df_final = df_final.drop_duplicates(subset=["Employee ID","PID","Functional Manager Employee ID"], keep="first")

# -----------------------------
# Step 4: Precompute counts
# -----------------------------
direct_counts = df_final.groupby("Functional Manager Employee ID").size().to_dict()
open_pos_counts = df_open.groupby("Functional Manager Employee ID").size().to_dict()

# -----------------------------
# Step 5: Helpers for hierarchy
# -----------------------------
def get_direct_reports(manager_id):
    return df_final[df_final["Functional Manager Employee ID"] == manager_id].drop_duplicates(subset=["Employee ID","PID"]).copy()

def box_text(emp_id, is_l6=False):
    row = df_final[df_final["Employee ID"] == emp_id]
    if row.empty:
        return "<unknown>"
    r = row.iloc[0]
    lines = [
        f"{safe_str(r.get('Employee Name'))}",
        f"{safe_str(r.get('Position Title'))}",
        f"{safe_str(r.get('GCB'))} | {safe_str(r.get('Country R3'))}"
    ]
    if is_l6:
        l7_count = direct_counts.get(emp_id, 0)
        lines.append(f"Reports: {int(l7_count)}")
    op = open_pos_counts.get(emp_id, 0)
    if op > 0:
        lines.append(f"Open Positions: {op}")
    return "\n".join(lines)

# -----------------------------
# Step 6: PowerPoint generation
# -----------------------------
# -----------------------------
# Step 6: PowerPoint generation
# -----------------------------
def draw_orgchart(level4_id, ppt_path="OrgChart_Output.pptx"):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()

    L4_W, L4_H = 320, 110
    L5_W, L5_H = 280, 100
    L6_W, L6_H = 240, 90
    TOP_MARGIN = 30
    L5_TOP = 180
    L6_TOP_BASE = 320
    COL_GAP = 50
    ROW_GAP = 20

    def add_box(slide, left, top, w, h, text):
        shape = slide.Shapes.AddShape(1, left, top, w, h)  # msoShapeRectangle
        tr = shape.TextFrame.TextRange
        tr.Text = text
        tr.ParagraphFormat.Alignment = 1  # center
        shape.TextFrame.AutoSize = 0
        return shape

    def connect(slide, parent_shape, child_shape):
        conn = slide.Shapes.AddConnector(1, 0, 0, 0, 0)  # straight connector
        conn.ConnectorFormat.BeginConnect(parent_shape, 3)  # bottom
        conn.ConnectorFormat.EndConnect(child_shape, 1)    # top
        return conn

    def place_row(slide_width, n, box_w):
        if n <= 0:
            return []
        total_w = n * box_w + (n - 1) * COL_GAP
        start_left = max(20, (slide_width - total_w) / 2)
        return [start_left + i * (box_w + COL_GAP) for i in range(n)]

    def add_l4_slide(l4_id, l5_rows):
        slide = pres.Slides.Add(pres.Slides.Count + 1, 12)
        sw = pres.PageSetup.SlideWidth

        # L4 centered
        l4_left = (sw - L4_W) / 2
        l4_box = add_box(slide, l4_left, TOP_MARGIN, L4_W, L4_H, box_text(l4_id))

        # L5 row
        l5_positions = place_row(sw, len(l5_rows), L5_W)
        for i, l5_row in enumerate(l5_rows):
            l5_id = l5_row["Employee ID"]
            if pd.isna(l5_id):
                continue
            left = l5_positions[i]
            l5_box = add_box(slide, left, L5_TOP, L5_W, L5_H, box_text(l5_id))
            connect(slide, l4_box, l5_box)

            # L6 under L5
            l6_reports = get_direct_reports(l5_id)
            l6_rows = [row for _, row in l6_reports.iterrows() if pd.notna(row["Employee ID"])]

            if len(l6_rows) == 0:
                continue

            if len(l6_rows) > 10:
                # Show placeholder on main slide
                info_box = add_box(slide, left + (L5_W - L6_W) / 2, L6_TOP_BASE, L6_W, L6_H,
                                   f"Direct Reports: {len(l6_rows)}")
                connect(slide, l5_box, info_box)

                # Overflow slides for this L5 (batches of up to 10 L6 per slide)
                batch = []
                for idx, l6_row in enumerate(l6_rows):
                    batch.append(l6_row)
                    is_last = (idx == len(l6_rows) - 1)
                    if len(batch) == 10 or is_last:
                        ov_slide = pres.Slides.Add(pres.Slides.Count + 1, 12)
                        sw2 = pres.PageSetup.SlideWidth
                        l5_left = (sw2 - L5_W) / 2
                        ov_l5_box = add_box(ov_slide, l5_left, TOP_MARGIN, L5_W, L5_H, box_text(l5_id))
                        l6_positions = place_row(sw2, len(batch), L6_W)
                        for j, b in enumerate(batch):
                            l6_id = b["Employee ID"]
                            l6_box = add_box(ov_slide, l6_positions[j], L6_TOP_BASE, L6_W, L6_H, box_text(l6_id, is_l6=True))
                            connect(ov_slide, ov_l5_box, l6_box)
                        batch = []
            else:
                # Render all L6 on main slide
                for j, l6_row in enumerate(l6_rows):
                    l6_id = l6_row["Employee ID"]
                    l6_left = left + (L5_W - L6_W) / 2
                    l6_top = L6_TOP_BASE + j * (L6_H + ROW_GAP)
                    l6_box = add_box(slide, l6_left, l6_top, L6_W, L6_H, box_text(l6_id, is_l6=True))
                    connect(slide, l5_box, l6_box)

    # Build slides for L4 → split L5 across slides if >10
    l5_reports = get_direct_reports(level4_id)
    l5_rows_all = [row for _, row in l5_reports.iterrows() if pd.notna(row["Employee ID"])]

    if len(l5_rows_all) == 0:
        slide = pres.Slides.Add(pres.Slides.Count + 1, 12)
        sw = pres.PageSetup.SlideWidth
        l4_left = (sw - L4_W) / 2
        add_box(slide, l4_left, TOP_MARGIN, L4_W, L4_H, box_text(level4_id))
    elif len(l5_rows_all) <= 10:
        add_l4_slide(level4_id, l5_rows_all)
    else:
        # First slide: first 10 L5
        add_l4_slide(level4_id, l5_rows_all[:10])
        # Second slide: remaining L5
        add_l4_slide(level4_id, l5_rows_all[10:])

    pres.SaveAs(ppt_path)
    print(f"PPT saved: {ppt_path}")
    return pres

# -----------------------------
# Run workflow
# -----------------------------
if __name__ == "__main__":
    root = tk.Tk()
    root.withdraw()
    level4_id = simpledialog.askinteger("Input", "Enter Level 4 Manager Employee ID:")

    if level4_id is None:
        print("No Level 4 ID entered. Exiting.")
    else:
        draw_orgchart(level4_id, "OrgChart_Output.pptx")
        print("Workflow complete. PPT generated.")
import pandas as pd
import win32com.client
def export_indented_text_full(level4_id, excel_path="OrgChart_Indented.xlsx", ppt_path="OrgChart_Indented.pptx"):
    """
    Export indented hierarchy lines (with open positions and direct reports counts) to Excel and PowerPoint.
    """

    lines = []

    # --- L4 manager details ---
    mgr_row = df_final[df_final["Employee ID"] == level4_id].iloc[0]
    mgr_details = f"{mgr_row['Employee Name']} | {mgr_row.get('Position Title','<blank>')}\n{mgr_row.get('GCB','')} | {mgr_row.get('Country R3','')}"
    count_open = open_pos_counts.get(level4_id, 0)
    if count_open > 0:
        mgr_details += f"\n→ Open Positions: {count_open}"
    count_reports = direct_counts.get(level4_id, 0)
    if count_reports > 0:
        mgr_details += f"\n→ Direct Reports: {count_reports}"
    lines.append(mgr_details)

    # --- L5 reports ---
    l5_reports = get_direct_reports(level4_id)
    for _, l5 in l5_reports.iterrows():
        l5_id = l5["Employee ID"]
        if pd.isna(l5_id):
            continue
        l5_row = df_final[df_final["Employee ID"] == l5_id].iloc[0]
        l5_details = f"{l5_row.get('Employee Name','')} | {l5_row.get('Position Title','<blank>')}\n{l5_row.get('GCB','')} | {l5_row.get('Country R3','')}"
        count_open = open_pos_counts.get(l5_id, 0)
        if count_open > 0:
            l5_details += f"\n→ Open Positions: {count_open}"
        count_reports = direct_counts.get(l5_id, 0)
        if count_reports > 0:
            l5_details += f"\n→ Direct Reports: {count_reports}"
        lines.append(f"\t{l5_details}")

        # --- L6 reports ---
        l6_reports = get_direct_reports(l5_id)
        for _, l6 in l6_reports.iterrows():
            l6_id = l6["Employee ID"]
            if pd.isna(l6_id):
                continue
            l6_row = df_final[df_final["Employee ID"] == l6_id].iloc[0]
            l6_details = f"{l6_row.get('Employee Name','')} | {l6_row.get('Position Title','<blank>')}\n{l6_row.get('GCB','')} | {l6_row.get('Country R3','')}"
            count_open = open_pos_counts.get(l6_id, 0)
            if count_open > 0:
                l6_details += f"\n→ Open Positions: {count_open}"
            count_reports = direct_counts.get(l6_id, 0)
            if count_reports > 0:
                l6_details += f"\n→ Direct Reports: {count_reports}"
            lines.append(f"\t\t{l6_details}")

    # --- Write to Excel ---
    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to Excel: {excel_path}")

    # --- Write to PowerPoint ---
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()
    slide = pres.Slides.Add(1, 12)
    textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
    tr = textbox.TextFrame.TextRange
    tr.Text = "\r".join(lines)
    tr.Font.Size = 4  # compact font
    pres.SaveAs(ppt_path)
    print(f"Indented hierarchy exported to PPT: {ppt_path}")

    return lines
lines = export_indented_text_with_openpos(level4_id)
____________________


import pandas as pd
import win32com.client
import tkinter as tk
from tkinter import simpledialog

# -----------------------------
# Step 1: Read and clean org data
# -----------------------------
def is_missing(val):
    if pd.isna(val):
        return True
    s = str(val).strip()
    return s == "" or s.lower() == "unspecified"

# Read org_data.xlsx
df = pd.read_excel("org_data.xlsx", skiprows=1, sheet_name="Data")
df["Employee Name"] = df["Employee Name"].astype(str).str.strip().replace("Unspecified","")
df["Functional Manager Employee Name"] = df["Functional Manager Employee Name"].astype(str).str.strip().replace("Unspecified","")
df["Employee ID"] = pd.to_numeric(df["Employee ID"], errors="coerce").astype("Int64")
df["Functional Manager Employee ID"] = pd.to_numeric(df["Functional Manager Employee ID"], errors="coerce").astype("Int64")

# Read lookup file for Position Title
lookup = pd.read_excel("ghaOct.xlsx", sheet_name="Headcount - Employee Detail")
lookup["Employee ID"] = pd.to_numeric(lookup["Employee ID"], errors="coerce").astype("Int64")

# Merge Position Title into df
df = df.merge(lookup[["Employee ID","Position Title"]], on="Employee ID", how="left")
df["Position Title"] = df["Position Title"].fillna("<blank>")

# Re-read org_data.xlsx for open positions
needed_cols = ["Employee ID","Employee Name","Functional Manager Employee ID",
               "Functional Manager Employee Name","Stack","FTE FCST","PID"]
df_base = pd.read_excel("org_data.xlsx", skiprows=1, sheet_name="Data", usecols=needed_cols)

mask = (
    (df_base["Stack"] != "ACTUALS") &
    (df_base["FTE FCST"] > 0) &
    df_base["PID"].apply(lambda x: not is_missing(x))
)
df_open_candidates = df_base[mask].drop_duplicates(subset=["PID"]).copy()

# Load open_position.xlsx
open_pos = pd.read_excel("open_position.xlsx",
                         usecols=["Position Number","Position Title",
                                  "Functional Manager Position Level Employee ID",
                                  "Functional Manager Position Level Employee Name"])
for col in open_pos.columns:
    open_pos[col] = open_pos[col].astype(str).str.strip().replace("Unspecified","")

open_pos["Position Number"] = pd.to_numeric(open_pos["Position Number"], errors="coerce").astype("Int64")
open_pos["Functional Manager Position Level Employee ID"] = pd.to_numeric(open_pos["Functional Manager Position Level Employee ID"], errors="coerce").astype("Int64")

# Merge candidates with open pos report
df_open_candidates["PID"] = pd.to_numeric(df_open_candidates["PID"], errors="coerce").astype("Int64")
df_open_enriched = df_open_candidates.merge(
    open_pos,
    left_on="PID",
    right_on="Position Number",
    how="left"
)
df_open_enriched = df_open_enriched[~df_open_enriched["Position Number"].isna()].copy()

# Add placeholders for open positions
df_open_enriched["Employee ID"] = pd.NA
df_open_enriched["Employee Name"] = ""
df_open_enriched["Position Title"] = df_open_enriched["Position Title"].fillna("<blank>")

# Combine ACTUALS + Open Positions
df_final = pd.concat([df, df_open_enriched], ignore_index=True)
df_final = df_final.drop_duplicates(subset=["Employee ID","PID"], keep="first")

# -----------------------------
# Step 2: Precompute counts
# -----------------------------
open_pos_counts = (
    df_open_enriched.groupby("Functional Manager Position Level Employee ID")
    .size()
    .to_dict()
)
direct_counts = (
    df_final.groupby("Functional Manager Employee ID")
    .size()
    .to_dict()
)

# -----------------------------
# Step 3: Excel export helpers
# -----------------------------
def get_direct_reports(manager_id):
    return (
        df_final[df_final["Functional Manager Employee ID"] == manager_id]
        .drop_duplicates(subset=["Employee ID","PID"])
        .copy()
    )

def person_header(emp_id):
    row = df_final[df_final["Employee ID"] == emp_id]
    if row.empty:
        return "<unknown>"
    r = row.iloc[0]
    header = f"{r.get('Employee Name','')} | {r.get('Position Title','<blank>')}\n{r.get('GCB','')} | {r.get('Country R3','')}"
    op = open_pos_counts.get(emp_id, 0)
    if op > 0:
        header += f"\n→ Open Positions: {op}"
    return header

def l6_line(emp_id):
    l7_count = direct_counts.get(emp_id, 0)
    line = f"→ Reports: {l7_count}"
    op = open_pos_counts.get(emp_id, 0)
    if op > 0:
        line += f"\n→ Open Positions: {op}"
    return line

def build_indented_lines_for_level4(level4_id):
    lines = []
    overflow_l5_ids = []
    lines.append(person_header(level4_id))
    l5_reports = get_direct_reports(level4_id)

    for _, l5 in l5_reports.iterrows():
        l5_id = l5["Employee ID"]
        if pd.isna(l5_id):
            continue
        l5_hdr = person_header(l5_id)
        l6_reports = get_direct_reports(l5_id)
        l6_count = l6_reports.shape[0]

        if l6_count == 0:
            lines.append(f"\t{l5_hdr}")
        elif l6_count <= 7:
            lines.append(f"\t{l5_hdr}")
            for _, l6 in l6_reports.iterrows():
                l6_id = l6["Employee ID"]
                if pd.isna(l6_id):
                    continue
                lines.append(f"\t\t{l6_line(l6_id)}")
        else:
            lines.append(f"\t{l5_hdr}\n\t→ Direct Reports: {l6_count}")
            overflow_l5_ids.append(l5_id)

    return lines, overflow_l5_ids

def export_indented_to_excel(level4_id, excel_path="OrgChart_Indented.xlsx"):
    lines, overflow_l5_ids = build_indented_lines_for_level4(level4_id)
    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to {excel_path}")
    return overflow_l5_ids

# -----------------------------
# Step 4: PowerPoint generation
# -----------------------------
def write_outline_to_ppt(level4_id, ppt_path="OrgChart_Output.pptx"):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()

    def add_outline_slide(lines):
        slide = pres.Slides.Add(pres.Slides.Count + 1, 12)
        shape = slide.Shapes.AddTextbox(1, 50, 50, 820, 420)
        shape.TextFrame.TextRange.Text = "\r".join(lines)

    # Build main outline for Level 4
    l5_reports = get_direct_reports(level4_id)
    l5_rows = [row for _, row in l5_reports.iterrows()]

    outline_lines = [person_header(level4_id)]
    overflow_l5_ids = []

    for l5_row in l5_rows:
        l5_id = l5_row["Employee ID"]
        if pd.isna(l5_id):
            continue
        outline_lines.append("\t" + person_header(l5_id))

        l6_reports = get_direct_reports(l5_id)
        l6_count = l6_reports.shape[0]

        if l6_count == 0:
            continue
        elif l6_count <= 7:
            for _, l6 in l6_reports.iterrows():
                l6_id = l6["Employee ID"]
                if pd.isna(l6_id):
                    continue
                outline_lines.append("\t\t" + l6_text(l6_id))
        else:
            outline_lines.append("\t\tDirect Reports: " + str(l6_count))
            overflow_l5_ids.append(l5_id)

    # Add Level 4 slide
    add_outline_slide(outline_lines)

    # Add overflow slides for each L5 with >7 L6
    for l5_id in overflow_l5_ids:
        l5_header = person_header(l5_id)
        l6_reports = get_direct_reports(l5_id)
        l6_lines = [f"\t{l6_text(l6_id)}" for l6_id in l6_reports["Employee ID"] if pd.notna(l6_id)]
        add_outline_slide([l5_header] + l6_lines)

    pres.SaveAs(ppt_path)
    print(f"PPT saved: {ppt_path}")
    return pres
# Run the Workflow
# -----------------------------

if __name__ == "__main__":
    # Prompt user for the Level 4 Manager Employee ID
    root = tk.Tk()
    root.withdraw()
    level4_id = simpledialog.askinteger("Input", "Enter Level 4 Manager Employee ID:")

    if level4_id is None:
        print("No Level 4 ID entered. Exiting.")
    else:
        # Step 3: Export hierarchy to Excel
        overflow_l5_ids = export_indented_to_excel(level4_id, "OrgChart_Indented.xlsx")

        # Step 4: Generate PowerPoint slides
        write_to_ppt(level4_id, "OrgChart_Output.pptx")

        print("Workflow complete. Excel and PPT generated.")
...................................................................
............................................

import pandas as pd
import win32com.client
import tkinter as tk
from tkinter import simpledialog

# --- Helper functions ---
def is_missing(val):
    if pd.isna(val):
        return True
    s = str(val).strip()
    return s == "" or s.lower() == "unspecified"

def get_direct_reports(manager_id):
    return (
        df_final[df_final["Functional Manager Employee ID"] == manager_id]
        .drop_duplicates(subset=["Employee ID", "PID"])
        .copy()
    )

def person_header(emp_id):
    row = df_final[df_final["Employee ID"] == emp_id]
    if row.empty:
        return "<unknown>"
    r = row.iloc[0]
    header = f"{r.get('Employee Name','')} | {r.get('Position Title','<blank>')}\n{r.get('GCB','')} | {r.get('Country R3','')}"
    op = open_pos_counts.get(emp_id, 0)
    if op > 0:
        header += f"\n→ Open Positions: {op}"
    return header

def l6_line(emp_id):
    l7_count = direct_counts.get(emp_id, 0)
    line = f"→ Reports: {l7_count}"
    op = open_pos_counts.get(emp_id, 0)
    if op > 0:
        line += f"\n→ Open Positions: {op}"
    return line

# --- Step 3: Build indented hierarchy for Excel ---
def build_indented_lines_for_level4(level4_id):
    lines = []
    overflow_l5_ids = []

    # Level 4 header
    lines.append(person_header(level4_id))

    # All Level 5 under this Level 4
    l5_reports = get_direct_reports(level4_id)

    for _, l5 in l5_reports.iterrows():
        l5_id = l5["Employee ID"]
        if pd.isna(l5_id):
            continue

        l5_hdr = person_header(l5_id)
        l6_reports = get_direct_reports(l5_id)
        l6_count = l6_reports.shape[0]

        if l6_count == 0:
            lines.append(f"\t{l5_hdr}")
        elif l6_count <= 7:
            lines.append(f"\t{l5_hdr}")
            for _, l6 in l6_reports.iterrows():
                l6_id = l6["Employee ID"]
                if pd.isna(l6_id):
                    continue
                lines.append(f"\t\t{l6_line(l6_id)}")
        else:
            lines.append(f"\t{l5_hdr}\n\t→ Direct Reports: {l6_count}")
            overflow_l5_ids.append(l5_id)

    return lines, overflow_l5_ids

def export_indented_to_excel(level4_id, excel_path="OrgChart_Indented.xlsx"):
    lines, overflow_l5_ids = build_indented_lines_for_level4(level4_id)
    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to {excel_path}")
    return overflow_l5_ids

# --- Step 4: PowerPoint generation ---
def write_to_ppt(level4_id, ppt_path="OrgChart_Output.pptx"):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()

    def add_slide_with_lines(header_text, block_lines):
        slide = pres.Slides.Add(pres.Slides.Count + 1, 12)
        shape = slide.Shapes.AddTextbox(1, 50, 50, 820, 420)
        shape.TextFrame.TextRange.Text = "\r".join([header_text] + block_lines)

    def batch_list(items, size=7):
        return [items[i:i+size] for i in range(0, len(items), size)]

    # Level 4 header and all L5
    level4_header = person_header(level4_id)
    l5_reports = get_direct_reports(level4_id)

    l5_blocks = []
    overflow_l5_ids = []

    for _, l5 in l5_reports.iterrows():
        l5_id = l5["Employee ID"]
        if pd.isna(l5_id):
            continue

        block_lines = [person_header(l5_id)]
        l6_reports = get_direct_reports(l5_id)
        l6_count = l6_reports.shape[0]

        if l6_count == 0:
            pass
        elif l6_count <= 7:
            for _, l6 in l6_reports.iterrows():
                l6_id = l6["Employee ID"]
                if pd.isna(l6_id):
                    continue
                block_lines.append("\t" + l6_line(l6_id))
        else:
            block_lines.append(f"\t→ Direct Reports: {l6_count}")
            overflow_l5_ids.append(l5_id)

        l5_blocks.append("\n".join(block_lines))

    # Batch L5 blocks into groups of 7 for Level 4 slides
    for chunk in batch_list(l5_blocks, size=7):
        add_slide_with_lines(level4_header, chunk)

    # Overflow slides for L5 with >7 L6
    for l5_id in overflow_l5_ids:
        l5_header = person_header(l5_id)
        l6_reports = get_direct_reports(l5_id)

        l6_lines = []
        for _, l6 in l6_reports.iterrows():
            l6_id = l6["Employee ID"]
            if pd.isna(l6_id):
                continue
            l6_lines.append(l6_line(l6_id))

        for chunk in batch_list(l6_lines, size=7):
            add_slide_with_lines(l5_header, chunk)

    pres.SaveAs(ppt_path)
    print(f"PPT saved: {ppt_path}")
    return pres

# --- Orchestration ---
root = tk.Tk()
root.withdraw()
level4_id = simpledialog.askinteger("Input", "Enter Level 4 Manager Employee ID:")

overflow_l5_ids = export_indented_to_excel(level4_id, "OrgChart_Indented.xlsx")
write_to_ppt(level4_id, "OrgChart_Output.pptx")


....................................

import pandas as pd
import win32com.client
import tkinter as tk
from tkinter import simpledialog

# --- Helper to detect missing values robustly ---
def is_missing(val):
    if pd.isna(val):
        return True
    s = str(val).strip()
    return s == "" or s.lower() == "unspecified"

# Step 1: Read base org data (ACTUALS)
df = pd.read_excel("org_data.xlsx", skiprows=1, sheet_name="Data")
df["Employee Name"] = df["Employee Name"].astype(str).str.strip().replace("Unspecified","")
df["Functional Manager Employee Name"] = df["Functional Manager Employee Name"].astype(str).str.strip().replace("Unspecified","")
df["Employee ID"] = pd.to_numeric(df["Employee ID"], errors="coerce").astype("Int64")
df["Functional Manager Employee ID"] = pd.to_numeric(df["Functional Manager Employee ID"], errors="coerce").astype("Int64")

# Step 1b: Read lookup file for Position Title
lookup = pd.read_excel("ghaOct.xlsx", sheet_name="Headcount - Employee Detail")
lookup["Employee ID"] = pd.to_numeric(lookup["Employee ID"], errors="coerce").astype("Int64")

# Merge Position Title into df (ID-based)
df = df.merge(lookup[["Employee ID","Position Title"]], on="Employee ID", how="left")
df["Position Title"] = df["Position Title"].fillna("<blank>")

# Step 1c: Re-read org_data.xlsx for open positions
needed_cols = ["Employee ID","Employee Name","Functional Manager Employee ID",
               "Functional Manager Employee Name","Stack","FTE FCST","PID"]
df_base = pd.read_excel("org_data.xlsx", skiprows=1, sheet_name="Data", usecols=needed_cols)

mask = (
    (df_base["Stack"] != "ACTUALS") &
    (df_base["FTE FCST"] > 0) &
    df_base["PID"].apply(lambda x: not is_missing(x))
)
df_open_candidates = df_base[mask].drop_duplicates(subset=["PID"]).copy()

# Step 1d: Load open_position.xlsx
open_pos = pd.read_excel("open_position.xlsx",
                         usecols=["Position Number","Position Title",
                                  "Functional Manager Position Level Employee ID",
                                  "Functional Manager Position Level Employee Name"])
for col in open_pos.columns:
    open_pos[col] = open_pos[col].astype(str).str.strip().replace("Unspecified","")

open_pos["Position Number"] = pd.to_numeric(open_pos["Position Number"], errors="coerce").astype("Int64")
open_pos["Functional Manager Position Level Employee ID"] = pd.to_numeric(open_pos["Functional Manager Position Level Employee ID"], errors="coerce").astype("Int64")

# Step 1e: Merge candidates with open pos report (ID-based)
df_open_candidates["PID"] = pd.to_numeric(df_open_candidates["PID"], errors="coerce").astype("Int64")
df_open_enriched = df_open_candidates.merge(
    open_pos,
    left_on="PID",
    right_on="Position Number",
    how="left"
)

# Skip rows where Position Number is missing
df_open_enriched = df_open_enriched[~df_open_enriched["Position Number"].isna()].copy()

# Add placeholders for open positions
df_open_enriched["Employee ID"] = pd.NA
df_open_enriched["Employee Name"] = ""
df_open_enriched["Position Title"] = df_open_enriched["Position Title"].fillna("<blank>")

# Step 1f: Combine ACTUALS + Open Positions
df_final = pd.concat([df, df_open_enriched], ignore_index=True)
df_final = df_final.drop_duplicates(subset=["Employee ID","PID"], keep="first")

# Step 2: Precompute counts
open_pos_counts = (
    df_open_enriched.groupby("Functional Manager Position Level Employee ID")
    .size()
    .to_dict()
)
direct_counts = (
    df_final.groupby("Functional Manager Employee ID")
    .size()
    .to_dict()
)

output_rows = []
overflow_managers = []

def traverse_level5(level4_id):
    level5_reports = df_final[df_final["Functional Manager Employee ID"] == level4_id].drop_duplicates(subset=["Employee ID","PID"])
    for _, l5 in level5_reports.iterrows():
        l5_id = l5["Employee ID"]
        if is_missing(l5_id):
            continue
        level6_reports = df_final[df_final["Functional Manager Employee ID"] == l5_id].drop_duplicates(subset=["Employee ID","PID"])
        if level6_reports.empty:
            output_rows.append([level4_id, l5_id, None, 0, l5.get("PID",""), l5.get("Position Title","")])
        else:
            for _, l6 in level6_reports.iterrows():
                l6_id = l6["Employee ID"]
                count = df_final[df_final["Functional Manager Employee ID"] == l6_id].drop_duplicates(subset=["Employee ID","PID"]).shape[0]
                output_rows.append([level4_id, l5_id, l6_id, count, l6.get("PID",""), l6.get("Position Title","")])

# Step 3: Export indented hierarchy with details
def export_indented_to_excel(out_df, excel_path="OrgChart_Indented.xlsx", level4_id=None):
    lines = []
    if level4_id is not None:
        mgr_row = df_final[df_final["Employee ID"] == level4_id].iloc[0]
        mgr_details = f"{mgr_row['Employee Name']} | {mgr_row.get('Position Title','<blank>')}\n{mgr_row.get('GCB','')} | {mgr_row.get('Country R3','')}"
        count_open = open_pos_counts.get(level4_id, 0)
        if count_open > 0:
            mgr_details += f"\n→ Open Positions: {count_open}"
        lines.append(mgr_details)

    for l5_id, group in out_df.groupby("Level 5 Employee ID"):
        if pd.notna(l5_id):
            l5_row = df_final[df_final["Employee ID"] == l5_id].iloc[0]
            l5_details = (
                f"{l5_row.get('Employee Name','')} | {l5_row.get('Position Title','<blank>')}\n"
                f"{l5_row.get('GCB','')} | {l5_row.get('Country R3','')}"
            )
            count_open = open_pos_counts.get(l5_id, 0)
            if count_open > 0:
                l5_details += f"\n→ Open Positions: {count_open}"
            count_reports = direct_counts.get(l5_id, 0)
            if count_reports > 7:   # overflow rule for Level-5
                l5_details += f"\n→ Direct Reports: {count_reports}"
                overflow_managers.append(l5_id)
            lines.append(f"\t{l5_details}")

        for _, row in group.iterrows():
            l6_id = row["Level 6 Employee ID"]
            count = row["Count of Direct Reports"]
            if pd.notna(l6_id):
                l6_row = df_final[df_final["Employee ID"] == l6_id].iloc[0]
                l6_details = (
                    f"{l6_row.get('Employee Name','')} | {l6_row.get('Position Title','<blank>')}\n"
                    f"{l6_row.get('GCB','')} | {l6_row.get('Country R3','')}\n"
                    f"→ Reports: {count}"
                )
                count_open = open_pos_counts.get(l6_id, 0)
                if count_open > 0:
                    l6_details += f"\n→ Open Positions: {count_open}"
                if count > 7:   # overflow rule for Level-6
                    overflow_managers.append(l6_id)
                lines.append(f"\t\t{l6_details}")

    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to {excel_path}")
    return lines


# Step 4: Write to PowerPoint with batching + overflow
def write_indented_to_ppt(lines, ppt_path="OrgChart_Output.pptx", level4_id=None):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()

    # Helper to create slides in batches of 7
    def create_batched_slides(header, report_lines):
        chunks = [report_lines[i:i+7] for i in range(0, len(report_lines), 7)]
        for chunk in chunks:
            slide = pres.Slides.Add(pres.Slides.Count+1, 12)
            textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
            textbox.TextFrame.TextRange.Text = "\r".join([header] + chunk)

    # Level-4 batching
    mgr_header = lines[0]
    report_lines = lines[1:]
    create_batched_slides(mgr_header, report_lines)

    # Add overflow slides for managers (Level-5 or Level-6 with >7 reports)
    for mgr_id in overflow_managers:
        mgr_row = df_final[df_final["Employee ID"] == mgr_id].iloc[0]
        mgr_details = f"{mgr_row['Employee Name']} | {mgr_row.get('Position Title','<blank>')}\n{mgr_row.get('GCB','')} | {mgr_row.get('Country R3','')}"
        count_open = open_pos_counts.get(mgr_id, 0)
        if count_open > 0:
            mgr_details += f"\n→ Open Positions: {count_open}"

        # Collect all direct reports of this overflow manager
        mgr_reports = df_final[df_final["Functional Manager Employee ID"] == mgr_id].drop_duplicates(subset=["Employee ID","PID"])
        report_lines = []
        for _, rep in mgr_reports.iterrows():
            rep_details = f"{rep.get('Employee Name','')} | {rep.get('Position Title','<blank>')}\n{rep.get('GCB','')} | {rep.get('Country R3','')}"
            count_reports = direct_counts.get(rep["Employee ID"], 0)
            if count_reports > 0:
                rep_details += f"\n→ Reports: {count_reports}"
            count_open = open_pos_counts.get(rep["Employee ID"], 0)
            if count_open > 0:
                rep_details += f"\n→ Open Positions: {count_open}"
            report_lines.append(f"\t{rep_details}")

        # Batch these reportees into slides of 7
        create_batched_slides(mgr_details, report_lines)

    pres.SaveAs(ppt_path)
    print(f"PPT saved: {ppt_path}")
    return pres


# --- Ask user for Level 4 Manager Employee ID ---
root = tk.Tk()
root.withdraw()
level4_id = simpledialog.askinteger("Input", "Enter Level 4 Manager Employee ID:")

# --- Traverse hierarchy ---
traverse_level5(level4_id)

# --- Build DataFrame ---
out_df = pd.DataFrame(output_rows, columns=[
    "Level 4 Employee ID","Level 5 Employee ID","Level 6 Employee ID",
    "Count of Direct Reports","PID","Position Title"
])

# --- Export hierarchy to Excel and capture lines ---
lines = export_indented_to_excel(out_df, "OrgChart_Indented.xlsx", level4_id=level4_id)

# --- Write those lines to PowerPoint ---
write_indented_to_ppt(lines, "OrgChart_Output.pptx", level4_id=level4_id)---- following is ok for op pos as well
import pandas as pd
import win32com.client
import tkinter as tk
from tkinter import simpledialog

# --- Helper to detect missing values robustly ---
def is_missing(val):
    if pd.isna(val):
        return True
    s = str(val).strip()
    return s == "" or s.lower() == "unspecified"

# Step 1: Read base org data (ACTUALS)
df = pd.read_excel("org_data.xlsx", skiprows=1, sheet_name="Data")
df["Employee Name"] = df["Employee Name"].astype(str).str.strip().replace("Unspecified","")
df["Functional Manager Employee Name"] = df["Functional Manager Employee Name"].astype(str).str.strip().replace("Unspecified","")
df["Employee ID"] = pd.to_numeric(df["Employee ID"], errors="coerce").astype("Int64")
df["Functional Manager Employee ID"] = pd.to_numeric(df["Functional Manager Employee ID"], errors="coerce").astype("Int64")

# Step 1b: Read lookup file for Position Title
lookup = pd.read_excel("ghaOct.xlsx", sheet_name="Headcount - Employee Detail")
lookup["Employee ID"] = pd.to_numeric(lookup["Employee ID"], errors="coerce").astype("Int64")

# Merge Position Title into df (ID-based)
df = df.merge(lookup[["Employee ID","Position Title"]], on="Employee ID", how="left")
df["Position Title"] = df["Position Title"].fillna("<blank>")

# Step 1c: Re-read org_data.xlsx for open positions
needed_cols = ["Employee ID","Employee Name","Functional Manager Employee ID",
               "Functional Manager Employee Name","Stack","FTE FCST","PID"]
df_base = pd.read_excel("org_data.xlsx", skiprows=1, sheet_name="Data", usecols=needed_cols)

mask = (
    (df_base["Stack"] != "ACTUALS") &
    (df_base["FTE FCST"] > 0) &
    df_base["PID"].apply(lambda x: not is_missing(x))
)
df_open_candidates = df_base[mask].drop_duplicates(subset=["PID"]).copy()

# Step 1d: Load open_position.xlsx
open_pos = pd.read_excel("open_position.xlsx",
                         usecols=["Position Number","Position Title",
                                  "Functional Manager Position Level Employee ID",
                                  "Functional Manager Position Level Employee Name"])
for col in open_pos.columns:
    open_pos[col] = open_pos[col].astype(str).str.strip().replace("Unspecified","")

open_pos["Position Number"] = pd.to_numeric(open_pos["Position Number"], errors="coerce").astype("Int64")
open_pos["Functional Manager Position Level Employee ID"] = pd.to_numeric(open_pos["Functional Manager Position Level Employee ID"], errors="coerce").astype("Int64")

# Step 1e: Merge candidates with open pos report (ID-based)
df_open_candidates["PID"] = pd.to_numeric(df_open_candidates["PID"], errors="coerce").astype("Int64")
df_open_enriched = df_open_candidates.merge(
    open_pos,
    left_on="PID",
    right_on="Position Number",
    how="left"
)

# Skip rows where Position Number is missing
df_open_enriched = df_open_enriched[~df_open_enriched["Position Number"].isna()].copy()

# Add placeholders for open positions
df_open_enriched["Employee ID"] = pd.NA
df_open_enriched["Employee Name"] = ""
df_open_enriched["Position Title"] = df_open_enriched["Position Title"].fillna("<blank>")

# Step 1f: Combine ACTUALS + Open Positions
df_final = pd.concat([df, df_open_enriched], ignore_index=True)
df_final = df_final.drop_duplicates(subset=["Employee ID","PID"], keep="first")

# Step 2: Precompute counts
open_pos_counts = (
    df_open_enriched.groupby("Functional Manager Position Level Employee ID")
    .size()
    .to_dict()
)
direct_counts = (
    df_final.groupby("Functional Manager Employee ID")
    .size()
    .to_dict()
)

output_rows = []
overflow_managers = []

def traverse_level5(level4_id):
    level5_reports = df_final[df_final["Functional Manager Employee ID"] == level4_id].drop_duplicates(subset=["Employee ID","PID"])
    for _, l5 in level5_reports.iterrows():
        l5_id = l5["Employee ID"]
        if is_missing(l5_id):
            continue
        level6_reports = df_final[df_final["Functional Manager Employee ID"] == l5_id].drop_duplicates(subset=["Employee ID","PID"])
        if level6_reports.empty:
            output_rows.append([level4_id, l5_id, None, 0, l5.get("PID",""), l5.get("Position Title","")])
        else:
            for _, l6 in level6_reports.iterrows():
                l6_id = l6["Employee ID"]
                count = df_final[df_final["Functional Manager Employee ID"] == l6_id].drop_duplicates(subset=["Employee ID","PID"]).shape[0]
                output_rows.append([level4_id, l5_id, l6_id, count, l6.get("PID",""), l6.get("Position Title","")])

# Step 3: Export indented hierarchy with details
def export_indented_to_excel(out_df, excel_path="OrgChart_Indented.xlsx", level4_id=None):
    lines = []
    if level4_id is not None:
        mgr_row = df_final[df_final["Employee ID"] == level4_id].iloc[0]
        mgr_details = f"{mgr_row['Employee Name']} | {mgr_row.get('Position Title','<blank>')}\n{mgr_row.get('GCB','')} | {mgr_row.get('Country R3','')}"
        count_open = open_pos_counts.get(level4_id, 0)
        if count_open > 0:
            mgr_details += f"\n→ Open Positions: {count_open}"
        lines.append(mgr_details)

    for l5_id, group in out_df.groupby("Level 5 Employee ID"):
        if pd.notna(l5_id):
            l5_row = df_final[df_final["Employee ID"] == l5_id].iloc[0]
            l5_details = f"{l5_row.get('Position Title','<blank>')}\n{l5_row.get('GCB','')} | {l5_row.get('Country R3','')}"
            count_open = open_pos_counts.get(l5_id, 0)
            if count_open > 0:
                l5_details += f"\n→ Open Positions: {count_open}"
            count_reports = direct_counts.get(l5_id, 0)
            if count_reports > 10:
                l5_details += f"\n→ Direct Reports: {count_reports} (see next slide)"
                overflow_managers.append(l5_id)
            lines.append(f"\t{l5_details}")

        for _, row in group.iterrows():
            l6_id = row["Level 6 Employee ID"]
            count = row["Count of Direct Reports"]
            if pd.notna(l6_id):
                l6_row = df_final[df_final["Employee ID"] == l6_id].iloc[0]
                l6_details = (
                    f"{l6_row.get('Position Title','<blank>')}\n"
                    f"{l6_row.get('GCB','')} | {l6_row.get('Country R3','')}\n"
                    f"→ Reports: {count}"
                )
                count_open = open_pos_counts.get(l6_id, 0)
                if count_open > 0:
                    l6_details += f"\n→ Open Positions: {count_open}"
                count_reports = direct_counts.get(l6_id, 0)
                if count_reports > 10:
                    l6_details += f"\n→ Direct Reports: {count_reports} (see next slide)"
                    overflow_managers.append(l6_id)
                lines.append(f"\t\t{l6_details}")

    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to {excel_path}")
    return lines

# Step 4: Write to PowerPoint
def write_indented_to_ppt(lines, ppt_path="OrgChart_Output.pptx"):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()
    slide = pres.Slides.Add(1, 12)

    textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
    tr = textbox.TextFrame.TextRange
    tr.Text = "\r".join(lines)

    # Add extra slides for overflow managers
    for mgr_id in overflow_managers:
        mgr_reports = df_final[df_final["Functional Manager Employee ID"] == mgr_id].drop_duplicates(subset=["Employee ID","PID"])
        mgr_row = df_final[df_final["Employee ID"] == mgr_id].iloc[0]
        mgr_details = f"{mgr_row['Employee Name']} | {mgr_row.get('Position Title','<blank>')}\n{mgr_row.get('GCB','')} | {mgr_row.get('Country R3','')}"
        report_lines = [mgr_details]

        for _, rep in mgr_reports.iterrows():
            if pd.notna(rep["Employee ID"]):
                rep_id = rep["Employee ID"]
                rep_details = f"{rep.get('Position Title','<blank>')}\n{rep.get('GCB','')} | {rep.get('Country R3','')}"
                # Add direct reports count
                count_reports = df_final[df_final["Functional Manager Employee ID"] == rep_id].drop_duplicates(subset=["Employee ID","PID"]).shape[0]
                if count_reports > 0:
                    rep_details += f"\n→ Reports: {count_reports}"
                # Add open positions count
                count_open = open_pos_counts.get(rep_id, 0)
                if count_open > 0:
                    rep_details += f"\n→ Open Positions: {count_open}"
                report_lines.append(f"\t{rep_details}")

        slide = pres.Slides.Add(pres.Slides.Count+1, 12)
        textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
        textbox.TextFrame.TextRange.Text = "\r".join(report_lines)

    pres.SaveAs(ppt_path)
    print(f"PPT saved: {ppt_path}")
    return pres
#write_indented_to_ppt(lines, "OrgChart_Output.pptx")

# --- Ask user for Level 4 Manager Employee ID ---
root = tk.Tk()
root.withdraw()  # hide Tkinter main window
level4_id = simpledialog.askinteger("Input", "Enter Level 4 Manager Employee ID:")

# --- Traverse hierarchy for that manager ---
traverse_level5(level4_id)

# --- Build DataFrame from collected rows ---
out_df = pd.DataFrame(output_rows, columns=[
    "Level 4 Employee ID","Level 5 Employee ID","Level 6 Employee ID",
    "Count of Direct Reports","PID","Position Title"
])

# --- Export hierarchy to Excel and capture lines ---
lines = export_indented_to_excel(out_df, "OrgChart_Indented.xlsx", level4_id=level4_id)

# --- Write those lines to PowerPoint ---
write_indented_to_ppt(lines, "OrgChart_Output.pptx")
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>






....................................................

Here is a more polished and senior-management-friendly version:

---

**Subject:** Monthly Hybrid Workstyle Dashboard – Confirmation on Gurugram Threshold

Dear Team,

Please find attached the monthly Hybrid Workstyle Dashboard report.

As the comparison metrics may vary with the revised guidelines, we have currently retained the **Gurugram office threshold at 1 day**.
Requesting your confirmation on whether this should be updated to **2 days effective 1st December** or **1st January**, so we can align the reporting accordingly.

Thank you,
[Your Name]

---

If you want it to sound even more formal or add a justification line, I can refine it further.



# Keep track of managers needing extra slides
overflow_managers = []

def export_indented_to_excel(out_df, excel_path="OrgChart_Indented.xlsx", level4_id=None):
    lines = []
    if level4_id is not None:
        mgr_row = df_final[df_final["Employee ID"] == level4_id].iloc[0]
        mgr_details = f"{mgr_row['Employee Name']} | {mgr_row.get('Position Title','')}\n{mgr_row.get('GCB','')} | {mgr_row.get('Country R3','')}"
        lines.append(mgr_details)

    for l5_id, group in out_df.groupby("Level 5 Employee ID"):
        if pd.notna(l5_id):
            l5_row = df_final[df_final["Employee ID"] == l5_id].iloc[0]
            l5_details = f"{l5_row['Employee Name']} | {l5_row.get('Position Title','')}\n{l5_row.get('GCB','')} | {l5_row.get('Country R3','')}"
            count_reports = direct_counts.get(l5_id, 0)
            if count_reports > 10:
                l5_details += f"\n→ Direct Reports: {count_reports} (see next slide)"
                overflow_managers.append(l5_id)
            lines.append(f"\t{l5_details}")

        for _, row in group.iterrows():
            l6_id = row["Level 6 Employee ID"]
            count = row["Count of Direct Reports"]

            if pd.notna(l6_id):
                l6_row = df_final[df_final["Employee ID"] == l6_id].iloc[0]
                l6_details = (
                    f"{l6_row['Employee Name']} | {l6_row.get('Position Title','')}\n"
                    f"{l6_row.get('GCB','')} | {l6_row.get('Country R3','')}\n"
                    f"→ Reports: {count}"
                )
                count_reports = direct_counts.get(l6_id, 0)
                if count_reports > 10:
                    l6_details += f"\n→ Direct Reports: {count_reports} (see next slide)"
                    overflow_managers.append(l6_id)
                lines.append(f"\t\t{l6_details}")

    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to {excel_path}")
    return lines

def write_indented_to_ppt(lines, ppt_path="OrgChart_Output.pptx"):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()
    slide = pres.Slides.Add(1, 12)

    textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
    tr = textbox.TextFrame.TextRange
    tr.Text = "\r".join(lines)

    # Add extra slides for overflow managers
    for mgr_id in overflow_managers:
        mgr_reports = df_final[df_final["Functional Manager Employee ID"] == mgr_id]
        mgr_row = df_final[df_final["Employee ID"] == mgr_id].iloc[0]
        mgr_details = f"{mgr_row['Employee Name']} | {mgr_row.get('Position Title','')}\n{mgr_row.get('GCB','')} | {mgr_row.get('Country R3','')}"
        report_lines = [mgr_details]
        for _, rep in mgr_reports.iterrows():
            if pd.notna(rep["Employee ID"]):
                rep_details = f"{rep['Employee Name']} | {rep.get('Position Title','')}\n{rep.get('GCB','')} | {rep.get('Country R3','')}"
                report_lines.append(f"\t{rep_details}")
        slide = pres.Slides.Add(pres.Slides.Count+1, 12)
        textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
        textbox.TextFrame.TextRange.Text = "\r".join(report_lines)

    pres.SaveAs(ppt_path)
    print(f"PPT saved: {ppt_path}")

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# Step: Aggregate open positions by manager
open_pos_counts = (
    df_open_enriched.groupby("Functional Manager Position Level Employee ID")
    .size()
    .to_dict()
)

# Step 3: Export indented hierarchy with details (employees + open position counts)
def export_indented_to_excel(out_df, excel_path="OrgChart_Indented.xlsx", level4_id=None):
    lines = []
    if level4_id is not None:
        mgr_row = df_final[df_final["Employee ID"] == level4_id].iloc[0]
        mgr_details = f"{mgr_row['Employee Name']} | {mgr_row.get('Position Title','')}\n{mgr_row.get('GCB','')} | {mgr_row.get('Country R3','')}"
        # Add open positions count for Level 4 manager
        count_open = open_pos_counts.get(level4_id, 0)
        if count_open > 0:
            mgr_details += f"\n→ Open Positions: {count_open}"
        lines.append(mgr_details)

    for l5_id, group in out_df.groupby("Level 5 Employee ID"):
        if pd.notna(l5_id):
            l5_row = df_final[df_final["Employee ID"] == l5_id].iloc[0]
            l5_details = f"{l5_row['Employee Name']} | {l5_row.get('Position Title','')}\n{l5_row.get('GCB','')} | {l5_row.get('Country R3','')}"
            # Add open positions count for Level 5
            count_open = open_pos_counts.get(l5_id, 0)
            if count_open > 0:
                l5_details += f"\n→ Open Positions: {count_open}"
            lines.append(f"\t{l5_details}")

        for _, row in group.iterrows():
            l6_id = row["Level 6 Employee ID"]
            count = row["Count of Direct Reports"]

            if pd.notna(l6_id):
                l6_row = df_final[df_final["Employee ID"] == l6_id].iloc[0]
                l6_details = (
                    f"{l6_row['Employee Name']} | {l6_row.get('Position Title','')}\n"
                    f"{l6_row.get('GCB','')} | {l6_row.get('Country R3','')}\n"
                    f"→ Reports: {count}"
                )
                # Add open positions count for Level 6
                count_open = open_pos_counts.get(l6_id, 0)
                if count_open > 0:
                    l6_details += f"\n→ Open Positions: {count_open}"
                lines.append(f"\t\t{l6_details}")

    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to {excel_path}")
    return lines
====

# addd open pos
import pandas as pd
import win32com.client
import tkinter as tk
from tkinter import simpledialog

# --- Helper to detect missing values robustly ---
def is_missing(val):
    if pd.isna(val):
        return True
    s = str(val).strip()
    return s == "" or s.lower() == "unspecified"

# Step 1: Read base org data (ACTUALS)
df = pd.read_excel("org_data.xlsx")
df["Employee Name"] = df["Employee Name"].astype(str).str.strip().replace("Unspecified","")
df["Functional Manager Employee Name"] = df["Functional Manager Employee Name"].astype(str).str.strip().replace("Unspecified","")
df["Employee ID"] = pd.to_numeric(df["Employee ID"], errors="coerce").astype("Int64")
df["Functional Manager Employee ID"] = pd.to_numeric(df["Functional Manager Employee ID"], errors="coerce").astype("Int64")

# Step 1b: Read lookup file for Position Title
lookup = pd.read_excel("ghaOct.xlsx", sheet_name="Headcount - Employee Detail")
lookup["Employee ID"] = pd.to_numeric(lookup["Employee ID"], errors="coerce").astype("Int64")

# Merge Position Title into df
df = df.merge(lookup[["Employee ID","Position Title"]], on="Employee ID", how="left")

# Step 1c: Re-read org_data.xlsx for open positions
needed_cols = ["Employee ID","Employee Name","Functional Manager Employee ID",
               "Functional Manager Employee Name","Stack","FTE FCST","PID"]
df_base = pd.read_excel("org_data.xlsx", usecols=needed_cols)

mask = (
    (df_base["Stack"] != "ACTUALS") &
    (df_base["FTE FCST"] > 0) &
    df_base["PID"].apply(lambda x: not is_missing(x))
)
df_open_candidates = df_base[mask].drop_duplicates(subset=["PID"]).copy()

# Step 1d: Load open_position.xlsx
open_pos = pd.read_excel("open_position.xlsx",
                         usecols=["Position Number","Position Title",
                                  "Functional Manager Position Level Employee ID",
                                  "Functional Manager Position Level Employee Name"])
for col in open_pos.columns:
    open_pos[col] = open_pos[col].astype(str).str.strip().replace("Unspecified","")

open_pos["Position Number"] = pd.to_numeric(open_pos["Position Number"], errors="coerce").astype("Int64")
open_pos["Functional Manager Position Level Employee ID"] = pd.to_numeric(open_pos["Functional Manager Position Level Employee ID"], errors="coerce").astype("Int64")

# Step 1e: Merge candidates with open pos report
df_open_enriched = df_open_candidates.merge(
    open_pos,
    left_on="PID",
    right_on="Position Number",
    how="left"
)

# Skip rows where Position Number is missing (PID not found in open pos report)
df_open_enriched = df_open_enriched[~df_open_enriched["Position Number"].isna()].copy()

# Add placeholders for open positions
df_open_enriched["Employee ID"] = pd.NA
df_open_enriched["Employee Name"] = ""

# Step 1f: Combine ACTUALS + Open Positions
df_final = pd.concat([df, df_open_enriched], ignore_index=True)

# Step 2: Traverse Level 5/6 using IDs
output_rows = []

def traverse_level5(level4_id):
    level5_reports = df_final[df_final["Functional Manager Employee ID"] == level4_id]
    for _, l5 in level5_reports.iterrows():
        l5_id = l5["Employee ID"]

        if is_missing(l5_id):
            output_rows.append([level4_id, None, None, 0, l5.get("PID",""), l5.get("Position Title","")])
            continue

        level6_reports = df_final[df_final["Functional Manager Employee ID"] == l5_id]
        if level6_reports.empty:
            output_rows.append([level4_id, l5_id, None, 0, l5.get("PID",""), l5.get("Position Title","")])
        else:
            for _, l6 in level6_reports.iterrows():
                l6_id = l6["Employee ID"]
                count = df_final[df_final["Functional Manager Employee ID"] == l6_id].shape[0]

                if is_missing(l6_id):
                    output_rows.append([level4_id, l5_id, None, 0, l6.get("PID",""), l6.get("Position Title","")])
                else:
                    output_rows.append([level4_id, l5_id, l6_id, count, l6.get("PID",""), l6.get("Position Title","")])

# Step 3: Export indented hierarchy with details
def export_indented_to_excel(out_df, excel_path="OrgChart_Indented.xlsx", level4_id=None):
    lines = []
    if level4_id is not None:
        mgr_row = df_final[df_final["Employee ID"] == level4_id].iloc[0]
        mgr_details = f"{mgr_row['Employee Name']} | {mgr_row.get('Position Title','')}\n{mgr_row.get('GCB','')} | {mgr_row.get('Country R3','')}"
        lines.append(mgr_details)

    for l5_id, group in out_df.groupby("Level 5 Employee ID"):
        if pd.notna(l5_id):
            l5_row = df_final[df_final["Employee ID"] == l5_id].iloc[0]
            l5_details = f"{l5_row['Employee Name']} | {l5_row.get('Position Title','')}\n{l5_row.get('GCB','')} | {l5_row.get('Country R3','')}"
            lines.append(f"\t{l5_details}")
        else:
            pos_title = group["Position Title"].iloc[0]
            pid = group["PID"].iloc[0]
            lines.append(f"\tOpen Position ({pid}) | {pos_title}")

        for _, row in group.iterrows():
            l6_id = row["Level 6 Employee ID"]
            count = row["Count of Direct Reports"]
            pid = row["PID"]
            pos_title = row["Position Title"]

            if pd.notna(l6_id):
                l6_row = df_final[df_final["Employee ID"] == l6_id].iloc[0]
                l6_details = (
                    f"{l6_row['Employee Name']} | {l6_row.get('Position Title','')}\n"
                    f"{l6_row.get('GCB','')} | {l6_row.get('Country R3','')}\n"
                    f"→ Reports: {count}"
                )
                lines.append(f"\t\t{l6_details}")
            else:
                lines.append(f"\t\tOpen Position ({pid}) | {pos_title}")

    pd.DataFrame({"Hierarchy": lines}).to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to {excel_path}")
    return lines

# Step 4: Write to PowerPoint
def write_indented_to_ppt(lines, ppt_path="OrgChart_Output.pptx"):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()
    slide = pres.Slides.Add(1, 12)

    textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
    tr = textbox.TextFrame.TextRange
    text_content = "\r".join(lines)
    tr.Text = text_content

    pres.SaveAs(ppt_path)
    print(f"PPT saved: {ppt_path}")

# Step 5: GUI to get manager ID
root = tk.Tk()
root.withdraw()
manager_id_str = simpledialog.askstring("Org Chart Builder", "Enter Level 4 Manager Employee ID:")

if manager_id_str:
    try:
        manager_id = int(manager_id_str)
        if manager_id not in df_final["Employee ID"].values:
            print(f"Manager ID {manager_id} not found in data.")
        else:
            traverse_level5(manager_id)
            out_df = pd.DataFrame(output_rows, columns=["Level 4 Manager ID","Level 5 Employee ID","Level 6 Employee ID","Count of Direct Reports","PID","Position Title"])
            out_df.to_excel("OrgChart_Flat.xlsx", index=False)

            lines = export_indented_to_excel(out_df, "OrgChart_Indented.xlsx", manager_id)
            write_indented_to_ppt(lines, f"OrgChart_{manager_id}.pptx")
    except Exception as e:
        print(f"Error: {e}")
///////////////////
import pandas as pd
import win32com.client
import tkinter as tk
from tkinter import simpledialog

# Step 1: Read base org data
df = pd.read_excel("org_data.xlsx")
df["Employee Name"] = df["Employee Name"].astype(str).str.strip()
df["Functional Manager Employee Name"] = df["Functional Manager Employee Name"].astype(str).str.strip()
df["Employee ID"] = pd.to_numeric(df["Employee ID"], errors="coerce").astype("Int64")
df["Functional Manager Employee ID"] = pd.to_numeric(df["Functional Manager Employee ID"], errors="coerce").astype("Int64")

# Step 1b: Read lookup file for Position Title
lookup = pd.read_excel("ghaOct.xlsx", sheet_name="Headcount - Employee Detail")
lookup["Employee ID"] = pd.to_numeric(lookup["Employee ID"], errors="coerce").astype("Int64")

# Merge Position Title into df
df = df.merge(lookup[["Employee ID","Position Title"]], on="Employee ID", how="left")

# Step 2: Traverse Level 5/6 using IDs
output_rows = []

def traverse_level5(level4_id):
    level5_reports = df[df["Functional Manager Employee ID"] == level4_id]
    for _, l5 in level5_reports.iterrows():
        l5_id = l5["Employee ID"]

        level6_reports = df[df["Functional Manager Employee ID"] == l5_id]
        if level6_reports.empty:
            output_rows.append([level4_id, l5_id, None, 0])
        else:
            for _, l6 in level6_reports.iterrows():
                l6_id = l6["Employee ID"]
                count = df[df["Functional Manager Employee ID"] == l6_id].shape[0]
                output_rows.append([level4_id, l5_id, l6_id, count])

# Step 3: Export indented hierarchy with details (ID‑based)
def export_indented_to_excel(out_df, excel_path="OrgChart_Indented.xlsx", level4_id=None):
    lines = []
    # Root manager details
    if level4_id is not None:
        mgr_row = df[df["Employee ID"] == level4_id].iloc[0]
        mgr_details = f"{mgr_row['Employee Name']} | {mgr_row.get('Position Title','')}\n{mgr_row.get('GCB','')} | {mgr_row.get('Country R3','')}"
        lines.append(mgr_details)

    for l5_id, group in out_df.groupby("Level 5 Employee ID"):
        l5_row = df[df["Employee ID"] == l5_id].iloc[0]
        l5_details = f"{l5_row['Employee Name']} | {l5_row.get('Position Title','')}\n{l5_row.get('GCB','')} | {l5_row.get('Country R3','')}"
        lines.append(f"\t{l5_details}")

        for _, row in group.iterrows():
            l6_id = row["Level 6 Employee ID"]
            count = row["Count of Direct Reports"]

            if pd.notna(l6_id):
                l6_row = df[df["Employee ID"] == l6_id].iloc[0]
                l6_details = (
                    f"{l6_row['Employee Name']} | {l6_row.get('Position Title','')}\n"
                    f"{l6_row.get('GCB','')} | {l6_row.get('Country R3','')}\n"
                    f"→ Reports: {count}"
                )
                lines.append(f"\t\t{l6_details}")

    df_out = pd.DataFrame({"Hierarchy": lines})
    df_out.to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to {excel_path}")
    return lines

# Step 4: Write to PowerPoint (plain indented text, no SmartArt)
def write_indented_to_ppt(lines, ppt_path="OrgChart_Output.pptx"):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()
    slide = pres.Slides.Add(1, 12)

    textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
    tr = textbox.TextFrame.TextRange
    text_content = "\r".join(lines)
    tr.Text = text_content

    pres.SaveAs(ppt_path)
    print(f"PPT saved: {ppt_path}")

# Step 5: GUI to get manager ID
root = tk.Tk()
root.withdraw()  # hide main window
manager_id_str = simpledialog.askstring("Org Chart Builder", "Enter Level 4 Manager Employee ID:")

if manager_id_str:
    try:
        manager_id = int(manager_id_str)
        if manager_id not in df["Employee ID"].values:
            print(f"Manager ID {manager_id} not found in data.")
        else:
            traverse_level5(manager_id)
            out_df = pd.DataFrame(output_rows, columns=["Level 4 Manager ID","Level 5 Employee ID","Level 6 Employee ID","Count of Direct Reports"])
            out_df.to_excel("OrgChart_Flat.xlsx", index=False)

            lines = export_indented_to_excel(out_df, "OrgChart_Indented.xlsx", manager_id)
            write_indented_to_ppt(lines, f"OrgChart_{manager_id}.pptx")
    except Exception as e:
        print(f"Error: {e}")

================================
-- based on names- (prob with ambuiguoty in names of employees--
import pandas as pd
import win32com.client
import tkinter as tk
from tkinter import simpledialog

# Step 1: Read base org data
df = pd.read_excel("org_data.xlsx")
df["Employee Name"] = df["Employee Name"].str.strip()
df["Functional Manager Employee Name"] = df["Functional Manager Employee Name"].str.strip()
df["Employee ID"] = pd.to_numeric(df["Employee ID"], errors="coerce").astype("Int64")
df["Functional Manager Employee ID"] = pd.to_numeric(df["Functional Manager Employee ID"], errors="coerce").astype("Int64")

# Step 1b: Read lookup file for Position Title
lookup = pd.read_excel("ghaOct.xlsx", sheet_name="Headcount - Employee Detail")
lookup["Employee ID"] = pd.to_numeric(lookup["Employee ID"], errors="coerce").astype("Int64")

# Merge Position Title into df
df = df.merge(lookup[["Employee ID","Position Title"]], on="Employee ID", how="left")

# Step 2: Traverse Level 5/6
output_rows = []

def traverse_level5(level4_id, level4_name):
    level5_reports = df[df["Functional Manager Employee ID"] == level4_id]
    for _, l5 in level5_reports.iterrows():
        l5_id = l5["Employee ID"]
        l5_name = l5["Employee Name"]

        level6_reports = df[df["Functional Manager Employee ID"] == l5_id]
        if level6_reports.empty:
            output_rows.append([level4_name, l5_name, "", 0])
        else:
            for _, l6 in level6_reports.iterrows():
                l6_id = l6["Employee ID"]
                l6_name = l6["Employee Name"]
                count = df[df["Functional Manager Employee ID"] == l6_id].shape[0]
                output_rows.append([level4_name, l5_name, l6_name, count])

# Step 3: Export indented hierarchy with details
def export_indented_to_excel(out_df, excel_path="OrgChart_Indented.xlsx", level4_name="Manager"):
    lines = [level4_name]

    for l5_name, group in out_df.groupby("Level 5 Employee"):
        l5_row = df[df["Employee Name"] == l5_name].iloc[0]
        l5_details = f"{l5_name} | {l5_row.get('Position Title','')}\n{l5_row.get('GCB','')} | {l5_row.get('Country R3','')}"
        lines.append(f"\t{l5_details}")

        for _, row in group.iterrows():
            l6_name = row["Level 6 Employee"]
            count = row["Count of Direct Reports"]

            if l6_name:
                l6_row = df[df["Employee Name"] == l6_name].iloc[0]
                l6_details = (
                    f"{l6_name} | {l6_row.get('Position Title','')}\n"
                    f"{l6_row.get('GCB','')} | {l6_row.get('Country R3','')}\n"
                    f"→ Reports: {count}"
                )
                lines.append(f"\t\t{l6_details}")

    df_out = pd.DataFrame({"Hierarchy": lines})
    df_out.to_excel(excel_path, index=False)
    print(f"Indented hierarchy exported to {excel_path}")
    return lines

# Step 4: Write to PowerPoint and convert to SmartArt Org Chart
def write_indented_to_ppt(lines, ppt_path="OrgChart_Output.pptx"):
    ppt = win32com.client.Dispatch("PowerPoint.Application")
    ppt.Visible = True
    pres = ppt.Presentations.Add()
    slide = pres.Slides.Add(1, 12)

    textbox = slide.Shapes.AddTextbox(1, 50, 50, 600, 400)
    tr = textbox.TextFrame.TextRange
    text_content = "\r".join(lines)
    tr.Text = text_content

    # Convert textbox to SmartArt Org Chart
    try:
        textbox.ConvertToSmartArt()
        textbox.SmartArt.Layout = ppt.SmartArtLayouts("urn:microsoft.com/office/officeart/2005/8/layout/OrganizationChart")
        print("Converted to SmartArt Org Chart")
    except Exception as e:
        print(f"Could not convert to SmartArt: {e}")

    pres.SaveAs(ppt_path)
    print(f"PPT saved: {ppt_path}")

# Step 5: GUI to get manager name
root = tk.Tk()
root.withdraw()  # hide main window
manager_name = simpledialog.askstring("Org Chart Builder", "Enter Level 4 Manager Name:")

if manager_name:
    try:
        manager_id = df.loc[df["Employee Name"] == manager_name, "Employee ID"].iloc[0]
        traverse_level5(manager_id, manager_name)
        out_df = pd.DataFrame(output_rows, columns=["Level 4 Manager","Level 5 Employee","Level 6 Employee","Count of Direct Reports"])
        out_df.to_excel("OrgChart_Flat.xlsx", index=False)

        lines = export_indented_to_excel(out_df, "OrgChart_Indented.xlsx", manager_name)
        write_indented_to_ppt(lines, f"OrgChart_{manager_name.replace(' ','_')}.pptx")
    except IndexError:
        print(f"Manager '{manager_name}' not found in data.")
