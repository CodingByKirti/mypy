change
# Pick correct comment
if is_likely_same_person:
    final_comment = 'Duplicate name against same PS ID, might be same person.'
else:
    final_comment = 'Same PS ID has unrelated names (likely different people).'
....

# If there's no email, and more than 2 very different names, flag as unrelated
if not has_email and len(set(norm_names)) > 2:
    final_comment = 'Same PS ID has unrelated names (likely different people).'
elif is_likely_same_person:
    final_comment = 'Duplicate name against same PS ID, might be same person.'
else:
    final_comment = 'Same PS ID has unrelated names (likely different people).'
...........


import pandas as pd

def normalize_bpcc_and_billing_entities(main_df: pd.DataFrame, last_month_df: pd.DataFrame) -> pd.DataFrame:
    # Copy to avoid changing original columns
    main_df = main_df.copy()
    last_month_df = last_month_df.copy()

    # Normalize BPCC: string, strip spaces, remove leading zeros
    main_df['BPCC_temp'] = main_df['Business Partner Cost Center'].astype(str).str.strip().str.lstrip('0')
    last_month_df['BPCC_temp'] = last_month_df['Business Partner Cost Center'].astype(str).str.strip().str.lstrip('0')

    # Normalize Billing Entity
    main_df['Billing_Entity_temp'] = main_df['Billing Entity'].astype(str).str.strip().str.upper()
    last_month_df['Billing_Entity_temp'] = last_month_df['Billing Entity'].astype(str).str.strip().str.upper()

    # Create combo key for matching (except for BPCCs starting with '9')
    main_df['combo_key'] = main_df.apply(
        lambda row: f"{row['BPCC_temp']}|{row['Billing_Entity_temp']}" if not str(row['BPCC_temp']).startswith('9') else None,
        axis=1
    )

    last_month_df['combo_key'] = last_month_df.apply(
        lambda row: f"{row['BPCC_temp']}|{row['Billing_Entity_temp']}" if not str(row['BPCC_temp']).startswith('9') else None,
        axis=1
    )

    # Build set of valid combo keys from last month
    valid_combos = set(last_month_df['combo_key'].dropna())

    # Ensure 'Comment' column exists
    if 'Comment' not in main_df.columns:
        main_df['Comment'] = ""

    # Identify rows where combo_key is not in last_month_df and BPCC does not start with '9'
    for idx, row in main_df.iterrows():
        combo = row['combo_key']
        bpcc = row['BPCC_temp']

        if combo is not None and combo not in valid_combos:
            # Try to find a matching BPCC in last_month_df
            match = last_month_df[last_month_df['BPCC_temp'] == bpcc]

            if not match.empty:
                new_entity = match['Billing_Entity_temp'].iloc[0]
                old_entity = row['Billing Entity']

                # Update Billing Entity
                main_df.at[idx, 'Billing Entity'] = new_entity

                # Update comment
                comment = f"Mismatch in Billing Entity; replaced '{old_entity}' with '{new_entity}' based on BPCC."
                existing_comment = main_df.at[idx, 'Comment']
                if comment not in existing_comment:
                    updated_comment = f"{existing_comment} | {comment}".strip(" |")
                    main_df.at[idx, 'Comment'] = updated_comment

    # Drop temporary columns
    main_df.drop(columns=['BPCC_temp', 'Billing_Entity_temp', 'combo_key'], inplace=True, errors='ignore')

    return main_df